;******************************************************************************
; This software is provided "as is" without warranty.  National Semiconductor
; expressly disclaims implied warranties of merchantibility and/or fitness
; for a particular purpose.  NSC shall not be responsible for any loss to
; recipient, customers or third-parties by failure of this software to 
; function.  NSC shall not be liable for any direct, indirect, special,
; incidental or consequential damages, whether based on contract, tort or any
; other legal theory, even if NSC has been advised of the possibliity of such
; damages.
;******************************************************************************

;******************************************************************************
; merged and debugged by migry
; migrytech@gmail.com
; migry@ns32000.com
;
; NOTE: "The Force" is the name of a homebrew NS32016 system built on a multibus card,
;       back in 1986, but only re-surrected and got working in 2020.
;
; In order to re-create the (EP)ROMs needed to run the TDS on the above system,
; which has a different hardware configuration to the DB16000/DB32000 all the 
; assembly source code files for TDS (found on the internet) have been merged into a
; single file in order to do away with the need for a linker, and new code has been
; added to support "The Force".
; 
; The MigryTech assembler recognises most but not all the syntax of the National Semicondutor
; NS32016 assembler, but also adds C preprocessor hash commands: #define, #ifdef, and #endif
; which is used to allow the same code to be assembled for different platforms.
; All the assembly source code files for TDS (found on the internet) have been merged into a
; single file in order to do away with the need for a linker.
; 
; The MigryTech assembler recognises most but not all the syntax of the National Semicondutor
; NS32016 assembler, but also adds C preprocessor hash commands: #define, #ifdef, and #endif
; which is used to allow the same code to be assembled for different platforms.
;
; The original source files each assemble to a separate module, and use the support of modules
; of the NS32016 CPU. In merging all the source files into a single composite source file
; there is only one module, and so calls to other modules using the CXP mechanism have been
; simplified to BSR. Also all the global variables for each of the original modules have been
; merged into the same area and are pointed to by the Static Base register. In the original
; code access to variables in a different module use the "EXT" addressing mode, whereas in 
; the composite code the simpler (and faster) "SB" addressing mode is used.
; The module structure and interrupt structure, which were likely created by the linker,
; have be re-created manually. The need for a link table is removed.
;
; In order to help dedbug the code, additional code can be conditionally assembled
; which causes write to a fixed "debug" location (DEBUGD). This can for example be used
; to trigger a logic analyser.
;
;******************************************************************************

; 09-Jun-2020 - V0.01 First write. Merge all modules. Assemble and fix bugs.
; 10-Jun-2020 - V0.02 Change CXP to BSR and RXP to RET. Merge more modules.
;             - Eliminate duplicate lables (usually SB or EQU).
; 19-Jun-2020 - V0.03 Create missing module tables for traps. Now no longer crashing!
;             - SB appears to be changed, so add debug writes in MAINLP
; 20-Jun-2020 - V0.03 Change search for top of memory (TheForce only) to fixed value.
; 24-Aug-2020 - V0.03 Change for new Force mk2 hardware and new UART address.
; 27-Aug-2020 - V1.00 Correct the UART address. Doh!
; 18-Sep-2020 - V1.01 Add ICU initialisation code.
; 12-Nov-2020 - V1.02 Add ICU timer code.
; 18-Dec-2020 - V1.04 Fake DIP switches for FORCE
; 17-Jan-2021 - V1.10 Add tape save and load to/from RAM.
; 18-Jan-2021 - V1.11 Minor tidy up.
; 21-Jan-2021 - V1.12 Fix bug with tape write.
; 25-Jan-2021 - V1.13 Debug tape write and read.
; 27-Jan-2021 - V1.14 Start to debug interrupt behaviour. Use ICU LEDs for debug.
; 28-Jan-2021 - V1.15 Fix interrupt problem and add more comments.
; 30-Jan-2021 - V1.16 Minor tweak to TRACE interrupt.
; 31-Jan-2021 - V1.17 Add undefined instruction trap
; 02-Feb-2021 - V1.18 Add undefined instruction trap
; 04-Feb-2021 - V1.19 Still debugging interrupts - write out PSR for debug.
;             - V1.20 Fix interrupt problem, caused by out by one bit error.
;             - V1.21 Fix interrupt count on LED bar.
; 05-Feb-2021 - V1.22 Add ICU vector support.
; 05-May-2024 - V1.23 Make changes so that DB16000 version assembles.


;       DCT16 - DB16000A Diagnostic Monitor

; remove/add add X to generate appropriate #defines
#define XTHEFORCE
#define XTHEFORCE_MK1
#define XTHEFORCE_MK2
#define XDEBUGTHEFORCE
#define  DB16000

;+++++++++++++
#ifdef DB16000
;+++++++++++++
RAMBOT:   .EQU 0x8000 
SB_MAIN:  .EQU RAMBOT+0
SB_NVIRT: .EQU SB_MAIN
SB_NMIRT: .EQU SB_MAIN
SB_ABTRT: .EQU SB_MAIN
SB_FPURT: .EQU SB_MAIN
SB_ILLRT: .EQU SB_MAIN
SB_SVCRT: .EQU SB_MAIN
SB_DVZRT: .EQU SB_MAIN
SB_FLGRT: .EQU SB_MAIN
SB_BPTRT: .EQU SB_MAIN
SB_TRCRT: .EQU SB_MAIN
SB_UNINS: .EQU SB_MAIN
#endif
;+++++++++++++

;@@@@@@@@@@@@@@
#ifdef THEFORCE
;@@@@@@@@@@@@@@
RAMBOT:   .EQU 0x8000 
SB_MAIN:  .EQU RAMBOT+0
SB_NVIRT: .EQU SB_MAIN
SB_NMIRT: .EQU SB_MAIN
SB_ABTRT: .EQU SB_MAIN
SB_FPURT: .EQU SB_MAIN
SB_ILLRT: .EQU SB_MAIN
SB_SVCRT: .EQU SB_MAIN
SB_DVZRT: .EQU SB_MAIN
SB_FLGRT: .EQU SB_MAIN
SB_BPTRT: .EQU SB_MAIN
SB_TRCRT: .EQU SB_MAIN
SB_UNINS: .EQU SB_MAIN
ALTSTACK: .EQU 0xb700 
ISTACK:   .EQU 0xb800 
SUPSTACK: .EQU 0xbfe0 
RAMTOP:   .EQU 0xbff0           ; reserve locations for fake SWITCHP and DEBUGD
; miscellaneous - non TDS
DEBUGD:   .EQU 0xbffc
SWITCHP: .EQU  0xbffa ; DIP SWICHES FAKE ADDRESS for FORCE
               ; S4  S3  S2  s1   Baud rate
               ; on  on  on  on   19200
               ; off off off off     50
               ; S5 = FPU installed
               ; S6 = MMU installed
               ; S7 = Off enables testing of 8255 PPI

#endif
;@@@@@@@@@@@@@@

;+++++++++++++
#ifdef DB16000
;+++++++++++++
STACKL: .EQU    H'500           ; STACK AREA END RELATIVE TO BEGIN OF SB
STATIC: .EQU    H'C000
#endif
;+++++++++++++

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;                       CONSTANTS                       ;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;
;     GLOBAL CONSTANTS
;

SHRT:   .EQU    0       ;RADIX SELECTION VALUES
LNG:    .EQU    1
DEC:    .EQU    2
HEX:    .EQU    3

STALON: .EQU    0               ; STAND ALONE INDICATOR
TRANSP: .EQU    1               ; TRANSPARENT MODE
TRUE:   .EQU    1               ; DEFINE LOGICAL TRUE
FALSE:  .EQU    0               ; DEFINE LOGICAL FALSE
TRMA:   .EQU    0               ; TERMINAL A
TRMB:   .EQU    1               ; TERMINAL B
NSFBR:  .EQU    14              ; NUMBER OF SOFTWARE BREAK-POINTS

; use following consts with CBIT and SBIT
PSR_T:  .EQU    1               ; T BIT IN PSR FOR REV E
PSR_U:  .EQU    8               ; U BIT IN PSR
PSR_S:  .EQU    9               ; S BIT IN PSR
PSR_P:  .EQU    10              ; P BIT IN PSR

; use following consts with BICPSR and BISPSR
PSRC:   .EQU    H'001           ; PSR CARRY
PSRT:   .EQU    H'002           ; PSR TRACE
PSRL:   .EQU    H'004           ; PSR LOW
PSRV:   .EQU    H'010           ; PSR OVERFLOW
PSRF:   .EQU    H'020           ; PSR FLAG
PSRZ:   .EQU    H'040           ; PSR ZERO
PSRN:   .EQU    H'080           ; PSR NEGATIVE
PSRU:   .EQU    H'100           ; PSR SUPERVISOR MODE
PSRS:   .EQU    H'200           ; PSR STACK
PSRP:   .EQU    H'400           ; PSR PENDING
PSRI:   .EQU    H'800           ; PSR I NUMBER

BPR_BE: .EQU    29              ; BE BIT IN BPR REG OF MMU
MSR_NT: .EQU    25              ; NT BIT IN MSR
MOMOD:  .EQU    5               ; MONITOR MODULE NUMBER
BPTC:   .EQU    H'F2            ; BPT INSTRUCTION
NOERR:  .EQU    -128            ;NO ERROR FLAG
;
;       HUMON GLOBALS
INITMOD:.EQU     0              ;VALUE FOR FLAG INITIALIZATION
PRNTAC: .EQU     5              ;FLAG TO PRINT ALL CPU REGS VIA PROCESS
HUTERM: .EQU     H'C            ; TERMINAL SETTING FOR FULL DUPLEX
ALONE:  .EQU     H'E            ; REAL STAND ALONE INDICATOR

;
;     ASCII CHARACTERS
;
CNTRA:  .EQU    H'1             ; CNTR/A
CNTRB:  .EQU    2               ; CNTR/B
BACKSP: .EQU    8               ; BACK SPACE CHARACTER
LF:     .EQU    H'0A            ; LINE FEED
CR:     .EQU    H'0D            ; RETURN
XON:    .EQU    H'11
XOFF:   .EQU    H'13
CNTRT:  .EQU    H'14            ; CNTR/T
bell:   .equ    'G' & x'1f
SPACE:  .EQU    H'20            ; SPACE CHARACTER
COMMA:  .EQU    H'2C            ; COMMA CHARACTER
DOT:    .EQU    H'2E            ; DOT
DELETE: .EQU    H'7F                    ; BACK SPACE CHARACTER
;ENDLIN: .EQU    CR                      ; END OF LINE CHARACTER
PRINTE: .EQU    0               ; END OF LINE INDICATOR
GETI:   .EQU    0               ; GET INDICATOR
PUTI:   .EQU    1               ; PUT INDICATOR


;;;STACKL: .EQU    H'500           ; STACK AREA END RELATIVE TO BEGIN OF SB
;;;STATIC: .EQU    H'C000

; from acmd.32k

NOTRC:  .EQU    0               ; FLAG OF NO TRACE ACTIVE
STPN:   .EQU    1               ; FLAG OF STEP N
STU:    .EQU    2               ; FLAG OF STEP UNTIL
STW:    .EQU    3               ; FLAG OF STEP WHILE
STBRK:  .EQU    4               ; FLAG OF BREAK STEP
#ifdef THEFORCE
TRCRI:  .EQU    8
#endif

SPACES: .EQU '  '
EVRF:   .EQU    12              ; VERIFY ERROR CONSTANT
ECRC:   .EQU    7               ; CRC ERROR
ESRC:   .EQU    8               ; SEARCH ERROR
ECXP:   .EQU    10              ; ERROR MORE THEN ONE CXP COMMAND
EMOD:   .EQU    11
NLIN:   .EQU    16              ; NUMBER OF BYTE IN A LINE
MOVC:   .EQU    0               ; # OF MOVE COMMAND
SRCHC:  .EQU    2               ; # OF SRCH COMMAND
PRC:    .EQU    12              ; DEFINE PRINT COMMAND
CHCM:   .EQU    13              ; CHANGE COMMAND NUMBER
JSBC:   .EQU    7               ; JSB COMMAND NUMBER
STWC:   .EQU    6               ; STW COMMAND NUMBER

msr_ft:         .equ    23
msr_ut:         .equ    24
ptbr_mask:      .equ    x'80fffc00
bpr_mask:       .equ    x'00ffffff
bcnt_mask:      .equ    bpr_mask
sc_mask:        .equ    x'ffffffff

; TABLE OF EQUATES - ahelpio

PASS1:  .EQU    1       ;PASS 1 FLAG
PASS2:  .EQU    2       ;PASS 2 FLAG
 
BYTLONG:        .EQU    0       ;BASIC CODING FOR i TYPE
WRDLONG:        .EQU    1       ; i=    WORD 
DOUBLNG:        .EQU    3       ; i=    DOUBLE

SHRT_REAL:      .EQU    0       ;FLOATING POINT CONVERSION CONSTANTS
LONG_REAL:      .EQU    1

NUMOFINST:      .EQU    131     ; TOTAL NUMBER OF INSTRUCTIONS

BIT0:   .EQU    1       ;i CODING AREA CATEGORY
BIT8:   .EQU    2       ; CODE i @BIT0 OR BIT8 IF=0 THEN NO i

; from ahelp.32k

;EXTRACTION DATA FOR OPERAND CODING
; OPCODE FIELD DEFINITION:
;       1. LENGTH OF ASCII INSTRUCTION STRING
;       2. LENGTH OF BASIC OPCODE
;       3. CATEGORY OF LENGTH DIESIGNATOR
;               A. 0=NO LENGTH SPECIFICATION
;               B. 1=LENGTH SPECIFIED IN OPCODE FIELD BIT 0-1
;               C. 2=LENGHT SPECIFIED IN OPCODE FIELD BIT 8-9
;                       A '$' IS POSITION OF BWD OPTION
;       4. OPCODE START BIT OF OPERAND 1
;       5. OPCODE START BIT OF OPERAND 2
;       6. OPCODE START BIT OF OPERAND 3
;       7. OPCODE START BIT OF OPERAND 4

;(   #1    ) LENGTH OF ASCII NEUMONIC
F1OFF:  .EQU    0       ;OFFSET TO START OF FIRST DATA FIELD
F1LGTH: .EQU    3       ;FIELD WIDTH = 3 BITS
;
;(   #2    ) LENGTH OF BASIC INSTRUCTION CODE
F2OFF:  .EQU    3       ;OFFSET TO START OF FIELD 2
F2LGTH: .EQU    2       ;FIELD WIDTH = 2 BITS
;
;(   #3    ) i CATEGORY
F3OFF:  .EQU    5       ;OFFSET TO FIELD 3
F3LGTH: .EQU    2       ;FIELD WIDTH = 2 BITS
;
FLGTHO: .EQU    5       ;WIDTH OF OPERAND MODE CODING START FIELD

;(   #4    ) START OF CODING AREA FOR FIRST OPERAND
F4OFF:  .EQU    7       ;OFFSET TO THAT FIELD
F4LGTH: .EQU    FLGTHO  ;WIDTH IS OP FIELD WIDTH 5 BITS

;(   #5    ) START OF CODING AREA FOR SECOND OPERAND
F5OFF:  .EQU    12
F5LGTH: .EQU    FLGTHO

;(   #6    ) START OF CODING AREA FOR THIRD OPERAND 
F6OFF:  .EQU    17
F6LGTH: .EQU    FLGTHO

;(   #7    ) START OF FOURTH
F7OFF:  .EQU    22
F7LGTH: .EQU    FLGTHO

;  #8 SPECIAL CASE CONTROL
CATOFF:  .EQU   27
CAT:     .EQU   5

;       CATEGORIES OF SPECIAL CASES
;CATEGORY A
;       OPERAND IS A DISPLACEMENT
OP1_DISP:       .EQU    1
OP2_DISP:       .EQU    2
OP3_DISP:       .EQU    3
;       TREAT VALUE FOUND THERE AS AN ABSOLUTE TYPE ADDR MODE
;       ADDR MODE APPENDED TO END OF INST THEN OVERWRITTEN BY DISP VALUE.
;       FLAG USED IS OP_IS_DISP
;CATEGORY A1
;       OPERAND 3 IS FOR BLOCK INSTRUCTION
;       FOLLOW THIS ALOGORITHM  ENCODE 1BYT := ( DISP3 * i ) - i
BLOCK:  .EQU    OP3_DISP
;DO CHECK FOR CONFLICT WITH ACBi INSTRUCTION
;       IF (QUICK AND OP3_DISP) = TRUE 
;       THEN OP3_DISP := ADISP
;       ELSE OP3_DISP := BLOCK          
;CATEGORY B
;       OPERAND IS QUICK TYPE --OP 1 ONLY--
;       INSERT 4 BIT FIELD INTO BASIC INST CODE @F1OFF
;       FLAG USED IS INS_4BIT
QUICK:  .EQU    4
ACB_I:  .EQU    QUICK
;ACB_INS:       .EQU    OP3_DISP OR ACB_I
ACB_INS:        .EQU    OP3_DISP | ACB_I
;CATEGORY C 
;       OPERAND IS REGLIST --OP1 ONLY--
;       DO SPECIAL PARSE
;       INSERT 8 BITS @F1OFF
;       FLAG USED IS INS_8BIT
REGLIST:        .EQU    8

;CATEGORY D
;       OPERAND IS FOR STRING INST
;       DO SPECIAL PARSE
;       INSERT 4 BITS @F1OFF
;       FLAG USED IS INS_4BIT
STRNG:  .EQU    12

;CATEGORY E
;       OPERAND IS SPEC REG --OP1 ONLY--
;       INSERT 4 BITS @F1OFF
;       FLAG USED IS INS_4BIT
SPC_REG:        .EQU    16

;CATEGORY F
;       INST IS FILED TYPE LONG OR SHORT OP3-OP4
;       SPECIAL PARSE FOR SHORT
SHR_I:  .EQU    20      ;OP3+OP4=> DISP OP4
LNG_I:  .EQU    24      ;OP4 IS DISP FLAG

;CATEGORY F1
;       INST IS ARRAY TYPE  INDEX OR CHECK
;       OP3 IS READi.
ARAY_I: .EQU    LNG_I

;CATEGORY G
;       IF OP1 = IMMED THEN IMMED VALUE <= BYTE
;       FOR SHIFTY INST
;       FLAG USED IS IMM_IS_BYT
SWIP:   .EQU    28

;SPECIAL FOR ENTER INST
;ENT_I: .EQU    OP2_DISP OR REGLIST
ENT_I:  .EQU    OP2_DISP | REGLIST

;EQUATES FOR SEGMENT ID
SB_SEG: .EQU    2
PC_SEG: .EQU    1
;EQUATES FOR SYMBOL ID
SB_SYM: .EQU    2
PC_SYM: .EQU    1

;               E Q U A T E S - ahelpio

READ:           .EQU    3
WRITE:          .EQU    4
MAIN:           .EQU    0        ;USER TERMINAL 
AUX:            .EQU    1        ;BLX351 PORT
READ_NUM:       .equ    -80

DEB_FLG:        .EQU    157

ASYNC:  .EQU    1               ;TIMOUT ERROR
FREC:   .EQU    2               ;BAD TAPE FORMAT
RCRC:   .EQU    4               ;BAD CRC ON READ
CYCLE:  .EQU    100             ;BAUD SETTING FOR DB16000 @ 7MHZ IN PROM

; from asub.32k

HANDB:  .EQU    0               ; HAND_SHAKING BIT OF OPMOD WORD
HANDLF: .EQU    1               ; ON HAND_SHAKING CR ECHO IS LF
ECHOB:  .EQU    2               ; ECHO BIT
ECHOLF: .EQU    3               ; FLAG FOR ECHO TO CR BY CR LF

;    S R D L I N     (STANDARD READ LINE PROCEDURE )
LINLIM: .EQU    72              ; MAX NUMBER OF CHARACTERS IN INPUT LINE

; from edit.32k

TEXT_BAD:       .EQU    2       ;BAD TEXT ERROR FLAG VALUE
LINE_LGTH:      .EQU    58      ;MAX LINE INPUT LENGTH
EMES_L:         .EQU    7

; from tio.32k

RLEN:           .EQU    128             ;TAPE RECORD LENGTH
LEADN:          .EQU    1000            ;NUMBER OF MASTER SYNC CHARACTERS
TMARK:          .EQU    H'A5            ;BYTE SYNC MARK CHAR
RECMARK:        .EQU    H'B7            ;START OF TEXT RECORD
NUL:            .EQU    0               ;
MAXCYCLE:       .EQU    2000            ;MAX CLK PULSE WAIT TIME
;CYCLE:         .EQU    65              ;FOR ISE WORK AT 5 MHZ CTTL(EMUL RAM)
;CYCLE:         .EQU    100             ;FOR ISE WORK AT 5 MHZ CTTL(TARGET RAM)
;CYCLE:         .EQU    100             ;FOR 7MHZ CTTL DB16000 (PROM SPEED)
;CYCLE:         .EQU    135             ;FOR 7MHZ CTTL DB16000 (RAM SPEED)
                                        ;EQUIVALENT TO APPROX 300 BAUD 
MAXWAIT:        .EQU    8000000         ;TAPE LEADER WAIT TIME
;FILTER:                .EQU    10              ;NOISE FILTER COUNT 10% PERIOD
FILTER:         .EQU    6               ;NOISE FILTER COUNT 10% PERIOD

PRI_BUSY:       .equ    0               ;offset to busy bit
PRI_SLCT:       .equ    5               ;offset to select bit
DC1:            .equ    h'11    ;cntrl char to select printer
        
BUSY_WAIT:      .equ    500000          ;max wait time for busy loop
STRB_TIME:      .equ    1               ;strobe pulse time **ISE TUNED**

;****NOTE****    reverse logic drivers on db16000
pTRUE:          .equ    0               ;GP logical true
pFALSE:         .equ    1               ;GP logical false

;
;  E R R O R    E X I T
;
ENMI:   .EQU    -8                      ; ERROR NMI
ENVI:   .EQU    -7                      ; ERROR NVI
EFPU:   .EQU    -6                      ; ERROR FPU
EDVZ:   .EQU    -5                      ; ERROR DIVIDE BY ZERO
EUND:   .EQU    -4                      ; ERROR UN-DEFINED INSTRUCTION
EFLG:   .EQU    -3                      ; ERROR FLAG TRAP
EBPT:   .EQU    -2                      ; ERROR BPT
EILL:   .EQU    -1                      ; ERROR ILLEGAL INSTRUCTION
ETRC:   .EQU    0                       ; ERROR TRACE TRAP
EXTR:   .EQU    1                       ; ERROR EXTERNAL ABORT
EBPR:   .EQU    2                       ; MMU BREAK POINT
ENST:   .EQU    3                       ; MMU NON-SEQ TRACE
EABT:   .EQU    4                       ; ERROR ABORT
EUSR:   .EQU    5                       ; USER ERROR
ESVC:   .EQU    9                       ; SVC ERROR
EVIO:   .EQU    11                      ; VIO PROTOCOL ERROR
EPND:   .EQU    6                       ; PENNDING INTERRUPT ERROR
ERTS:   .EQU    13                      ; RUN TIME SYSTEM ERROR.

; from pasutil.32k

CONST1: .equ    429496729       ; 2**32 / 10
CONST2: .equ    6               ; 2**32 mod 10

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; HARDWARE REGISTERS ;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;       MMU CONSTANTS
;
CNFMMU: .EQU    2               ; MMU BIT IN CONFIGURATION
MONT:   .EQU    0               ; FLAG MONITOR TIME
USERT:  .EQU    1               ; FLAG USER TIME
PNDMOD: .EQU    2               ; FLAG TO DELAY INTERRUPTS


byte_pat:       .equ    x'55            ;PPI data pattern

lor:            .equ    8               ;low order refresh bit
ms_wait:        .equ    1000            ;1000 ms (1 sec) refresh delay
cpms:           .equ    500             ;counts per millisecond (10Mhz cpu)
;
;       Switch S3 definitions
;
fpu_bit:        .equ    4
mmu_bit:        .equ    5
test_ppi:       .equ    6

on:             .equ    0
off:            .equ    1

;+++++++++++++
#ifdef DB16000
;+++++++++++++

; 0x000000 to 0x007fff - EPROM

; 0x008000 to 0x027FFF - Dual Port RAM

ram_start:      .equ    x'10000
ram_top:        .equ    x'27fff
ram_end:        .equ    ram_top - 8     ;leave room for PC, PSR & MOD
tru_pat:        .equ    x'5746          ;RAM test pattern data (rat & rrt)

; migry ; has to be changed since code assembles as far as this address
;;;INTTAB: .EQU    RESET+H'5100     ; INTERRUPT TABLE ADDRESS FOR VI.03 
;;;MODTB:  .EQU    RESET+H'5000     ; MODULE  TABLE ADDRESS FOR VI.03   
MODTB:  .EQU    RESET+H'6000        ; chnage due to code being found at 0x5000
INTTAB: .EQU    RESET+H'6100        ; possibly the tape I/O module was linked at a higher address to keep this area free?

;
;       usart definitions
;

io_base:        .equ    x'c00000
j2base:         .equ    io_base + x'00
j3base:         .equ    io_base + x'40

statp:          .equ    2
;DATAP:         .equ    0       already declared in monint

j2data:         .equ    j2base + DATAP
j2stat:         .equ    j2base + statp
j3data:         .equ    j3base + DATAP
j3stat:         .equ    j3base + statp

tx_rdy:         .equ    0               ; TX-RDY bit of status word
rx_rdy:         .equ    1               ; RX_RDY bit of status word

; Configuration switches 0xc00030 to 0xc0003e
;SWITCHP:       .equ    statbase                already declared
statbase:       .equ    io_base + x'30
diag_mode:      .equ    statbase + 8
ds1:            .equ    statbase + 6    ; LED1  0xc00036
ds2:            .equ    statbase + 4    ; LED2  0xc00034
ds3:            .equ    statbase + 2    ; LED3  0xc00032
diag_run:       .equ    ds1
diag_fail:      .equ    ds2
#endif
;+++++++++++++

;
;       PSR definitions
;
ipsr:   .equ    1 << 11         ;interrupt enable PSR bit
spsr:   .equ    1 << 9          ;stack selection bit
;
;       icu definitions
;
icu:    .equ    x'fffe00
hvct:   .equ    0 * 2
svct:   .equ    1 * 2
eltgl:  .equ    2 * 2
eltgh:  .equ    3 * 2
tpll:   .equ    4 * 2
tplh:   .equ    5 * 2
ipndl:  .equ    6 * 2
ipndh:  .equ    7 * 2
isrvl:  .equ    8 * 2
isrvh:  .equ    9 * 2
imskl:  .equ    10 * 2
imskh:  .equ    11 * 2
csrcl:  .equ    12 * 2
csrch:  .equ    13 * 2
fprtl:  .equ    14 * 2
fprth:  .equ    15 * 2
mctl:   .equ    16 * 2
ocasn:  .equ    17 * 2
ciptr:  .equ    18 * 2
pdat:   .equ    19 * 2
ips:    .equ    20 * 2
pdir:   .equ    21 * 2
cctl:   .equ    22 * 2
cictl:  .equ    23 * 2
lcsvl:  .equ    24 * 2
lcsvh:  .equ    25 * 2
hcsvl:  .equ    26 * 2
hcsvh:  .equ    27 * 2
lccvl:  .equ    28 * 2
lccvh:  .equ    29 * 2
hccvl:  .equ    30 * 2
hccvh:  .equ    31 * 2

CRunl:  .equ    1 << 2
CRunh:  .equ    1 << 3
;
;       mode control definitions
;
coutd:  .equ    1 << 6
ntar:   .equ    1 << 1
bus8:   .equ    0
frz:    .equ    1 << 3
clkm:   .equ    1 << 4
cfrz:   .equ    1 << 7

USRT_BN: .EQU   6               ; BIT NUBER THAT SELECT 7 OR 8 BIT PER CHAR

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;                     DATA SECTION                      ;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       TERMINAL RECORD
        .DSECT
INBUF:  .BLKB   80              ; INPUT BUFER
INLM:   .BLKB   4               ; POINTER TO LAST CHARACTER READ
OUTB:   .EQU    INBUF           ; OUTPUT BUFFER (SAME AS INPUT )
OUTLM:  .EQU    INLM            ; POINTER TO LAST BYTE IN OUTB TO BE PRINTED
TRMRLG: .EQU    $               ; TERMINAL RECORD LENGTH
        .ENDSEG

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;                   STATIC SECTION                      ;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        .STATIC                 ; DEFINE STATIC AREA

FIRST:  .BLKW   1               ; FOR USE IN DETERMINING WHETER TO RUN CONFIDENCE TEST
OPMOD:  .BLKB   1               ; OPERATION MODE VARIABLE
OPHND:  .BLKB   1               ; OPERATION MODE HAND_SHAKING
MON_USR:.BLKB   1               ; MONITOR/USER TIME FLAG
NOTECHO:.BLKB   1               ; TERM READ ECHO FLAG
NDTRM:  .BLKB   1               ; #  OF DEFULT TERMINAL
ERRTYP: .BLKB   1               ; ENTRY TYPE
CONFIG: .BLKB   1               ; CONFIGURATION BYTE
DTRM:   .BLKB   4               ; POINTER TO DEFULT TERMINAL BUFFER
L:      .BLKB   1               ; SAVE COMMAND NUMBER
        .ALIGN 2
SCRCH1: .BLKB   4               ; SCRACH 1
SCRCH2: .BLKB   4               ; SCRACH 2
STRTADR:.BLKB   4               ; SAVE RESET ADDRESS
ENDADR: .BLKB   4               ; SAVE END INTERRUPT ROUTINE ADDRESS
SEREA:
SVFP:   .BLKB   4               ; SAVE FP
SVUS:   .BLKB   4               ; SAVE US
SVIS:   .BLKB   4               ; SAVE IS
SVPC:   .BLKB   4               ; SAVE PC
SVMOD:  .BLKB   4               ; SAVE MOD
SVPSR:  .BLKB   4               ; SAVE PSR
SVINTB: .BLKB   4               ; SAVE INTB
SVR7:   .BLKB   4*7             ; SAVE R
SVR0:   .BLKB   4               ; SAVE R0
;
SVMSR:  .BLKB   4               ; SAVE MSR
SVBPR0: .BLKB   4               ; SAVE BPR0
SVBPR1: .BLKB   4               ; SAVE BPR1
DUM1:   .BLKB   4               ; DUMMY STORAGE
DUM2:   .BLKB   4               ; 
DUM3:   .BLKB   4               ; 
;
;
MNFP:   .BLKB   4               ; SAVE MONITOR FP
MNMSR:  .BLKB   4               ; SAVE MONITOR MSR
MNSP:   .BLKB   4               ; SAVE MONITOR SP
MNINTB: .BLKB   4               ; ""     ""    INTB
MNPSR:  .BLKB   2               ; MONITOR PSR
BRKAR:  .BLKB   NSFBR*4         ; SOFT-BPR ARRAY
STPCNT: .BLKB   4               ; STEP COUNTER
ACTBRK: .BLKB   4               ; # OF CURRENT BREAK
INS:    .BLKB   NSFBR           ; ARRAY OF BRPR INSTRUCTION SAVE
OLDPC:  .BLKB   16              ; SAVE OLD PC,US,IS,MOD IN CXP COMMAND
STUADD: .BLKB   16              ; STU COMMAND VERIABLE ADDRESS
#ifdef THEFORCE
SXPSR:  .BLKB   2               ; SAVE AREA FOR DEBUG
IRQCNT: .BLKB   1               ; IRQ count
#endif
STEPFLG: .BLKB  1               ; STEP FLAG
ACKFLG: .BLKB   1               ; ACKNOLEDGE FLAGE
CXPFLG: .BLKB   1               ; CXP COMMAND COUNTER
;
        .ALIGN 0x100
TERM1:  .BLKB   TRMRLG          ; TERMINAL 1 RECORD
TERM2:  .BLKB   TRMRLG          ; TERMINAL 2 RECORD
JMPRAM: .EQU    SCRCH1
;
;       SB AREA FOR HUMON NEEDS
DEFSET: .BLKB                   ; DEFUALT FLAG START AREA
ASCII:  .EQU    DEFSET          ; FLAG TO ACTIVATE ASCII DUMP ON PRINTOUT
SPACIT: .BLKB                   ; SPACES DURING DUMP
PROCESS:.BLKB                   ; COMPLEX COMMAND PROCESS FLAG
ALONFLG:.BLKB                   ; REAL STAND ALONE INDICATOR
NEGIT:  .BLKB                   ; FLAG TO NEGATE A NUMBER
        .ALIGN 2
LADDR:  .BLKD                   ; ADDRESS OF LAST LOAD
REGCHR: .BLKD                   ; REGISTER ID FOR PRINTOUT OF COMPLEX COMNDS.
CHRNUM: .EQU    REGCHR          ; NUMBER OF ASCII DUMP CHARS
BUFLGT: .EQU    36              ; CHR BUFFER FOR PROCESS AND ASCII DUMP
PROCBUF:.BLKB BUFLGT    ; CMPLX COMND BUFFER AREA
ASCDUMP:.EQU  PROCBUF   ; ASCDUMP AND PROBUF ARE EQUAL FOR ECONOMY
        .BLKD   4       ;BUFFER ZONE
TEMP1:  .BLKD           ;STATIC WORKING AREA
;TEMP2: .BLKB           ;FOR USERAID - ; migry ; removed as not used
        .BLKB   8       ;ROUTINES
ANUMBER:.BLKB   40


;       STATIC BASE AREA - ahelpio
;
;       THIS AREA CONTAINS DYNAMIC CODE BUILDING DATA

LASTSEG:        .BLKB   ;LAST SEGMENT BEORE CHANGE
SEGMENT:        .BLKB   ;CURRENT SEGMENT
SBCOUNT:        .BLKD   ;SB COUNTER
                .BLKD   ;THESE GLOBALS ARE INIT BY AHELPIO AND ARE NOT ZEROED
                        ;AT THE START OF MONASM ENTRY
SBSTRT:

BASECODE:       .BLKD   ;BASIC INSTRUCTION CODE
                .BLKW   ;BIT BUFFER
SUFFIX:                 ;SUFFIX FOR INDEX ADDR MODE 
SUFFIX1:        .BLKB   ; FOR OPERANDS 1-4
SUFFIX2:        .BLKB
SUFFIX3:        .BLKB
SUFFIX4:        .BLKB

SUFF_FLGS:              ;FLAG THAT SUFFIX IS PRESSENT
S_FLG1:         .BLKB
S_FLG2:         .BLKB
S_FLG3:         .BLKB
S_FLG4:         .BLKB

DISP1X:                 ;FIRST DISPLACEMENT FOR 
DISP1A:         .BLKD   ; OPERANDS 1-4
DISP1B:         .BLKD
DISP1C:         .BLKD
DISP1D:         .BLKD

DISP2X:                 ;SECOND DISPLACEMENT FOR
DISP2A:         .BLKD   ; OPERANDS 1-4
DISP2B:         .BLKD
DISP2C:         .BLKD
DISP2D:         .BLKD

LEN1:                   ;LENGTH OF DISPLACE MENTS FOR
LEN1A:          .BLKB   ; OPERANDS 1-4
LEN1B:          .BLKB
LEN1C:          .BLKB
LEN1D:          .BLKB

LEN2:                   ;LENGTH OF DISPLACEMENT 2
LEN2A:          .BLKB   ; FOR OPERANDS 1-4
LEN2B:          .BLKB
LEN2C:          .BLKB
LEN2D:          .BLKB

;       SYMBOL ID VARIABLE
SYM_TYPE:       .BLKB   ;SET BY SYM_SRCH
SBC:            .BLKD   ;STATIC BASE SYMBOL VALU TO DEDUG CONTROL
LABEL:          .BLKD   ;LABEL IF ANY FOR CURRENT LINE
;       VARIABLE USED TO CONSTRUCT THE INST CODE
CODELGTH:       .BLKB   ;BASIC CODELENGTH :INT 1..4
ITYPE:          .BLKB   ;DATUM LENGTH :INT 1..4
DISPLACE:       .BLKB   ; FLAG OF DATUM TYPE IMMD/DISP :BOOL

;       PARSING VARIABLES
NUMLETS:        .BLKB   ; LENGTH OF ASCCII NEUMONIC
ADDRMODE:       .BLKB   ; BASIC ADDR MODE
OPFIELD:        .BLKB   ; OFFSET TO START OF CURRENT ADDR MODE FIELD
OPCLGTH:        .BLKB   ; LENGTH OF BASIC INST
ICODE:          .BLKB   ; i CATEGORY
OPSTRT:         .BLKD   ; VECTOR TO CURRENT OPERAND INPUT
INS_4BIT:       .BLKB   ;FLAG TO INSERT 4BIT ADDR MODE FIELD
INS_8BIT:       .BLKB   ; "      "   "   8
CATGORY:        .BLKB   ;OPERAND CATEGORIES
OP_IS_DISP:     .BLKB   ;OPERAND IS A DISP
ADISP:          .BLKB   ; WHICH DISP IS A DISP
IMM_IS_BYT:     .BLKB   ; IMM VAL IS BYTE
A_LONG_F:       .BLKB   ;FLAG THAT DISP IS FOR LONG FIELD INST
VECIN:          .BLKD   ;START OF INPUT LINE
ENDLIN:         .BLKD   ;END OF INPUT LINE
PC_ADDR:        .BLKD   ;CURRENT ADDRESS
ERR_FLG:        .BLKB   ;ROUTINE ERROR FLAG FOR SYMBOLTABLE FUNCTIONS
YES_SYM:        .BLKB   ;FLAG THAT SYMBOL WAS FOUND
S_FOUND:        .BLKB   ;BOOLEAN TO INDICATE PRESENSE OF A SYMBOL
SYM_VAL:        .BLKD   ;THE SYMBOL VALUE
PC_REL:         .BLKB   ;FLAG TO CALCULATE PFOGRAM BASE ADDRESS
DISP_FLGS:              ;SYMBOL LENGHT DIRECTIVE FOR FORWARD REF VALUES
DISP_B:         .BLKB   ;BYTE LONG
DISP_W:         .BLKB   ;WORD LONG
DISP_D:         .BLKB   ;DOUBLE LONG
                .BLKB   ;FLAG BUFFER AREA
FORM:           .BLKD   ;LONG OR SHORT FLOATING POINT FLAG      
F_ERROR:        .BLKD   ;FLOATING POINT CONVERSION ERROR FLAG
CONREAL:        .BLKB   ;A SHORT REAL NUMBER CONVERSION INST FLAG
SHRTREAL:       .BLKB   ;A REAL TO REAL SHORT NUMBER INST FLAG
A_REAL_NUM:     .BLKD   ;A REAL NUMBER
                .BLKD   ;2 DOUBLES IF LONG
TXT_BUF:        .BLKB   80      ;ADJUSTED INPUT LINE
                .BLKD
SBEND:          .EQU    $
SBSIZE: .EQU    ($ - SBSTRT)

;       STATIC BASE AREA - ahelp

                .ALIGN 2
VECIN3:         .BLKD           ;was VECIN ; migry ;
VECEN:          .BLKD
MEMSIZ:         .BLKD           ;MEMORY SIZE
PAR_VAL:        .BLKD           ;LINE PARAMETER VALUE
MON_BASE:       .BLKB
BASE:           .BLKB
A_PARAM:        .BLKB           ;BOOLEAN FOR LINE PARAM
HISTF:          .BLKD           ;HISTORY FILE
DELIMIT:        .BLKB           ;PARAMETER DELIMITER CHAR
LEADZERO:       .BLKB
ERROR:          .BLKD           ;ERROR CODE
ASM_ERR:        .BLKD           ;ASSEMBLER ERROR
ERR_CNT:        .BLKD           ;ASSEMBLY ERROR COUNT
TEMP4:          .BLKD           ;GENERAL PURPOSE VARIABLE - was TEMP1 ; migry ;
TEMP2:          .BLKD           ;   ''      ''      ''
TEMP3:          .BLKD           ;   ''      ''      ''
COUNTER:        .BLKD
PROG_BASE:      .BLKD           ;PC START
ASM_LIN:        .BLKD
ASS_BLED:       .BLKB           ;FLAG FOR SUCCESFUL ASSEMBLY
PASS_NUM:       .BLKB           ;PASS NUMBER
LIN_ERR:        .BLKB           ;ASSEMBLED LINE ERROR FLAG
SYM_TAB:        .BLKD 
CODESTAR:       .BLKD
A_SP:           .BLKD           ;AUTO SELECTED SP
A_MOD:          .BLKD           ;EXPORTED TO MONITOR
IOBUF:          .BLKB   70     ; ASCII string data
IOBUF2:         .BLKB   60

                .ALIGN H'10     ;AUTO MODE MODULE TABLE
MODTAB:
A_SB:           .BLKD
                .BLKD
A_PC:           .BLKD
                .BLKD

; STATIC BASE AREA - edit
SAFETY: .BLKB               ;SANITY TIMER               

; STATIC BASE AREA - autil
NUMCH:    .BLKB 82
LEAD_0:   .BLKB
DEC_VAL:  .BLKD
STROBE:   .BLKB

FLOATS: .BLKB   208             ; 140(SB)-208(SB): SYSTEM working area

         .ALIGN 0x800
; STATIC BASE AREA - edit
LGTH:   .BLKD               ;LENGTH OF INPUT LINE
LINNUM: .BLKD               ;ACTION LINE NUMBER
NEXT_LN:.BLKD               ;AUTO SEQUENCE LINE NUMBER
LAST_L: .BLKD               ;LAST GOOD LINE NUMBER FOR ERROR RECOVERY
LAST_AD:.BLKD               ;ADDRESS OF LAST GOOD LINE  
L_ADDR: .BLKD               ;LINE ADDRESS
LINES:  .BLKD               ;NUMBER OF LINES IN BUFFER
TXTEND: .BLKD               ;END OF TEXT
TEXT:   .BLKB               ; EDIT TEXT STORAGE AREA ??? SO MUST BE AT THE END OF SB???

STATICSZ: .EQU $-OPMOD

        .ENDSEG

        .org 0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; start of aint.32k

;
;
;   R E S E T    R O U T I N E
;
;


RESET:
        br       RESETF:w              ; skip TRAP module descriptors

;@@@@@@@@@@@@@@
#ifdef THEFORCE
;@@@@@@@@@@@@@@
        .align   0x10
MD_MAIN:
        ; standard MODULE TABLE ENTRY, composed of...
        .double SB_MAIN    ; Static Base Pointer
        .double 0          ; Link Base Pointer
        .double RESET      ; Program Base Pointer
        .double 0          ; reserved
; module descriptors normally done by the linker
MD_NVIRT:
        .double SB_NVIRT
        .double 0
        .double NVIRT
        .double 0
MD_NMIRT:
        .double SB_NMIRT
        .double 0
        .double NMIRT
        .double 0
MD_ABTRT:
        .double SB_ABTRT
        .double 0
        .double ABTRT
        .double 0
MD_FPURT:
        .double SB_FPURT
        .double 0
        .double FPURT
        .double 0
MD_ILLRT:
        .double SB_ILLRT
        .double 0
        .double ILLRT
        .double 0
MD_SVCRT:
        .double SB_SVCRT
        .double 0
        .double SVCRT
        .double 0
MD_DVZRT:
        .double SB_DVZRT
        .double 0
        .double DVZRT
        .double 0
MD_FLGRT:
        .double SB_FLGRT
        .double 0
        .double FLGRT
        .double 0
MD_BPTRT:
        .double SB_BPTRT
        .double 0
        .double BPTRT
        .double 0
MD_TRCRT:
        .double SB_TRCRT
        .double 0
        .double TRCRT
        .double 0
MD_UNINS:
        .double SB_UNINS
        .double 0
        .double INSRT
        .double 0
MD_ICU0:
        .double SB_MAIN
        .double 0
        .double ICU0RT
        .double 0
MD_ICU1:
        .double SB_MAIN
        .double 0
        .double ICU1RT
        .double 0
MD_ICU2:
        .double SB_MAIN
        .double 0
        .double ICU2RT
        .double 0
MD_ICU3:
        .double SB_MAIN
        .double 0
        .double ICU3RT
        .double 0
MD_ICU4:
        .double SB_MAIN
        .double 0
        .double ICU4RT
        .double 0
MD_ICU5:
        .double SB_MAIN
        .double 0
        .double ICU5RT
        .double 0
MD_ICU6:
        .double SB_MAIN
        .double 0
        .double ICU6RT
        .double 0
MD_ICU7:
        .double SB_MAIN
        .double 0
        .double ICU7RT
        .double 0
MD_ICU8:
        .double SB_MAIN
        .double 0
        .double ICU8RT
        .double 0
MD_ICU9:
        .double SB_MAIN
        .double 0
        .double ICU9RT
        .double 0
MD_ICU10:
        .double SB_MAIN
        .double 0
        .double ICU10RT
        .double 0
MD_ICU11:
        .double SB_MAIN
        .double 0
        .double ICU11RT
        .double 0
MD_ICU12:
        .double SB_MAIN
        .double 0
        .double ICU12RT
        .double 0
MD_ICU13:
        .double SB_MAIN
        .double 0
        .double ICU13RT
        .double 0
MD_ICU14:
        .double SB_MAIN
        .double 0
        .double ICU14RT
        .double 0
MD_ICU15:
        .double SB_MAIN
        .double 0
        .double ICU15RT
        .double 0
#endif
;@@@@@@@@@@@@@@

;@@@@@@@@@@@@@@
#ifdef THEFORCE
;@@@@@@@@@@@@@@

RESETF:
        movqd   0,@SWITCHP              ; no MMU and no FPU
        LPRD    SP,SUPSTACK             ; Supervisor stack pointer 
        ADDR    MD_MAIN,R1              ; 
#ifdef DEBUGTHEFORCE
        MOVD    R1,@DEBUGD              ; migry - debug (check stack pointer)
#endif
        LPRW    MOD,R1                  ; INIT MOD REG 
        LPRD    SB,0(R1)                ; work,  INIT SB REG

        ; fill memory with 0x0
        MOVD    ((RAMTOP-RAMBOT)/4)-2,R0 ; LENGTH OF RAM IN DOUBLE WORDS
        MOVD    0x0,R1
        MOVD    RAMBOT+4,R2
FILLX:  MOVD    R1,0(R2)[R0:D]          ; FILL (doesn't do R0==0 case)
        ACBD    -1,R0,FILLX
        ;
        MOVD    INTTAB,R1
        LPRD    INTBASE,R1              ; INTBASE:=ADDRESS OF INTTAB 
#ifdef DEBUGTHEFORCE
        MOVD    R1,@DEBUGD              ; migry - debug (check stack pointer)
#endif
        MOVD    R1,SVINTB               ; INIT USER INTBASE

        ;ADDR    256(R1),SVIS            ; SVIS:=SP+20 INIT USE IS ***** TODO *****
        MOVD    ISTACK,SVIS             ; 

        MOVQB   TRMA,NDTRM              ; NDTRM:=TRMA (* SET TERM A AS DEFAULT
        MOVQD   0,OPMOD                 ; OPERATION MOD := STAND ASIDE
        MOVB    HUTERM,OPMOD            ; SET TERM TO NO ECHO/CRLF      
        MOVQB   FALSE,NOTECHO           ; MON_USR := MONITOR  
        MOVQD   INITMOD,DEFSET          ; SET STAND ALONE MODE,PROCESS OFF
        MOVB    ALONE,ALONFLG
        MOVQB   0,ACKFLG                ; migry
        ;
        MOVQD   0,SVPC                  ; USER_PC := 0
        MOVQD   0,SVPSR                 ; USER_PSR := 0
        ;
        MOVZBD  NSFBR+1,R1              ; INIT SOFTWARE BPR ARRAY
RST1:   MOVQD   0,BRKAR-4[R1:D]         ; FOR I:=1,NSFBR DO BRKAR:=0
        ACBB    -1,R1,RST1
        ;
        ADDR    BEGINA:W,STRTADR        ; SAVE START ADDRESS
        ADDR    ENDINT:W,ENDADR         ; SAVE END INTERRUPT ROUTINE ADDRESS
        ;
        BSR     INITICU
        ;
        BSR     INITUART                ; migry ; MUST CALL HARDWARE DEPENDANT ROUTINE
        ;
        bsr     LED1ON
        ;
        SETCFG  []
        MOVQB   0,CONFIG                ; SET CONFIGURATION
        MOVQB   0,IRQCNT
        ;
        BSR     MAINLP                  ; TYPE RESET MESSAGE
        ;
INFLOOP:
        bsr     LED1ON
        bsr     LED2ON
        movd    100000,R0
LEDLOOP1: ACBD    -1,R0,LEDLOOP1
        bsr     LED1OFF
        bsr     LED2OFF
        movd    100000,R0
LEDLOOP2: ACBD    -1,R0,LEDLOOP2
        BR      INFLOOP

#endif
;@@@@@@@@@@@@@@

;+++++++++++++
#ifdef DB16000
;+++++++++++++
RESETF:

        ;;;;;;;;;;;;;;;;;;
        ; ORIGINAL RESET ;
        ;;;;;;;;;;;;;;;;;;
        BICPSRW PSRS                    ; {STOP EXECUTION IF PSR_U ON}
        ADDR    MODTB,R1                ; 
        LPRW    MOD,R1                  ; INIT MOD REG so check of first will
        LPRD    SB,0(R1)                ; work,  INIT SB REG
        CMPW    12345,FIRST             ; IF THIS IS POWER UP RESET THEN
        BNE     dct16:d                 ; migry add :D ; Do the diagnostics 

RESET2: 
        ADDR    MODTB,R1                ; return point from diagnostics
        LPRW    MOD,R1                  ; INIT MOD REG
        LPRD    SB,0(R1)                ; INIT SB REG
        ADDR    INTTAB,R1
        LPRD    INTBASE,R1              ; INTBASE:=ADDRESS OF INTTAB
        MOVD    R1,SVINTB               ; INIT USER INTBASE
        ADDR    STACKL(SB),R1           ; SP:=ADDRESS OF STACK AREA
        LPRD    SP,R1                   ;   ( SP:=SB+STACKL)
        ADDR    256(R1),SVIS            ; SVIS:=SP+20 INIT USE IS
        MOVQB   TRMA,NDTRM              ; NDTRM:=TRMA (* SET TERM A AS DEFAULT
        MOVQD   0,OPMOD                 ; OPERATION MOD := STAND ASIDE
        MOVB    HUTERM,OPMOD            ; SET TERM TO NO ECHO/CRLF      
        MOVQB   FALSE,NOTECHO           ; MON_USR := MONITOR  
        MOVQD   INITMOD,DEFSET          ; SET STAND ALONE MODE,PROCESS OFF
        MOVB    ALONE,ALONFLG
        MOVQD   0,SVPC                  ; USER_PC := 0
        MOVQD   0,SVPSR                 ; USER_PSR := 0
        MOVZBD  NSFBR+1,R1              ; INIT SOFTWARE BPR ARRAY
RST1:   MOVQD   0,BRKAR-4[R1:D]         ; FOR I:=1,NSFBR DO BRKAR:=0
        ACBB    -1,R1,RST1
        ADDR    BEGINA:W,STRTADR        ; SAVE START ADDRESS
        ADDR    ENDINT:W,ENDADR         ; SAVE END INTERRUPT ROUTINE ADDRESS
;
        BSR     INITICU
;
        BSR     INITTIMER
;
        BSR     INITUART                ; migry ; MUST CALL HARDWARE DEPENDANT ROUTINE

        SETCFG  []
        MOVQB   0,CONFIG                ; SET CONFIGURATION
        BSR     MAINLP                  ; TYPE RESET MESSAGE
        ;
        BSR     INITAUXU

        ;??? FALLS THRU TO NOTHING???? 
        BR      $
#endif 
;+++++++++++++
;
BEGINA:
;
ERROR1: MOVD    SCRCH1,R1               ; RELOAD R1
ERROR2: BSR     MNENTR:B                ; SAVE USER STATUS LOAD MONITOR STATUS
ERROR3: BSR     BRKRMV:W                ; BRKRMV {BREAK REMOVE ROUTINE}
        MOVXBD  ERRTYP,R1               ; LOAD ERROR PARAMETER
        MOVD    SVR0-4,R0               ; LOAD NUMBER TO BE PRINTED WITH ERROR
ERROR4: 
        BSR     ERENT                   ; JUMP TO ERROR IM COMMAND LOOP
;
;
;   M N E N T R     (* ENTER COMMAND LINE INPUT MODE*)
;
;
MNENTRA: MOVD   SCRCH1,R1               ; RELOAD R1 FROM EXIT
MNENTR: MOVD    0(SP),SCRCH2            ; SAVE RETURN ADDRESS OF THIS ROUTINE
        CMPQB   MONT,MON_USR            ; IF MON_USER<> MONT THEN 
                                        ;       { MONITOR TIME  }
        BEQ     MNENTR3:W               ; BEGIN
        MOVZWD  8(SP),SVMOD             ;   SAVE MOD  OF USER PROGRAM
        MOVW    10(SP),SVPSR            ;   SAVE PSR
        MOVD    4(SP),SVPC              ;   SAVE PC
        ADDR    12(SP),SVIS             ;   SAVE IS
        BISPSRW PSRS                    ;   PSR-S :=1
        ADDR    0(SP),SVUS              ;   SAVE US
        SPRD    FP,SVFP                 ;   SAVE FP
        SPRD    INTBASE,SVINTB          ;   SABE INTB
        ADDR    SVR0+4,SCRCH1
        LPRD    SP,SCRCH1               ;   SP:= ADDRESS OF SVR0
        SAVE    [R0,R1,R2,R3,R4,R5,R6,R7]       ; SAVE R0-R7
                                        ; END;
        LPRW    PSR,MNPSR               ; LOAD MONITOR PSR
        LPRD    SP,MNSP                 ; LOAD MONITOR SP
        RESTORE [R0,R1,R2,R3,R4,R5,R6,R7] ; LOAD MONITOR R0-R7
        LPRD    FP,MNFP                 ; LOAD MONITOR FP
        LPRD    INTBASE,MNINTB          ; LOAD MONITOR INTB
        MOVD    SCRCH2,0(SP)            ; PUT RETURN ADDRESS ON STACK
        MOVQB   MONT,MON_USR            ; MON_USER:= MONITOR TIME
        TBITB   CNFMMU,CONFIG           ; IF CNG.MMU ON  THEN
        BFC     MNENTR3:B               ;   BEGIN
        CMPQD   0,SVMSR                 ;     IF MSR WAS NOT SAVED THEN
        BNE     MNENTR2:B               ;       BEGIN
        SMR     MSR,SVMSR               ;         SAVE MSR;
MNENTR2:LMR     MSR,MNMSR               ;         MSR := MONITOR MSR;
MNENTR3:                                ;       END;
        ADDR    TERM1,R7                ; DTRM:=TERM1
        ADDR    OUTB(R7),R6             ; INIT DTRM.OUTB
        RET     0
;
;
;   M N E X I T     (* EXIT COMMAND LINE MODE *)
;
;
MNEXIT: MOVB    NOERR, ERRTYP           ;NO ERROR FLAG
;       MOVQB   FALSE,PNDF              ; RESET PENDING INTERRUPT FLAG
        SPRD    FP,MNFP                 ; SAVE MONITOR FP
        SPRD    INTBASE,MNINTB          ; SAVE MONITOR INTB
        SPRW    PSR,MNPSR               ; SAVE MONITOR PSR
        SAVE    [R0,R1,R2,R3,R4,R5,R6,R7] ; SAVE MONITOR R0-R7
        SPRD    SP,MNSP                 ; SAVE MONITOR SP
        MOVQB   USERT,MON_USR           ; MON_USR:= USER TIME
        BISPSRW PSRS                    ; SET S BIT IN PSR {LOAD US}
        LPRD    SP,SVUS                 ; LOAD USER  US
        LPRD    FP,SVFP                 ; LOAD FP
        LPRD    INTBASE,SVINTB          ; LOAD INTB
        BICPSRW PSRS                    ; PSR-S:=0
        ADDR    SVR7,SCRCH1
        LPRD    SP,SCRCH1               ; SP:= ADDRESS SVR7             
        RESTORE [R0,R1,R2,R3,R4,R5,R6,R7] ; LOAD R0-R7
        LPRD    SP,SVIS                 ; LOAD IS
        CBITB   PSR_P,SVPSR             ; CLEAR P BIT IN PSR
        MOVW    SVPSR,TOS               ; PREPARE RETURN PUSH PSR
        MOVW    SVMOD,TOS               ; PUSH MOD
        MOVD    SVPC,TOS                ; PUSH PC
        TBITB   CNFMMU,CONFIG           ; IF CONFIG.MMU THEN
        BFC     MNEXT1:B                ;   BEGIN
        SMR     MSR,MNMSR               ;     MNMSR := MONITOR MSR;
        LMR     MSR,SVMSR               ;     MSR := SVMSR {LOAD MSR}
        MOVQD   0,SVMSR                 ;     SVMSR := 0 {FLAG FOR SAVING NSR}
MNEXT1: RETT    0                       ;   END;
;
;
;
;
;                  B R E A K    R E M O V E
;
;     REMOVES  BPT INSTRUCTION OF EACH ACTIVE BREAK POINTS 
;
;
;
BRKRMV: MOVQD   0,R3            ; BRKN:=0
        MOVD    SVPC,R1         ; R1:=USE_PC
        MOVZBD  NSFBR,R0        ; FOR I:= NSFBR DOWNTO 1 DO
RMV1:   MOVD    BRKAR-4[R0:D],R2 ;BEGIN
        TBITB   BPR_BE,R2       ;    R2:=BRKAR[I];
        BFC     RMV2:B          ;    IF BRKAR[I].BE THEN
        ANDD    H'FFFFFF,R2     ;   BEGIN
        CMPB    BPTC,INS-1[R0:B]; IF BP THEN SKIP SAVE
        BEQ     RMV1A:B 
        MOVB    INS-1[R0:B],0(R2);    M(BRKAK[I].ADDR):=INS[I]
                ; **** MOVSU ****;    (* RELOAD INSTRUCTION TO MEMORY *)
RMV1A:  CMPD    R1,R2           ;     IF BRKAR[I].ADDR=USER_PC THEN
        BNE     RMV2:B          ;     BEGIN
        MOVD    R0,R3           ;       BRKN:=I
RMV2:   ACBB    -1,R0,RMV1      ; END FOR
        CMPB    NOERR, ERRTYP
        BNE     RMVEX:W
        CMPQB   0,R3            ; IF BPRN>1 THEN (* SOFTWARE BP *)
        BEQ     RMV4:B          ; BEGIN
        MOVD    MESG:W,0(R6)    ;    OUTB(DTRM.OUTLM):=CR LF B
        MOVB    HEXAN+1[R3:B],3(R6) ;  OUTB(DTRM.OUTLM):= ASCII (BRKN)
        ADDQD   4,R6            ;    DTRM.OUTLM:=DTRM.OUTLM+7
;ORIGINAL DISPLAY SOURCE LINE SET 
        MOVQB   PRNTAC,PROCESS  ;  CPU REGISTER SET
        MOVQB   0,ALONFLG
RMV2A:  BSR     MSGENT          ; END (GOTO MESSAGE PRINT)
RMV4:   ADDR    CXPRL,R2        ; IF USE_PC = RETURN FROM CXP THEN
        CMPD    R1,R2
        BNE     RMVEX:B         ; BEGIN
        MOVQB   FALSE, PROCESS  ;NO DEBUG WHEN DONE
RMV6:   MOVMD   OLDPC,SVPC,3    ;    SVPC:=OLDPC SVUS:=OLDUS SVIS:=OLDIS SVMOD
                        ; XXX 12
        MOVD    H'54455220,2(R6);    OUTB(DTRM.OUTLM):= " RET"
        ACBB    -1,CXPFLG,RMV5:B ;   CXPFLG:=CXPFLG-1; 
        MOVD    H'444E4520,2(R6);    IF CXPFLG=0 "B END" {END OF PROGRAM}
RMV5:   MOVW    MESG:W,0(R6)    ;    OUTB(DTRM.OUTLM):=CR LF B
        ADDQD   6,R6            ;    DTRM.OUTLM:=DTRM.OUTLM+7
        BSR     MSGENT          ; END  (GO TO PRINT MESSAGE )
RMVEX:  RET     0
;
;
;   B P T     ROUTINE
;
;
MESG:   .BYTE   CR,"B"," "      ; BREAK POINT MESSAGE
;
BPTRT: 
#ifdef THEFORCE
        MOVB    ~0x09,@ICU_PDAT              ; initial pattern
#endif
        BSR     MNENTR          ; MNENTR {SAVE USER STATUS & LOAD MONITOR }
        BSR     BRKRMV          ; BRKRMV {REMOVE BPT'S AND FIND ACTUAL BREAK}
BPTER:  MOVQD   EBPT,ERRTYP     ; ELSE
        BR      ERROR2          ;    ERROR(EBPT)
;
;
;   T R A C E    T R A P    R O U T I N E
;
;
TRCRT:
#ifdef THEFORCE
        MOVB    ~0xaa,@ICU_PDAT ; initial pattern (0 switches on LED so need to invert value)
        SPRW    PSR,SXPSR       ; SAVE PSR
#endif
        MOVD    R1,SCRCH1       ; SAVE R1
TRCT1:  MOVZBD  STEPFLG,R1      ; R1:=STEP_FLAG
TRCCS:  CASEB   TRCCT:B[R1:B]   ; CASE OF STEP_FLAG
TRCCT:  .BYTE   TRCER-TRCCS     ;  NO MONITOR TRACE
        .BYTE   TRCSTPN-TRCCS   ;  STEP  N
        .BYTE   TRCSTU-TRCCS    ;  STU
        .BYTE   TRCSTU-TRCCS    ;  STW
        .BYTE   TRCGO-TRCCS     ;  TRACE AFTER GO
        .BYTE   TRCGO2-TRCCS    ;  TRACE AFTER STN
        .BYTE   TRCGO2-TRCCS    ;  TRACE AFTER STU
        .BYTE   TRCGO2-TRCCS    ;  TRACE AFTER STW
#ifdef THEFORCE
        .BYTE   TRCRETI-TRCCS
#endif
TRCER:  MOVQB   ETRC,ERRTYP     ; 0 : ERROR_TYPE:=ETRC
        BR      ERROR1
TRCGO:                          ; 1 : TRACE OF GO
        CBITB   PSR_T,6(SP)     ;       PSR_T:=0
TRCGO2: MOVB    BPTC,0(ACTBRK)  ;       M(PC):=BPTC (* BPT INSTRCTION
        ;      *** MOVSU ***
        ADDQB   (-STBRK),STEPFLG ;      STEP_FLAG:=NO MONITOR TRACE
        CMPQB   NOTRC,STEPFLG   ;       IF GO & STEP TRACE GOTO TRCT1
        BNE     TRCT1           ;       ELSE
TRC2:   MOVD    SCRCH1,R1       ;          RELOAD R1
        RETT    0               ;          RETURN TO USER
TRCSTPN:                        ; 2 : TRACE STEP N
        ACBD    -1,STPCNT,TRC2  ;       STEP_COUNT:=STEP_COUNT-1
                                ;       IF STEP_COUNT>0
                                ;       THEN RETURN TO USER
        BSR     MNENTRA         ;       ELSE MNENTR
TRC3:   MOVD    H'43525420,2(R6)    ;            OUTB:=" TRC"
;ORIGINAL DISPLAY SOURCE LINE SET 
        MOVQB   PRNTAC,PROCESS  ; PRINT ALL CPU REGS
        MOVQB   0, ALONFLG
TRC33:  BSR     BRKRMV          ;            REMOVE B.P. {EXIT TO COMMAND LOOP}
        BR      RMV5            ;            EXIT TO WRITE MESSAGE
TRCSTU: BSR     MNENTRA         ; 3 : STU/STU
        MOVQB   GETI,TOS        ;       MNENTR (* SAVE USER STATUS
        MOVZBD  STUADD+3,R2     ;       GETPUT (GET,STUADD.TYPE,STUADD.NO)
        MOVD    STUADD,TOS
        MOVQB   0,3(SP)
        BSR     GETPUT          ;       (* FIND VARIABLE USING GET-PUT ROUTINE
        ANDD    STUADD+4,R1     ;       VAR:=VAR AND MASK
        CHECKD  R0,STUADD+8,R1  ;       F=VAR>=LIMIT.LOWER AND VAR<=LIMIT.UPPER
        CMPQB   STU,STEPFLG
        BFS     TRC6:B          ;       IF NOT F THEN
        BEQ     TRC3            ;         IF STEPFLG=STU GOTO TRC3
TRC5:  
TRC55:  BSR     MNEXIT          ;         ELSE RETURN TO USER
TRC6:   BNE     TRC3            ;       ELSE IF STEPFLG<>STU GOTO TRC3
        BR      TRC5            ;               ELSE RETURN TO USER
#ifdef THEFORCE
TRCRETI:
        MOVB    ~0xa5,@ICU_PDAT 
        NOP
        NOP
        NOP
        NOP
        RETI
#endif
;
;
;  N M I     R O U T I N E
;
;
;
NMIRT:  
#ifdef THEFORCE
        MOVB    ~0x02,@ICU_PDAT              ; initial pattern
#endif
        MOVQB   FALSE,NOTECHO   ;CANCEL NO ECHO
        MOVB    ENMI,ERRTYP     ; 
        CMPQB   MONT,MON_USR    ; IF MTIME TIME ERROR(NMI)
                                ;BNE     ERROR
        BEQ     ERROR2
        MOVQB   1,ACKFLG        ; ELSE RESET NMI
        BSR     MNENTR          ; {ACKFLG:=1} RETURN USER STATUS
        BSR     BRKRMV          ; BRKRMV {BREAK REMOVE ROUTINE}
        BSR     MAINLP          ;
;
;  A B O R T   R O U T I N E
;
;
ABTRT: 
#ifdef THEFORCE
        MOVB    ~0x03,@ICU_PDAT              ; initial pattern
#endif
        MOVQB    EXTR, ERRTYP
        TBITB   CNFMMU, CONFIG  ;IF NO MMU THEN UNKNOWN ABORT CONDITION
        BFC     ERROR2  
        SMR     MSR, SVMSR      ;SAVE MSR
        MOVQB   EABT, ERRTYP
        TBITD   0, SVMSR        ;IF NOT ADDR TRANSLATION ERROR
        BFS     ERROR2          
        MOVQB   EBPR, ERRTYP    ;THEN IF NOT MMU BREAKPOINT
        TBITD   2, SVMSR
        BFS     ERROR2          ;THEN NON SEQ MMU TRACE TRAP
        MOVQB   ENST, ERRTYP
        BR      ERROR2                  

;
;
; E R R O R S    &   T R A P S
;
;

INSRT:
#ifdef THEFORCE
        MOVB    ~0x0f,@ICU_PDAT              
#endif
        BR      ERROR2

NVIRT:  MOVQB   ENVI,ERRTYP
#ifdef THEFORCE
        SAVE [R0]
        ; display interrupt on LED bar
        COMB    IRQCNT,R0
        MOVB    R0,@ICU_PDAT              
        NOP
        ADDQB   1,IRQCNT
        NOP
        NOP
        RESTORE [R0]
        NOP
        RETI
#endif
        BR      ERROR2

FPURT:  MOVQB   EFPU,ERRTYP
#ifdef THEFORCE
        MOVB    ~0x04,@ICU_PDAT              
#endif
        BR      ERROR2

ILLRT:  MOVQB   EILL,ERRTYP
#ifdef THEFORCE
        MOVB    ~0x05,@ICU_PDAT              
#endif
        BR      ERROR2

DVZRT:  MOVQB   EDVZ,ERRTYP
#ifdef THEFORCE
        MOVB    ~0x07,@ICU_PDAT              
#endif
        BR      ERROR2

FLGRT:  MOVQB   EFLG,ERRTYP
#ifdef THEFORCE
        MOVB    ~0x08,@ICU_PDAT              
#endif
        BR      ERROR2

UNDRT:  MOVQB   EUND,ERRTYP
#ifdef THEFORCE
        MOVB    ~0x02,@ICU_PDAT              
#endif
        BR      ERROR2
;
; SVC   R O U T I N E S
;
;

RNG:    .BYTE 3, 0      ;USERAID RANGE CHECK
SVCLM:  .BYTE   7,3     ;SVC LIMITS

SVCRT:  
#ifdef THEFORCE
        MOVB    ~0x06,@ICU_PDAT              
#endif
        MOVB    MON_USR, LADDR          ;SAVE TIME FLAG
        MOVQB   MONT,MON_USR            ; FLAG PENNDING MODE:= TRUE
        SAVE    [R0,R3]
        ANDD    H'FF,R0                 ; LIMIT R0
        CHECKB  R0,SVCLM,R0
        BFC     SVCS:B                  ; IF SVC#> SVCLM ERROR
SVCER:  MOVB    ESVC,ERRTYP
        BR      ERROR3
SVCS:   CASEW   SVCTB:B[R0:W]           ; BRANCH TO SVC[R0]
SVCTB:  .WORD   SVC3-SVCS
        .WORD   SVC4-SVCS
        .WORD   SVC5-SVCS
        .WORD   SVC6-SVCS
        .WORD   SVC7-SVCS
;
ENDINT:
;
;  S V C 3    R E A D N 
;
;
SVC3:   MOVW    R2,TOS
        MOVB    R3,TOS                  ; RDLIN(R2,R3,R1);
        MOVD    R1,TOS
        BSR     RDLIN
        MOVZWD  TOS,R2                  ; R2:= # OF READ CHAR
SVCEX:  RESTORE [R0,R3]
        MOVB    LADDR, MON_USR          ;RESTORE FLAG
        ADDQD   1,0(SP)                 ; {SKIP SVC INSTRUCTION. }
;       CMPQB   TRUE,PNDF               ; IF PENNDING INTERRUPT EXISTS
;       BR      SVCEX1:B                ;       BNE     SVCEX1:B THEN
;SVCEX2:        MOVB    EPND,ERRTYP             ; ERROR(PND)
;       BR      ERROR2                  ; ELSE
SVCEX1:                                 ;IF SVC REQUEST CAME FROM OUTSIDE
                                        ;THEN IT WAS A MONT TIME CASE
        MOVQB   FALSE,NOTECHO           ; FLAGE USER TIME
        RETT    0
;
;
;  S V C 4   P R I N T N
;
;
SVC4:   MOVD    R1,TOS                  ; PRINTA (R1,R1+R2,R3)
        ADDD    R1,R2
        MOVD    R2,TOS
        MOVB    R3,TOS
        MOVB    0x91,TOS                ; migry - for alignment
        BSR     PRINTA
        BR      SVCEX
;
;
;  S V C 5   G E T _ N U M
;
;
SVC5:   
                ;GET_NUM
                MOVZBD  R4, R4          ;GET CONVERSION CHOICE
                CHECKB  R4, RNG, R4     ;CHECK FOR LEGALITY
                BFS     SVCER
                ABSD    R2, R2
        HERE:   CASEW   NUMS:B[R4:W]
        NUMS:   .WORD   A_S - HERE
                .WORD   A_L - HERE
                .WORD   A_D - HERE
                .WORD   A_H - HERE

        A_S:    MOVQD   SHRT, TEMP1     ;SET RADIX TO SHORT FLOAT
                BR      FLOATIT:B
        A_L:    MOVQD   LNG, TEMP1      ;SET RADIX TO LONG FLOAT
FLOATIT:        MOVD    R3, TOS         ;ADDR OF RESULT
                MOVD    R1, TOS         ;PASS START OF ASC LINE
                MOVD    R2, TOS         ;PASS LENGTH
                ADDR    TEMP1, TOS      ;PASS LONG OR SHORT
                ADDR    ERROR, TOS      ;ERROR RET
                BSR     ASC_2_RE
                BR      EXx:B
        
        A_D:    MOVB    DEC, BASE       ;INTEGER CONVERSIONS
                BR      NUMIT:B         ;DECIMAL
        A_H:    MOVB    HEX, BASE       ;HEX
NUMIT:          MOVD    R1, TOS         ;START OF ASC LINE
                ADDD    R1, R2          ;GET LENGTH
                ADDQD   -2, R2          ;SKIP TO LAST CHAR(NOT CR)
                MOVD    R2, TOS         ;END OF ASC LINE
                BSR     A_NUM           ;CONVERT
                MOVD    TOS, 0(R3)      ;STORE RESULT
        EXx:    MOVQD   0, R4           ;NO ERROR
                CMPQD   FALSE, ERROR    ;CHECK FOR ERROR        
                BEQ     EX_IT:B         ;RETURN BOOLEAN IN R4
                MOVQD   TRUE, R4
                BR      ERR_EX:B
EX_IT:          
ERR_EX:         MOVQD   FALSE, ERROR    ;CLEAR GENERAL ERROR FLAG
                BR      SVCEX           ;RETT

;
;
;   S V C 6    P U T _ N U M
;
;
SVC6:
                ;PUT_NUM
                MOVZBD  R2, R2          ;GET RADIX AND CHECK FOR VALID RANGE
                CHECKB  R2, RNG, R2
                BFS     SVCER
        PHERE:  CASEW   ASCN:B[R2:W]
        ASCN:   .WORD   S_A - PHERE
                .WORD   L_A - PHERE
                .WORD   D_A - PHERE
                .WORD   H_A - PHERE

        S_A:    MOVQD   SHRT, TEMP1
                BR      UNFLOATIT:B
        L_A:    MOVQD   LNG, TEMP1
UNFLOATIT:      ADDR    ANUMBER, TOS
                ADDR    TEMP1, TOS
                MOVD    R1, TOS
                BSR     REAL_2_A
                ADDR    ANUMBER, R1 
                BR      EXP:B
        
        D_A:    MOVB    DEC, BASE
                BR      UNNUMIT:B
        H_A:    MOVB    HEX, BASE
                MOVQB   FALSE, LEADZERO
UNNUMIT:        MOVD    0(R1), TOS
                BSR     N_TO_ASC
                MOVD    TOS, R1         ;CLEAN STACK
                ADDR    NUMCH, R1
        EXP:    
                MOVD    R3, R2
                MOVMB   0(R1), 0(R2), 16
                MOVMB   16(R1), 16(R2), 16
                MOVMB   32(R1), 32(R2), 3
                BR      SVCEX
;
;
;   S V C 7   P R I N T E R   O U T P U T
;
;
SVC7:   
        ;PINTER OUTPUT
        MOVD    R1, TOS         ;START OF STRING
        MOVD    R2, TOS         ;LENGTH
        BSR     PRINTC
        BR      SVCEX

;
;
;


;+++++++++++++
#ifdef DB16000
;+++++++++++++
        .subtitle       "Messages and code constants"
;
;
;               A non-destructive place for pc & psr when exceptions
;               occur.  Not necessary to reserve PROM space but its
;               helpful for RAM debug of DCT16
;
        .double 0,0

stack_top:
sign_on:
        .byte   CR,LF
        .byte   'DCT16 - DB16000A Diagnostics - ver. 1.01 - 01/03/84',0 
pass_msg:
        .byte   CR,LF,'DCT16 complete - ALL TESTS PASSED',CR,LF,0
fail_msg:
        .byte   CR,LF,'*** DCT16 FAIL ***',bell,CR,LF,0
;
;       fail flags and messages
;
flag_base:      .equ    16      ;use upper word so lower holds fail code
usart_rdy:      .equ    flag_base + 13
any_fail:       .equ    flag_base + 14
msg_present:    .equ    flag_base + 15

cpu_fail:       .equ    flag_base + 0
 cpu_msg:       .byte   ' CPU failure',0
prom_fail:      .equ    flag_base + 1
 prom_msg:      .byte   ' PROM Checksum failed     ',0
j2_pr_fail:     .equ    flag_base + 2
 j2_pr_msg:     .byte   ' J2 Transmitter failed    ',0

f_msg_size:     .equ    j2_pr_msg - prom_msg

j2_rd_fail:     .equ    flag_base + 3
 j2_rd_msg:     .byte   ' J2 Receiver failed       ',0
j2_ll_fail:     .equ    flag_base + 4
 j2_ll_msg:     .byte   ' J2 Local loop back failed',0
j3_pr_fail:     .equ    flag_base + 5
 j3_pr_msg:     .byte   ' J3 Transmitter failed    ',0
j3_rd_fail:     .equ    flag_base + 6
 j3_rd_msg:     .byte   ' J3 Receiver failed       ',0
j3_ll_fail:     .equ    flag_base + 7
 j3_ll_msg:     .byte   ' J3 Local loop back failed',0
om_fail:        .equ    flag_base + 8
 om_msg:        .byte   ' Output message failed    ',0
;
;       NOTE: messages above must all be of same length
;
 rdt_msg:       .byte   ' RAM data test failure:           ',0
 rat_msg:       .byte   ' RAM address test failure:',0
 rrt_msg:       .byte   ' RAM Refresh test failure',0
 mmur_msg:      .byte   ' MMU register failure: ',0
 mmu_msg:       .byte   ' MMU trace test failure',0
 fpu_msg:       .byte   ' FPU test failed',0
pit_fail:       .equ    flag_base + 9
 pit_msg:       .byte   ' PIT test failure: ',0
ppi_fail:       .equ    flag_base + 10
 ppi_msg:       .byte   ' PPI test failure: ',0
icu_fail:       .equ    flag_base + 11
 icu_msg:       .byte   ' ICU timer failure: ',0
 icu_imsg:      .byte   ' ICU interrupt failure',0
        .subtitle       "Exception processing"
;
;       Exception processing
;
;               Link table builds dispatch table
;
exc_tab:        .byte   'NVI',0,'NMI',0,'ABT',0,'FPU',0
                .byte   'ILL',0,'SVC',0,'DVZ',0,'FLG',0
                .byte   'BPT',0,'TRC',0,'UND',0  
exc_msg:        .byte   ' exception occured, ***DCT16 ABORTED***'
sp_msg:         .byte   ' ',0
;
;       No exceptions other than nvi should normally occur
;
nvisvc: br      icu_int:w
nvierr: movzbd  0,r0
        br      excp_abt:b
nmisvc: movzbd  1,r0
        br      excp_abt:b
abtsvc: movzbd  2,r0
        br      excp_abt:b
fpusvc: movzbd  3,r0
        br      excp_abt:b
illsvc: movzbd  4,r0
        br      excp_abt:b
svcsvc: movzbd  5,r0
        br      excp_abt:b
dvzsvc: movzbd  6,r0
        br      excp_abt:b
flgsvc: movzbd  7,r0
        br      excp_abt:b
bptsvc: movzbd  8,r0
        br      excp_abt:b
trcsvc: movzbd  9,r0
        br      excp_abt:b
undsvc: movzbd  10,r0
;
excp_abt:
        sbitb   any_fail,r7
        movqb   on,@diag_fail

        addr    sp_msg,r1
        addr    exc_1:b,r6
        br      fcemsg
exc_1:
        addr    exc_tab[r0:d],r1
        addr    exc_2:b,r6
        br      outmsg:w
exc_2:
        addr    exc_msg,r1
        addr    diag_end:w,r6
        br      outmsg

;       .subtitle       "FCEMSG: Fail code + message routine"
;
;       Fail code + error message subroutine
;
;       input:  r6 = return address
;               r7 = fail code (low order word)
;               r1 = address of message, message terminated with zero byte
;
;       output: r2, r3 & r4 destroyed
;               all other (general) registers unchanged
;
ascii_tab:      .byte   '0123456789ABCDEF'
CRLFb:          .byte   CR,LF,bell,0

fcemsg: 
        lprd    sb,r1                   ; save message address
        lprd    fp,r6                   ; save return address

        addr    CRLFb,r1                ; Begin with CR, LF & BELL
        addr    fce_rtn:b,r6
        br      outmsg:w
fce_rtn:
                                        ; now output fail code
        movd    j2base,r3               ; r3 address of terminal 
fce_loop:
        movqb   4,r4                    ; four digit code
fce_nxt:
        movzbd  @SWITCHP,r2
        andb    x'0f,r2
        movzwd  wctb:d[r2:w],r2         ; migry; wait count
        rotw    4,r7                    ; next digit to low order position
        movzbd  r7,r1
        andb    x'0f,r1                 ; isolate lsd
fce_pr_wait:
        tbitb   tx_rdy,statp(r3)        ; if TX-RDY != 0
        bfs     fce_print_it:b
        acbd    -1,r2,fce_pr_wait
fce_print_it:
        movb    ascii_tab[r1:b],DATAP(r3)

        acbb    -1,r4,fce_nxt

        cmpd    j3base,r3               ; have we done both usarts?
        movd    j3base,r3
        bne     fce_loop                        ; if not, do j3

        sprd    sb,r1
        sprd    fp,r6
        br      outmsg:b

;       .subtitle       "ERRMSG Error message with spaces for fail code"
;
;       error message subroutine (without fail code)
;
;       input:  r6 = return address
;               r1 = address of message, message terminated with zero byte
;
;       output: r2, r3 & r4 destroyed
;               all other (general) registers unchanged
;
CRLFbspace:     .byte   CR,LF,bell,'    ',0

errmsg: 
        lprd    sb,r1                   ; save message address
        lprd    fp,r6                   ; save return address

        addr    CRLFbspace,r1           ; Begin with CR, LF & BELL
        addr    err_rtn:b,r6
        br      outmsg:b
err_rtn:

        sprd    sb,r1                   ; restore original parameters
        sprd    fp,r6                   ; and output message
        br      outmsg:b

;       .subtitle       "OUTMSG  Ouput message to console(s) routine"
;
;       output message subroutine (with out using RAM)
;
;       input:  r6 = return address
;               r1 = address of message, message terminated with zero byte
;
;       output: r2, r3 & r4 destroyed
;               all other (general) registers unchanged

outmsg: 
        sbitb   msg_present,r7
s_outmsg:
        movd    j2base,r3               ; r3 address of terminal 
om_loop:
        movd    r1,r4
om_nxt:
        movzbd  @SWITCHP,r2
        andb    x'0f,r2
        movzwd  wctb:d[r2:w],r2         ; migry; wait count
om_pr_wait:
        tbitb   tx_rdy,statp(r3)        ; if TX-RDY != 0
        bfs     om_print_it:b
        acbd    -1,r2,om_pr_wait
        movqb   on,@diag_fail
        sbitb   om_fail,r7
        br      msg_error:b
om_print_it:
        movb    0(r4),DATAP(r3)

        addqd   1,r4                    ; inCRement message pointer
        cmpqb   0,0(r4)                 ; at end of message?
        bne     om_nxt                  ; transmit next char    

msg_error:                              ; may still be able to send
                                        ; message to other port even
                                        ; first errored

        cmpd    j3base,r3               ; have we done both usarts?
        movd    j3base,r3
        bne     om_loop                 ; if not, do j3
om_done:
        jump    0(r6)                   ; return from subroutine
        .subtitle       "tick: Output tick to console"
;
;       output tick to console, including CR,LF if necessary
;
CRLF_tick:      .byte   CR,LF
tick_only:      .byte   '+',0

tick:
        addr    CRLF_tick,r1
        cbitb   msg_present,r7
        bfs     s_outmsg
        addr    tick_only,r1
        br      s_outmsg
;       .subtitle       "DISP_BINARY: Binary data display on console(s)"
;
;       disp_binary     Subroutine to display on console(s) binary
;                       data
;       input:  r0 = data to be displayed, right justified
;               r1 = number of bits to display (1 <= r1 <= 32)
;               r6 = return address
;
;       output: r2, r3 & r4 are destroyed
;
disp_binary:
        movd    j2base,r2
db_loop:
        movd    r1,r3
db_nxbit:
        addqb   -1,r3
        movzbd  @SWITCHP,r4
        andb    x'0f,r4
        movzwd  wctb:d[r4:w],r4         ; migry add :d ;
db_wait:
        tbitb   tx_rdy,statp(r2)
        bfs     db_print:b
        acbd    -1,r4,db_wait
db_print:
        tbitb   r3,r0
        bfs     db_1:d                  ; migry add :d ;
db_0:   movb    '0',DATAP(r2)
        br      db_la:d                 ; migry add :d ;
db_1:   movb    '1',DATAP(r2)
db_la:  
        cmpqb   0,r3
        bne     db_nxbit
        cmpd    j3base,r2
        movd    j3base,r2
        bne     db_loop
db_done:
        jump    0(r6)
;       .subtitle       "DISP_HEX: Binary data display on console(s)"
;
;       disp_hex        Subroutine to display on console(s) hex data
;
;       input:  r0 = data to be displayed, right justified
;               r1 = number of digits to display (1 <= r1 <= 8)
;               r6 = return address
;
;       output: r2, r3, & r4 are destroyed
;
disp_hex:
        movd    j2base,r2
dh_loop:
        negb    r1,r3
        addb    8,r3
        cmpqb   0,r3
        beq     dh_noadj:d              ; migry add :d ;
dh_adj: rotd    4,r0
        acbb    -1,r3,dh_adj
dh_noadj:
        movb    r1,r3
dh_nxdig:
        rotd    4,r0
        movzbd  @SWITCHP,r4
        andb    x'0f,r4
        movzwd  wctb:d[r4:w],r4         ; migry add :d ;
dh_wait:
        tbitb   tx_rdy,statp(r2)
        bfs     dh_print:b
        acbd    -1,r4,dh_wait
dh_print:
        movzbd  r0,r4
        andb    x'0f,r4
        movb    ascii_tab[r4:b],DATAP(r2)
        acbb    -1,r3,dh_nxdig
        cmpd    j3base,r2
        movd    j3base,r2
        bne     dh_loop
dh_done:
        jump    0(r6)

        .subtitle       "DCT16 initialization code"
;
;       extingquish all three LEDs
;
dct16:  movqb   off,@ds1
        movqb   off,@ds2
        movqb   off,@ds3
;
;       turn on diagnostic run LED
;
        movqb   on,@diag_run
        movqb   0,@diag_mode
        movqb   1,@diag_mode
        .subtitle       "00XX   CPU Test"
;
;       CPU Test
;       write & read all program accessable registers
;
cpu_bgn:
;
;               first verify integrity of r7 (in trouble if it's bad!)
;
        movqd   -1,r7
        cmpqd   -1,r7
        movqd   0,r7
        bne     cpu_error:w                     ;0000
        movqd   0,r7
        cmpqd   0,r7
        movd    x'ff,r7                         ;00FF
        bne     cpu_error:w

        movqw   0,r7    
        movqd   -1,r0
        cmpqd   -1,r0
        addqb   1,r7
        bne     cpu_error:w                     ;0000/0011
        movqd   0,r0
        cmpqd   0,r0
        addqb   1,r7
        bne     cpu_error:w                     ;0002/0012
cpu_tag1:
        movd    r0,r1
        cmpd    r0,r1
        addqb   1,r7
        bne     cpu_error:w                     ;0003/0013
        movd    r0,r2
        cmpd    r0,r2
        addqb   1,r7
        bne     cpu_error:w                     ;0004/0014
        movd    r0,r3
        cmpd    r0,r3
        addqb   1,r7
        bne     cpu_error:w                     ;0005/0015
        movd    r0,r4
        cmpd    r0,r4
        addqb   1,r7
        bne     cpu_error:w                     ;0006/0016
        movd    r0,r5
        cmpd    r0,r5
        addqb   1,r7
        bne     cpu_error:w                     ;0007/0017
        movd    r0,r6
        cmpd    r0,r6
        addqb   1,r7
        bne     cpu_error:w                     ;0008/0018
        cmpqd   -1,r0
        beq     cpu_tag2:b
        movqd   -1,r0
        movb    x'10,r7
        br      cpu_tag1
cpu_tag2:
;
;       CPU Test continued
;       check out all processor registers
;       (we enter this test with r0 set to -1
;
        andd    h'ffffff,r0     ;only 24 bits for next tests
        movb    x'20,r7
cpu_tag3:
        lprd    fp,r0
        sprd    fp,r1
        cmpd    r0,r1
        addqb   1,r7
        bne     cpu_error:b                     ;0021/0031
        sprd    sp,r6           ;save sp
        lprd    sp,r0
        sprd    sp,r1
        cmpd    r0,r1
        lprd    sp,r6           ;restore sp
        addqb   1,r7
        bne     cpu_error:b                     ;0022/0032
        lprd    sb,r0
        sprd    sb,r1
        cmpd    r0,r1
        addqb   1,r7
        bne     cpu_error:b                     ;0023/0033
        sprd    intbase,r6      ;save intbase
        lprd    intbase,r0
        sprd    intbase,r1
        cmpd    r0,r1
        lprd    intbase,r6      ;restore intbase
        addqb   1,r7
        bne     cpu_error:b                     ;0024/0034
        lprw    mod,r0
        sprw    mod,r1
        cmpw    r0,r1
        addqb   1,r7
        bne     cpu_error:b                     ;0025/0035
        cmpqd   0,r0
        beq     cpu_tag4:b
        movqd   0,r0
        br      cpu_tag3
cpu_error:

        sbitb   cpu_fail,r7     ;flag cpu failure
        movqb   on,@diag_fail   ;indicate failure
cpu_tag4:
        lprw    fp,r7           ;save fail code if fp
;       .subtitle       "01XX Configuration and exception setup"
        movw    x'0100,r7
;
;       set exception environment
;
        lprw    psr,0                   ;system / interrupt stack
        addr    stack_top,r0
        lprd    sp,r0
        addr    INTTAB,r0
        ADDD    4*11,R0
        lprd    intbase,r0
;
;       set configuration register
;
        movzbd  fpu_bit,r1
        extd    r1,@SWITCHP,r0,2
c_base: caseb   c_table:d[r0:b]         ; migry add :d ;
c_table:
        .byte   c_11 - c_base
        .byte   c_10 - c_base
        .byte   c_01 - c_base
        .byte   c_00 - c_base

c_11:   setcfg  [m,f]
        br      c_done:d                ; migry add :d ;
c_10:   setcfg  [m]
        br      c_done:d                ; migry add :d ;
c_01:   setcfg  [f]
        br      c_done:d                ; migry add :d ;
c_00:   setcfg  []
c_done:

        .subtitle       "02XX Prom test"
;
;       PROM TEST
;         simple word check sum of prom area
;
;       NOTE:   No fail code used but assigned for consistency
;
;
;
;prom_bgn:
;       movqw   0,r0
;       movw    code_length,r1
;       addr    code_base,r2
;prom_loop:
;       addw    0(r2),r0
;       addqd   2,r2
;       acbw    -2,r1,prom_loop
;       cmpqw   0,r0
;       beq     prom_end:b
;       sbitb   prom_fail,r7
;       movqb   on,@diag_fail
;prom_end:
;       lprw    sb,r0           ;save checksum in sb register
        .subtitle       "ICU & USART Set up"
;
;       Set up ICU (if it exists) for baud clock
;
;       icu baud table
;
        br      icu_init:w
icutbx: .word   2,5,7,11
        .word   15,23,28,31
        .word   47,95,191,383
        .word   429,523,767,1151
;
;       wait count table
;
wctb:   .word   347,347,463,694
        .word   926,1389,1667,1852
        .word   2778,5556,11111,22222
        .word   24876,30303,44444,65000

icu_init:
        movd    icu,r5
        movb    clkm+bus8,mctl(r5)

        movqb   0,cctl(r5)

        movzbd  @SWITCHP,r1
        andb    h'0f,r1
        movb    icutbx:w[r1:w],lcsvl(r5)
        movb    icutbx+1:w[r1:w],lcsvh(r5)
        movb    icutbx:w[r1:w],lccvl(r5)
        movb    icutbx+1:w[r1:w],lccvh(r5)

        movb    x'54,cctl(r5)
;
;       init usart j2 & j3 usarts
;
;
;       usart initialization sequence
;
        br      init_usart:b
termi:  .byte   0,0,0,x'40,x'4e,x'37

init_usart:
        movqd   -6,r1
iulp:   movb    termi+6[r1:b],@j2stat
        movb    termi+6[r1:b],@j3stat
        acbb    1,r1,iulp

        sbitb   usart_rdy,r7            ;flag for exception error exit
;       .subtitle       "03XX J2 & J3 USART Sign-on and loop back tests"
;
;       set local loop back mode and send & receive a message
;       The message sent is the sign on message and is sent to both 
;       j2 & j3
;
;       NOTE:   Fail codes not used but assigned for consistency
;
ll_bgn:
        movd    j2base,r1               ; r1 address of terminal A
ll_loop:
        addr    sign_on,r3
pr_bgn:
        movzbd  @SWITCHP,r2
        andb    x'0f,r2
        movzwd  wctb[r2:w],r2
pr_wait:
        tbitb   tx_rdy,statp(r1)        ; if TX-RDY != 0
        bfs     print_it:b
        acbd    -1,r2,pr_wait
        movqb   on,@diag_fail
        movzbd  j2_pr_fail,r0
        cmpd    j2base,r1
        beq     not_j3:b
        addqb   3,r0
not_j3:
        sbitb   r0,r7   
        br      usart_error:w

print_it:
        movb    0(r3),DATAP(r1)
        movzbd  @SWITCHP,r2
        andb    x'0f,r2
        movzwd  wctb[r2:w],r2
;    Now to read the char just transmitted
rd_wait:
        tbitb   rx_rdy,statp(r1)        ; if RX_RDY != 0
        bfs     read_it:b
        acbd    -1,r2,rd_wait
        movqb   on,@diag_fail
        movzbd  j2_rd_fail,r0
        cmpd    j2base,r1
        beq     not_j3a:b
        addqb   3,r0
not_j3a:
        sbitb   r0,r7   
        br      next_chr:b              ; continue in loop even if read wrong

read_it:
        cmpb    DATAP(r1),0(r3)         ; was char written same read?
        beq     read_ok:b
        movqb   on,@diag_fail
        movzbd  j2_ll_fail,r0
        cmpd    j2base,r1
        beq     not_j3b:b
        addqb   3,r0
not_j3b:
        sbitb   r0,r7   
read_ok:
next_chr:
        addqd   1,r3            ; inCRement message pointer
        cmpqb   0,0(r3)         ; at end of message?
        bne     pr_bgn          ; transmit next char    
usart_error:
        cmpd    j3base,r1       ; have we done both usarts?
        movd    j3base,r1
        bne     ll_loop         ; if not, do j3
ll_te_done:
        sbitb   msg_present,r7  ; flag for 'tick's
;       .subtitle       "Output accumulated error messages"
;
;       now output all the errors we may have accumulated before usart rdy
;
oe_bgn:
        sprw    sb,r5                   ;get prom check sum / save in r5
;
;               first the CPU separately since it can have valid fail code
;
        addr    ocpu_rtn:b,r6
        tbitb   cpu_fail,r7
        bfc     tick                    ;tick if it passed
        sprw    fp,r7                   ;Fail code saved in fp
        addr    cpu_msg,r1
        br      fcemsg
ocpu_rtn:
;
;               next the PROM so we can display checksum
;
        tbitb   prom_fail,r7
        addr    oprom_rtn:b,r6
        BR      tick
;       bfc     tick                    ;tick if it passed
;       movw    x'02ff,r7               ;Fail code saved in fp
;       addr    prom_msg,r1
;       addr    op1:b,r6
;       br      fcemsg
;op1:
;       movw    r5,r0                   ;get checksum
;       movb    4,r1
;       addr    oprom_rtn:b,r6
;       br      disp_hex
oprom_rtn:
;
;               now the rest that could have occured to this point
;
        movw    x'03ff,r7
        addr    j2_pr_msg,r5            ;point to first message
        movzbd  j2_pr_fail,r0           ;bit pointer
        addr    oe_rtn:b,r6

oe_loop:        
        movd    r5,r1
        tbitb   r0,r7
        bfs     errmsg                  ;error message if bit set
        br      tick                    ;tick if not
oe_rtn: addd    f_msg_size,r5
        addqb   1,r0
        cmpb    r0,om_fail
        ble     oe_loop
        .subtitle       "04XX Ram Data Test"
;
;       non destructive Ram Data Test (look for a bad chip or data line)
;
rdt_bgn:
        movw    x'400,r7
        movd    ram_start,r4                            ;address pointer
        movd    (ram_end - ram_start + 1) & ~ 3,r3      ;byte count
        movqd   0,r5                                    ;fail accumulator
rdt_loop:
        movd    0(r4),r0                ;get current contents
        comd    r0,r1                   ;complement it
        movd    r1,0(r4)                ;store complement
        xord    0(r4),r1                ;check complement
        movd    r0,0(r4)                ;store true
        xord    0(r4),r0                ;test true
        ord     r1,r0                   ;or two results
        ord     r0,r5                   ;combine with overall
        addqd   4,r4
        acbd    -4,r3,rdt_loop

        cmpqd   0,r5
        beq     rdt_pass:b
        movqb   on,@diag_fail
        sbitb   any_fail,r7
        addr    rdt_msg,r1
        addr    rdf_dsp:b,r6
        br      fcemsg
rdf_dsp:
        movd    r5,r0
        rotd    16,r0
        ord     r5,r0
        movzbd  16,r1
        addr    rdt_done:b,r6
        br      disp_binary

rdt_pass:
        addr    rdt_done:b,r6
        br      tick

rdt_done:
        .subtitle       "05XX Ram Address Test"
;
;       Non-destructive Ram Address Test (look for bad address line)
;
;               r0:     first address save data
;               r1:     second address save data
;               r2:     first address
;               r3:     second address
;               r4:     address bit number (ordinal)
;               r5:     error field
;               r6:     true test data pattern
;
rat_bgn:
        movw    x'500,r7
        movqd   0,r5                                    ;fail accumulator
        movw    tru_pat,r6
        movqd   1,r4
rat_loop:
        movd    ram_start,r2
        tbitb   r4,r2
        bfc     rat_ns:d                ; migry add :d ;
        movd    r4,r0
        addqb   1,r0
        sbitb   r0,r2
rat_ns: movd    r2,r3
        ibitb   r4,r3
        cmpd    r2,ram_end
        bgt     rat_exit:d              ; migry add :d ;exit_if first address beyond ram_end
        cmpd    r3,ram_end
        bgt     rat_exit:d              ; migry add :d ;exit_if second address beyond ram_end

        movw    0(r2),r0                ;get current RAM contents
        movw    0(r3),r1

        movw    r6,0(r2)                ;write to first
        comw    r6,0(r3)                ;complement to second
        cmpw    r6,0(r2)                ;check integrity of first
        beq     rat_1ok:b
        sbitb   r4,r5
rat_1ok:
        movw    r6,0(r3)                ;write to second
        comw    r6,0(r2)                ;complement to first
        cmpw    r6,0(r3)                ;check integrity of second
        beq     rat_2ok:b
        sbitb   r4,r5
rat_2ok:
        movw    r0,0(r2)                ;restore original data
        movw    r1,0(r3)
        addqb   1,r4
        br      rat_loop                ;end_loop

rat_exit:
        cmpqd   0,r5
        beq     rat_pass:b
        movqb   on,@diag_fail
        sbitb   any_fail,r7
        addr    rat_msg,r1
        addr    raf_dsp:b,r6
        br      fcemsg
raf_dsp:
        movd    r5,r0
        movzbd  24,r1
        addr    rat_done:b,r6
        br      disp_binary

rat_pass:
        addr    rat_done:b,r6
        br      tick
rat_done:
        .subtitle       "06XX Ram Refresh Test"
;
;       Non-destructive Ram Refresh Test
;
rrt_bgn:
        movw    x'600,r7
        movd    ram_start,r6            ;save ram data in r0..r5 & initialize
        movd    tru_pat,r4
        comd    r4,r5

        movw    0(r6),r0
        rotd    16,r0
        movw    r4,0(r6)
        sbitb   lor + 0,r6
        movw    0(r6),r0
        movw    r5,0(r6)

        sbitb   lor + 1,r6
        movw    0(r6),r1
        rotd    16,r1
        movw    r4,0(r6)
        sbitb   lor + 2,r6
        movw    0(r6),r1
        movw    r5,0(r6)

        sbitb   lor + 3,r6
        movw    0(r6),r2
        rotd    16,r2
        movw    r4,0(r6)
        sbitb   lor + 4,r6
        movw    0(r6),r2
        movw    r5,0(r6)

        sbitb   lor + 5,r6
        movw    0(r6),r3
        rotd    16,r3
        movw    r4,0(r6)
        sbitb   lor + 6,r6
        movw    0(r6),r3
        movw    r5,0(r6)

        movd    cpms * ms_wait,r6               ;delay for wait time
rrt_wait:
        acbd    -1,r6,rrt_wait

        movd    ram_start,r6                    ;now check and restore RAM

        cmpw    r4,0(r6)
        beq     rrt7:b
        sbitb   7,r7
rrt7:   rotd    16,r0
        movw    r0,0(r6)
        sbitb   lor + 0,r6
        cmpw    r5,0(r6)
        beq     rrt0:b
        sbitb   0,r7
rrt0:   rotd    16,r0
        movw    r0,0(r6)

        sbitb   lor + 1,r6
        cmpw    r4,0(r6)
        beq     rrt1:b
        sbitb   1,r7
rrt1:   rotd    16,r1
        movw    r1,0(r6)
        sbitb   lor + 2,r6
        cmpw    r5,0(r6)
        beq     rrt2:b
        sbitb   2,r7
rrt2:   rotd    16,r1
        movw    r1,0(r6)

        sbitb   lor + 3,r6
        cmpw    r4,0(r6)
        beq     rrt3:b
        sbitb   3,r7
rrt3:   rotd    16,r2
        movw    r2,0(r6)
        sbitb   lor + 4,r6
        cmpw    r5,0(r6)
        beq     rrt4:b
        sbitb   4,r7
rrt4:   movw    r2,0(r6)

        sbitb   lor + 5,r6
        cmpw    r4,0(r6)
        beq     rrt5:b
        sbitb   5,r7
rrt5:   rotd    16,r3
        movw    r3,0(r6)
        sbitb   lor + 6,r6
        cmpw    r5,0(r6)
        beq     rrt6:b
        sbitb   6,r7
rrt6:   rotd    16,r3
        movw    r3,0(r6)

        cmpqb   0,r7
        bne     rrt_error:b
        addr    rrt_done:b,r6
        br      tick

rrt_error:
        movqb   on,@diag_fail
        sbitb   any_fail,r7
        addr    rrt_msg,r1
        addr    rrt_done:b,r6
        br      fcemsg
rrt_done:
        .subtitle       "07XX MMU test"
;
;       mmu test (if present)
;
;       checks only for proper operation of registers as memory cannot
;       be counted on
;
;

mmu_bgn:
        movw    x'700,r7
        tbitb   mmu_bit,@SWITCHP
        bfs     no_mmu:w

        movqd   0,r0

        addqb   1,r7                    ;start with step 1

                                        ;test page table registers
                                        ;non-destructively
        movd    ptbr_mask,r1

        smr     ptb0,r1
        lmr     ptb0,r0
        smr     ptb0,r3
        xord    r0,r3
        andd    r1,r3
        cmpqd   0,r3
        lmr     ptb0,r1
        bne     mmur_error:w            ;0701
        addqb   1,r7
        lmr     ptb0,r1
        smr     ptb0,r3
        xord    r1,r3
        andd    r1,r3
        lmr     ptb0,r2
        cmpqd   0,r3
        bne     mmur_error:w            ;0702
        addqb   1,r7

        smr     ptb1,r2
        lmr     ptb1,r0
        smr     ptb1,r3
        xord    r0,r3
        andd    r1,r3
        lmr     ptb1,r2
        cmpqd   0,r3
        bne     mmur_error:w            ;0703
        addqb   1,r7
        lmr     ptb1,r1
        smr     ptb1,r3
        xord    r1,r3
        andd    r1,r3
        lmr     ptb1,r2
        cmpqd   0,r3
        bne     mmur_error:w            ;0704
        addqb   1,r7

        movd    bpr_mask,r1
                                        ;check bpr0
        smr     bpr0,r2
        lmr     bpr0,r0
        smr     bpr0,r3
        xord    r0,r3
        andd    r1,r3
        lmr     bpr0,r2
        cmpqd   0,r3
        bne     mmur_error:w            ;0705
        addqb   1,r7
        lmr     bpr0,r1
        smr     bpr0,r3
        xord    r1,r3
        andd    r1,r3
        cmpqd   0,r3
        bne     mmur_error:w            ;0706
        addqb   1,r7
        lmr     bpr0,r2


        smr     bpr1,r2                 ;check bpr1
        lmr     bpr1,r0
        smr     bpr1,r3
        xord    r0,r3
        andd    r1,r3
        lmr     bpr1,r2
        cmpqd   0,r3
        bne     mmur_error:w            ;0707
        addqb   1,r7
        lmr     bpr1,r1
        smr     bpr1,r3
        xord    r1,r3
        andd    r1,r3
        lmr     bpr1,r2
        cmpqd   0,r3
        bne     mmur_error:b            ;0708
        addqb   1,r7

        movd    bcnt_mask,r1

        smr     bcnt,r2                 ;check bcnt
        lmr     bcnt,r0
        smr     bcnt,r3
        xord    r0,r3
        andd    r1,r3
        lmr     bcnt,r2
        cmpqd   0,r3
        bne     mmur_error:b            ;0709
        addqb   1,r7
        lmr     bcnt,r1
        smr     bcnt,r3
        xord    r1,r3
        andd    r1,r3
        lmr     bcnt,r2
        cmpqd   0,r3
        bne     mmur_error:b            ;070A
        addqb   1,r7

        br      mmur_ok:b

mmur_error:                             ;mmu register error has occured
        movd    r3,r0                   ;save the error field in r0
        movqb   on,@diag_fail
        sbitb   any_fail,r7
        addr    mmur_msg,r1
        addr    mmur_rtn:b,r6
        br      fcemsg
mmur_rtn:
        movzbd  8,r1                    ;32 bits of significance
        addr    mmu_done:w,r6
        br      disp_hex

mmur_ok:                                ;tick
        addr    mmurt:b,r6
        br      tick
mmurt:                                  ;now try some tracing
        movb    x'11,r7                 ;start step at x'11
        smr     msr,r6                  ;save msr and set ft
        sbitb   msr_ft,r6
        cbitb   msr_ut,r6
        lmr     msr,r6

        lmr     pf0,r0
        br      extra:b
        nop
extra:
        br      pf1_addr:b
pf1_addr:
        movd    r6,r6
        movd    r0,r0
        br      pf0_addr:b
pf0_addr:
        smr     pf0,r0                  ;check the last nsf
        addr    pf0_addr,r1

        cbitb   msr_ft,r6               ;turn off trace
        lmr     msr,r6

        cmpd    r0,r1
        bne     mmu_error:b             ;0711 error if pf0 not correct
        addqb   1,r7

        smr     pf1,r0
        addr    pf1_addr,r1
        cmpd    r0,r1
        bne     mmu_error:b             ;0712
        addqb   1,r7

        smr     sc,r0
        xord    x'00030004,r0           ;asynchonism cause sc0 to be imprecise
        andd    x'fffffff0,r0
        cmpqd   0,r0
        bne     mmu_error:b             ;0713

no_mmu:                                 ;Want tick even if test not done
        addr    mmu_done:b,r6           ;tick
        br      tick

mmu_error:
        movqb   on,@diag_fail
        sbitb   any_fail,r7
        addr    mmu_msg,r1
        addr    mmu_done:b,r6
        br      fcemsg

mmu_done:
        .subtitle       "08XX FPU tests"
;
;       FPU test (if available)
;
fpu_bgn:
        movw    x'800,r7
        tbitb   fpu_bit,@SWITCHP
        bfs     no_fpu:w

        movf    -1.0e-35,f0
        movf    f0,f1
        movf    f1,f2
        movf    f2,f3
        movf    f3,f4
        movf    f4,f5
        movf    f5,f6
        movf    f6,f7
        cmpf    -1.0e-35,f7
        addqb   1,r7
        bne     fpu_error:w             ;0801

        movf    2.0,f0
        movf    f0,f1
        movf    f1,f2
        movf    f2,f3
        movf    f3,f4
        movf    f4,f5
        movf    f5,f6
        movf    f6,f7
        cmpf    2.0,f7
        addqb   1,r7
        bne     fpu_error:w             ;0802

        movbf   100,f0
        mulf    f0,f1
        mulf    f1,f2
        mulf    f2,f3
        mulf    f3,f4
        mulf    f4,f5
        mulf    f5,f6
        mulf    f6,f7

        addf    f0,f1
        addf    f1,f2
        addf    f2,f3
        addf    f3,f4
        addf    f4,f5
        addf    f5,f6
        addf    f6,f7

        mulf    f7,f7
        divf    1000.0,f7

        truncfd f7,r0
        cmpd    650250,r0
        addqb   1,r7                    ;0803
        bne     fpu_error:b

no_fpu:
        addr    fpu_done:b,r6           ;tick
        br      tick

fpu_error:
        movqb   on,@diag_fail
        sbitb   any_fail,r7
        addr    fpu_msg,r1
        addr    fpu_done:b,r6
        br      fcemsg
fpu_done:

pit_bgn:
        br      pit_s:b
pit_m_cmd:      .byte   pit_sc0 + pit_rlboth + pit_rate_gen + pit_binary
                .byte   pit_sc1 + pit_rlboth + pit_rate_gen + pit_binary
                .byte   pit_sc2 + pit_rlboth + pit_rate_gen + pit_binary
pit_l_cmd:      .byte   pit_sc0 + pit_latch  + pit_rate_gen + pit_binary
                .byte   pit_sc1 + pit_latch  + pit_rate_gen + pit_binary
                .byte   pit_sc2 + pit_latch  + pit_rate_gen + pit_binary
pit_s_cmd:      .byte   pit_sc0 + pit_rlboth + pit_square   + pit_binary
                .byte   pit_sc1 + pit_rlboth + pit_square   + pit_binary
                .byte   pit_sc2 + pit_rlboth + pit_square   + pit_binary
pit_min:        .word    500, 5000, 5000
pit_max:        .word   5000,50000,50000
pit_s:
        movw    x'900,r7
        movd    pit_base,r5             ;pit io_pointer
        addqb   pit_c0,r5               ;start with 0
pit_loop:
;
;               set up for rate gen with max count
;
        movd    r5,r4
        subd    pit_base + pit_c0,r4
        ashd    -1,r4                   ;compute counter number

        movb    pit_m_cmd[r4:b],@pit_mode       ;set up to load count

        movd    cpms * 5,r0             ;prepare for 5 millisecond wait loop
        movqb   0,0(r5)                 ;set max count
        movqb   0,0(r5)
pit_w0:
        acbd    -1,r0,pit_w0            ;wait for 5 ms. (10 Mhz)

        movb    pit_l_cmd[r4:b],@pit_mode       ;latch the count

        movb    pit_m_cmd[r4:b],@pit_mode       ;setup to read both bytes

        movb    0(r5),r0
        movzbd  8,r2                    ;read the counter to r0
        insb    r2,0(r5),r0,8
        negw    r0,r0                   ;get positive number of cycles

        addqb   1,r7
        cmpw    r0,pit_min[r4:w]        ;0901/0911/0921
        blo     pit_err:b

        addqb   1,r7
        cmpw    r0,pit_max[r4:w]
        bls     pit_nxt:b
pit_err:
        addr    pit_msg,r1
        addr    pit_u:b,r6              ;0902/0912/0922
        sbitb   pit_fail,r7
        br      fcemsg
pit_u:  addr    pit_nxt:b,r6
        movqb   4,r1
        br      disp_hex

pit_nxt:
        addb    x'10,r7
        andb    x'f0,r7
        addqb   pit_c2 - pit_c1,r5
        cmpd    r5,pit_base + pit_c2
        ble     pit_loop
;
;       set up timers as square wave to aid debug
;
;       TMR0:   100 hertz
;       TMR1:   1   Khz.
;       TMR2:   1   Khz.
;                       NOTE:   Above frequencies are based on factory
;                               shipping configuration
;
        movd    pit_base,r5

        movb    pit_s_cmd+0,pit_moff(r5)
        movb    pit_s_cmd+1,pit_moff(r5)
        movb    pit_s_cmd+2,pit_moff(r5)

        addqb   pit_c0,r5
pit_2loop:
        movb    1229 & x'ff,0(r5)
        movb    1229 / 256,0(r5)
        addqb   pit_c2-pit_c1,r5
        cmpd    pit_base + pit_c2,r5
        bge     pit_2loop

        tbitb   pit_fail,r7
        bfs     pit_error:b
        addr    pit_done:b,r6
        br      tick

pit_error:
        movqb   on,@diag_fail

pit_done:


;
;       Programmable Peripheral Interface (PPI) test
;
ppi_base:       .equ    io_base + x'020 ;Programmable peripheral interface
ppi_pa:         .equ    0
ppi_pb:         .equ    2
ppi_pc:         .equ    4
ppi_ctl:        .equ    6
ppi_inp_mode:   .equ    x'9b
ppi_out_mode:   .equ    x'80

ppi_bgn:
        movw    x'0a00,r7
        tbitb   test_ppi,@SWITCHP       ;If switch on, don't test ppi
        bfs     no_ppi:d                ; migry add :d ;

        movd    ppi_base,r5
        movb    ppi_out_mode,ppi_ctl(r5);Output mode

        addqb   ppi_pa,r5               ;start on port a

ppi_loop:
        movb    byte_pat,r0
        movb    r0,0(r5)
        xorb    0(r5),r0
        addqb   1,r7
        cmpqb   0,r0
        bne     ppi_d_err:b

        comb    byte_pat,r0
        movb    r0,0(r5)
        xorb    0(r5),r0
        addqb   1,r7
        cmpqb   0,r0
        beq     ppi_nxt:b
ppi_d_err:
        sbitb   ppi_fail,r7
        addr    ppi_msg,r1
        addr    ppi_2:b,r6
        br      fcemsg
ppi_2:  addr    ppi_nxt:b,r6
        movqb   2,r1
        br      disp_hex

ppi_nxt:
        addb    x'10,r7
        andb    x'f0,r7
        addqb   ppi_pb - ppi_pa,r5
        cmpd    r5,ppi_base + ppi_pc
        ble     ppi_loop

        movd    ppi_base,r5
        movb    ppi_inp_mode,ppi_ctl(r5)

        tbitb   ppi_fail,r7
        bfs     ppi_error:d            ; migry add :D ;
no_ppi:
        addr    ppi_done:b,r6
        br      tick
ppi_error:
        movqb   on,@diag_fail
ppi_done:
        .subtitle       "0BXX Interrupt control unit"
;
;       Interrupt Control Unit test
;

icu_bgn:
        movw    icu_code,r7
        movd    icu,r5
        movb    byte_pat,r0
        comb    r0,r1
        movb    r0,hcsvl(r5)
        xorb    hcsvl(r5),r0
        movb    r1,hcsvl(r5)
        xorb    hcsvl(r5),r1
        orb     r1,r0
        cmpqb   0,r0
        bne     no_icu:w
;
;               check out h counter (l counter is the baud clock)
;
        movb    x'ff,r0         ;set up max count
        movb    r0,hccvl(r5)
        movb    r0,hcsvl(r5)
        movb    r0,hccvh(r5)
        movb    r0,hcsvh(r5)

        movd    cpms * 5,r0             ;prepare for 5 millisecond wait loop

        movb    x'5c,cctl(r5)           ;start counter
        movb    clkm + bus8 + cfrz,mctl(r5)
                                        ;freeze the current value registers

        movzbd  hccvh(r5),r1
        ashw    8,r1
        movb    hccvl(r5),r1            ;read the count
        movb    clkm + bus8,mctl(r5)
icu_w1:
        acbd    -1,r0,icu_w1
        movb    clkm + bus8 + cfrz,mctl(r5)
                                        ;freeze the current value registers

        movzbd  hccvh(r5),r0
        ashw    8,r0
        movb    hccvl(r5),r0            ;read the count
        subw    r0,r1
        movw    r1,r0

        addqb   1,r7
        cmpw    r0,icu_min
        blo     icu_t_err:d            ; migry add :D ;
        addqb   1,r7
        cmpw    r0,icu_max
        bls     icu_t_ok:d             ; migry add :D ;
icu_t_err:
        sbitb   icu_fail,r7
        movqb   on,@diag_fail
        addr    icu_msg,r1
        addr    icu_1:b,r6
        br      fcemsg
icu_1:
        addr    icu_t_ok:b,r6
        movb    4,r1
        br      disp_hex

icu_t_ok:
        movb    clkm + bus8,mctl(r5)
        movb    x'54,cctl(r5)
;
;       Now try an interrupt
;
        br      icu_itest:b             ;branch around exception code
;
;       Non vectored interrupt entry point
;
icu_int:
        movw    r7,r0
        andw    x'ff00,r0
        cmpw    icu_code,r0
        bne     nvierr                  ;error if not in icu test
        movd    tos,r0                  ;adjust stack pointer
        movd    tos,r0
        br      icu_iok:w

icu_itest:
        addb    x'10,r7
        andb    x'f0,r7
        movd    icu,r5

        movb    clkm + bus8 + ntar,mctl(r5) ;fixed priority mode
        movqb   0,fprtl(r5)             ;make IR0 highest prior.

        movqb   -1,r0                   ;Mask all interrupts
        movb    r0,imskl(r5)
        cmpb    r0,imskl(r5)
        addqb   1,r7
        bne     icu_i_error:w           ;0B11

        movb    r0,imskh(r5)
        cmpb    r0,imskh(r5)
        addqb   1,r7
        bne     icu_i_error:w           ;0B12

        movb    clkm + bus8 + frz + ntar,r0     ;freeze interrupt samp
        movb    r0,mctl(r5)
        cmpb    r0,mctl(r5)
        addqb   1,r7
        bne     icu_i_error:w           ;0B13

        movb    x'40,ipndl(r5)          ;clear any pending interrupts
        movb    x'40,ipndh(r5)

        cmpqb   0,ipndl(r5)             ;make sure they are clear
        addqb   1,r7
        bne     icu_i_error:w           ;0B14

        cmpqb   0,ipndh(r5)
        addqb   1,r7
        bne     icu_i_error:w           ;0B15

        movb    clkm + bus8 + ntar,r0   ;unfreeze interrupt requests
        movb    r0,mctl(r5)
        cmpb    r0,mctl(r5)
        addqb   1,r7
        bne     icu_i_error:w           ;0B16

        movb    x'fe,r0                 ;unmask IR0
        movb    r0,imskl(r5)
        cmpb    r0,imskl(r5)
        addqb   1,r7
        bne     icu_i_error:w           ;0B17

        movb    x'88,ipndl(r5)          ;set ipnd for IR0
        addqb   1,r7
        tbitb   0,ipndl(r5)
        bfc     icu_i_error:b           ;0B18

        addb    x'10,r7
        andb    x'f0,r7
        LPRD    SP,H'8260               ;TO AVOID ISE PROTECTION ERROR
        bispsrw ipsr                    ;we should interrupt now
        movd    cpms * 100,r0
icu_iw: acbd    -1,r0,icu_iw            ;0B20
                                        ;Should never get here
icu_i_error:
        sbitb   icu_fail,r7
        movqb   on,@diag_fail

        addr    icu_imsg,r1
        addr    icu_done:b,r6
        br      fcemsg

icu_iok:
        
        tbitb   icu_fail,r7
        bfs     icu_done:d              ; migry add :D ;
no_icu:
        addr    icu_done:d,r6           ; migry add :D ;
        br      tick
icu_done:

;       .subtitle       "EXIT from DCT"
;
;       DCT16 Exit code
;
diag_end:
        movd    r7,r0
        cbitb   msg_present,r0          ;isolate fail bits
        cbitb   usart_rdy,r0
        movqw   0,r0
        cmpqd   0,r0
        addr    sf_rtn:d,r6             ; migry add :D ;
        beq     diag_pass:d             ; migry add :D ;
        addr    fail_msg,r1
        br      outmsg

diag_pass:
        addr    pass_msg,r1
        br      outmsg
        
sf_rtn:

        movqb   off,@diag_run
        movqb   0,@diag_mode    
ex:     br      RESET2                  ; RETURN TO TDS INIT
#endif
;+++++++++++++

; end of aint.32k
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; start of acmd.32k

;
;  TABLE OF COMMANDS NAME FOR SEARCH
;
REGNTB: .BYTE   "P","C"    ,"U","S"
        .BYTE   "I","S"    ,"I","N"
        .BYTE   "S","B"    ,"F","P"
        .BYTE   "M","O"    ,"P","S"
        .BYTE   "M","S"    ,"E","I"
        .BYTE   "P","T"    ,"P","F"
        .BYTE   "S","C"    ,"B","P"
        .BYTE   "B","C"    ,"M","M"
        .BYTE   "S","P"    ,"F","S"
        .BYTE   "F"," "    ,"R"," "
        .BYTE   "C","F"    ,"A","D"
        .BYTE   "M","F"    ,"M","L"
        .BYTE   "M","B"    ,"M","W"
        .BYTE   "M","D"
REGTLN: .EQU    ($-REGNTB) / 2
CMNDTB: .BYTE   "M"," "    ,"F"," "
        .BYTE   "S","R"    ,"L"," "
        .BYTE   "D"," "    ,"S","U"
        .BYTE   "S","W"    ,"J","S"
        .BYTE   "C","X"    ,"G"," "
        .BYTE   "S","T"    ,"O","M"
        .BYTE   "P"," "    ,"C"," "
        .BYTE   "B"," "    ,"A","R"     
        .BYTE   "A","C"    ,"A","M"
        .BYTE   "A","F"
CMNTLN: .EQU    ($-CMNDTB) / 2
;                v---------------------------------------------v
;+++++++++++++
#ifdef DB16000
;+++++++++++++
RMSG:   .BYTE   "  TDS16    Rev 2.00 24-NOV-83  DB16000A Version",CR
#endif
;+++++++++++++

#ifdef THEFORCE_MK1
RMSG:   .BYTE   "  TDS16   Rev 2.00 24-NOV-83  FORCE MK1 Version",CR
#endif
#ifdef THEFORCE_MK2
RMSG:   .BYTE   "  TDS16   Rev 1.22 05-FEB-21  FORCE MK2 Version",CR
#endif
RMSGE:  ;47 CHARS + CR
CRL:    .BYTE   CR," ",SPACE," "

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  COMMAND LINE INPUT LOOP  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        .ALIGN 2
MAINLP:
#ifdef DEBUGTHEFORCE
        MOVW    0xabcd,@DEBUGD          ; migry - debug
        SPRD    SP,@DEBUGD              ; migry - debug
        SPRD    SB,@DEBUGD              ; migry - debug
#endif
        MOVQB   FALSE, NOTECHO
        ADDR    TERM1, R7
        ADDR    OUTB+1(R7),R6           ; DTRM.OUTLM:=3
#ifdef DEBUGTHEFORCE
        MOVD    R6,@DEBUGD              ; migry - debug
#endif
        MOVD    '    ', 0(R6)           ;CLEAR INBUF
        MOVD    '    ', 4(R6)
        MOVD    '    ', 8(R6)
        MOVB    CR,-1(R6)               ; OUTB(DTRM.OUTLN-3):=CR 
        MOVXBD  ACKFLG,R3
        MOVQB   2,ACKFLG
        ;
PROCS:  CASEB   PROTB:B[R3:B]           ; CASE OF ACKFLG :
PROTB:  .BYTE   PRO0-PROCS
        .BYTE   PRO1-PROCS
        .BYTE   PRO2-PROCS

        ;
        ; RESET MESSAGE
        ;
PRO0:   
#ifdef DEBUGTHEFORCE
        MOVD    0x12345601,@DEBUGD
#endif
        MOVMD   RMSG,0(R6),4            ;   RESET MESSAGE
        MOVMD   RMSG+16,16(R6),4
        MOVMD   RMSG+32,32(R6),4
        ADDD    RMSGE-RMSG:d,R6         ; migry add :D ;    OUTBUF:= RESET MESEG
RNMES:  BSR     SPRINTA
#ifdef DEBUGTHEFORCE
        MOVD    0x12345602,@DEBUGD
#endif
        BR      MAINLP:W                ;    INLM[DTRM]:=INLM[DTRM]+RMSGE-RMSG
        ;
        ; NMI MESSAGE
        ;
PRO1:   
#ifdef DEBUGTHEFORCE
        MOVD    0x12347801,@DEBUGD
#endif
        MOVD    H'494D4E52,0(R6)        ;   " RNMI"
        ADDQD   4,R6                    ;    OUTBUF:= "RNMI"
#ifdef DEBUGTHEFORCE
        MOVD    0x12347802,@DEBUGD
#endif
        BR      RNMES
;       BR      PROPT1:B                ;    OUTLM[DTRM]:=OUTLM[DTRM]+2
        ;
        ; MAIN  MONITOR
        ;
PRO2:   
#ifdef DEBUGTHEFORCE
        MOVD    0x1234AB01,@DEBUGD
#endif
        MOVB    "*",0(R6)               ;   "*"
        ADDQD   1,R6                    ;    OUTBUF:= "*"
PROPT1: MOVB    ' ',0(R6)               ; OUTB[DTRM.OUTLM]:=CR****WAS CR NOW SP
        ADDQD   1,R6                    ; DTRM.OUTLM:=DTRM.OUTLM+2;
        CMPQB   FALSE,PROCESS           ; IF PROCESS ACTIVE
        BEQ     PROX:B                  ; THEN NO STAR RESP0NSE
        CMPQB   0, ALONFLG              ;IF START OF PROCESS PRINTOUT
        BEQ     ACR:B                   ;THEN DO A CR
        CMPQB   4, ALONFLG              ;ELSE START DOING 4 TO ALINE
        BLE     ACR:B
        ADDQB   1, ALONFLG              ;COUNT FOR PRINTOUT
        MOVD    '    ', -3(R6)
        ADDQD   1, R6
        BR      PROX:B
ACR:    MOVQB   1, ALONFLG
        ADDQD   -2,R6
PROX:   BSR     SPRINTA                 ; PRINT (OUTB)

;+++++++++++++
#ifdef DB16000
        ADDR    STACKL(SB),R0           ; SP:=SB+H'200
#endif
;+++++++++++++

;@@@@@@@@@@@@@@
#ifdef THEFORCE
        MOVD    ALTSTACK,R0             ; alternate stack in RAM for "The Force"
#endif
;@@@@@@@@@@@@@@

        LPRD    SP,R0
        CMPQB   FALSE,PROCESS           ; IF PROCESS IS STILL ALIVE
        BEQ     MOVON:B                 ;   THEN UPDATE TERM LINE
        BSR     PROCIT:W                ;        AND SKIP INPUT
        BR      FSCN4:B                 ;   ELSE GET NEXT LINE
MOVON:  BSR     SRDLIN                  ; CALL STANDARD READ LINE  ROUTINE
FSCN:   CMPD    R5,INLM(R7)             ; IF SCAN = END OF LINE GO TO MAIN LP
        BGE     MAINLP
FSCN2:  CMPB    0(R5),SPACE             ;SPACE,0(R5)IF CHAR >=SPACE GO TO FSCN3
        BGT     FSCN3:B
        ADDQD   1,R5                    ; DTRM.SCN := DTRM.SCN+1
        BR      FSCN
FSCN3:
FSCN4:  
        ADDR    OUTB(R7),R6             ; DTRM.OUTLM:=1
        ADDR    CMNDTB,TOS              ; TBSRCH (3,CMNDTB,(CMNDTBE-CMNDTB)/4)
        MOVB    CMNTLN,TOS
        BSR     TBSRCH                  ; (* SEARCH COMMND-TABLE *)
        CMPQB   TRUE,TOS
        BNE     SYNTERR:W               ; IF COMMAND NOT FOUND IN COMMAND TABLE ERROR
        MOVB    R2,L                    ; L:=COMMAND-NUMBER
MAINCS: CASEW   BRTB:W[R2:W]            ; MAIN CASE OF COMMAND-NUMBER
BRTB:   .WORD   MOVELP-MAINCS   ; MOVE             "M"
        .WORD   FILLP-MAINCS    ; FILL             "F"
        .WORD   SRCHLP-MAINCS   ; SEARCH           "SR"
        .WORD   LOADLP-MAINCS   ; LOAD             "L"
        .WORD   DUMPLP-MAINCS   ; DUMP             "D"
        .WORD   STULP-MAINCS    ; STEP UNTIL       "SU"
        .WORD   STULP-MAINCS    ; STEP WHILE       "SW"
        .WORD   CXPL-MAINCS     ; JSB              "JS"
        .WORD   CXPL-MAINCS     ; CXP              "CX"
        .WORD   GOLP-MAINCS     ; GO               "G"
        .WORD   STEPL-MAINCS    ; STEP N           "ST"
        .WORD   OPC-MAINCS      ; OPERATION MOD    "OM"
        .WORD   PRNTC-MAINCS    ; PRINT            "P"
        .WORD   PRNTC-MAINCS    ; CHANGE           "C"
        .WORD   BEGINL-MAINCS   ; BEGIN            "B"
        .WORD   ALLREG-MAINCS   ; COMPLEX COMND TO PRINTALL G.P REGS  "AR"
        .WORD   ALLCPU-MAINCS   ; COMPLEX COMND TO PRINTALL CPU REGS  "AC"
        .WORD   ALLMMU-MAINCS   ; COMPLEX COMND TO PRINTALL MMU REGS  "AM"
        .WORD   ALLFPU-MAINCS   ; COMPLEX COMND TO PRINTALL FPU REGS  "AF"
SYNTERR:
        MOVQB   FALSE, PROCESS          ;HOOK INTO AHELP ENVIROMENT     
        ADDR    0(R5), TOS              ;PASS LINE START
        BSR     COMD_IN                 ; check for commands
        CMPQB   TRUE, TOS               ;IF NO COMM ERROR THEN LOOP OK
        BEQ     MAINLP
ERRORC:  MOVQB   FALSE,PROCESS          ; CANCEL PROCESS IF ERROR
        MOVB    "?",0(R6)               ; WRITELN (# LF ? #)
        ADDQD   1,R6                    ;  OUTB(NDTRM.OUTLM):= ? 
        MOVQW   0,DEFSET                ; CANCEL PENDING ALONE MODE FLAGS
MSGENT: BSR     SPRINTA
        BR      MAINLP                  ; GOTO MAINLP
;
;     ERRORS TABLE
;
ERTAB:  .BYTE   " NMI NVI"
        .BYTE   " FPU DVZ"
        .BYTE   " UND FLG"
        .BYTE   " BPT ILL"
        .BYTE   " TRC EXT"
        .BYTE   " BPR NST"
        .BYTE   " ABT USR"
        .BYTE   " PND CRC"
        .BYTE   " SRC SVC"
        .BYTE   " CXP MOD"
        .BYTE   " VRF RTS"
ERENT:  ADDR    TERM1, R7
        ADDR    OUTB(R7),R6           ; DTRM.OUTLM:=3
        MOVQW   0,DEFSET                        ;CANCEL PENDING ALONE MODE FLGS
        MOVQB   FALSE,PROCESS                   ; CANCEL PROCESS IF ERROR
        MOVW    CR+H'100*"E",0(R6)              ; INSERT CR LF E 
        MOVXBD  R1,R1
        MOVD    ERTAB+32[R1:D],2(R6)            ; INSERT ERROR MESSAGE
        ADDQD   6,R6
        BR      MSGENT                          ; PRINT MESSAGE
;
;
;        S H X T O B N  ( STANDARD HEX TO BIN  CALL )
;
;
SHXTOBN:
        MOVD    0(SP),TOS
        ADDR    SYNTERR,4(SP)   ; EXIT ADDRESS SYNTERR
        JSR     COMPS           ; COMPRESS LEADING SPACE'S
        ADJSPB 5                ; (* PUSH DUMMY WORD EXERR
        MOVD    R5,TOS          ; VECP:=DTRM.SCN
        MOVD    INLM(R7),TOS    ; ENDP:=DTRM.INLM
        BSR     HXTOBN          ; HEXTOBN (WORD,EXRR,DTRM,SCN,DTRM.INLM)
        MOVD    TOS,R5          ; UPDATE DTRM.SCN
        CMPQB   TRUE,TOS
        MOVD    TOS,R1          ; R1:=WORD
        BNE     SHXTBEX:B       ; IF EXRR THEN
        MOVD    4(SP),0(SP)     ;    EXIT TO ERROR ADDRESS
SHXTBEX: 
        JSR     COMPS           ; COMPRESS LEADING SPACE'S
        RET     4
;
;
;       COMMAND TO PRINT  REGISTER SETS
;
;

; GENERAL PURPOSE REGS DEFINED
ALLRN:
        .BYTE 'R0','R1','R2','R3','R4','R5','R6','R7','@'
        RNNUM: .EQU ($ -ALLRN +1)

ALLREG: SAVE [R0,R1,R2] ;USING R0-R2
        MOVZBD RNNUM,R0 ;SET UP VALUES
        ADDR ALLRN,R1   ;FOR STRING MOVE
        BR ALLEND:W     ;DO STRNG MOVE
;
; CPU REGISTERS DEFINED
ALLCP:
        .BYTE 'PC','SB','FP','US','IS','SP','IN','PS','MO','@'
        CPNUM: .EQU ($ -ALLCP +1)

ALLCPU: SAVE [R0,R1,R2] ;ONCE AGAIN
        MOVZBD CPNUM,R0 ;SET UP VALUES
        ADDR ALLCP,R1   ;FOR STRING MOVE
        BR ALLEND:W     
;
; MMU REGISTERS DEFINED
ALLMM:
        .BYTE 'MS','EI','SC','BC','&'
        .BYTE 'PF0 ','&','PF1 ','&','BP0 '
        .BYTE '&','BP1 ','&','PT0 ','&'
        .BYTE 'PT1 ','@'
        MMNUM: .EQU ($ -ALLMM +1)

ALLMMU: SAVE [R0,R1,R2] ;AND ITS CHAR
        MOVZBD MMNUM,R0 ;GET READY FOR
        ADDR ALLMM,R1   ;MOVE TO PROCBUF
        BR ALLEND:W
;
;       FLOATING POINT REGISTER SET DEFINED
ALLFP:
        .BYTE 'F0','F1','F2','F3','F4','F5','F6','F7','FS','@'
        FPNUM: .EQU ($ -ALLFP +1)

ALLFPU: SAVE [R0,R1,R2] ;MOVE FPU SET
        MOVZBD FPNUM,R0 ;TO PROCBUF
        ADDR ALLFP,R1
        
;
ALLEND: MOVQB TRUE,PROCESS      ;ACTIVATE PROCESS
        ADDR PROCBUF,R2         ;FINAL VALU FOR STRING MOVE
        MOVSB
        RESTORE [R0,R1,R2]
        MOVQB   0, ALONFLG
        BR MAINLP               ;RETURN TO MAINLOOP TO DO PROCESS

SYM_MAT:                        ;SYMBOL MATCHING ROUTINE
        MOVQD   -1, R1          ;FLAG NO MATCH
        CMPQB   TRUE, ASS_BLED
        BNE     S_OUT:W         ;IF NO ASSEMBLT THEN SKIP
        SAVE [R6,R7]            ;SAVE USED REGISTERS
        MOVQD 0, R7             ;START AT LINE 0
        MOVD TXTEND, R6         ;START OF DEBUG DATA
        CMPB 0(R5), 'a' 
        BLT LS:B
        ADDB -H'20, 0(R5)
LS:     CMPB 1(R5), 'a' 
        BLT NX_CMP:B
        ADDB -H'20, 1(R5)               
NX_CMP:
        CMPW 0(R5), 4(R6)[R7:Q]
        BNE NEXTM:W             ;IF NOT THIS SYMBOL TRY NEXTLINE
        MOVD 0(R6)[R7:Q], R1
        TBITD 31, R1            ;IF THIS IS A PC VALU
        BFC APCVAL:B            ;THEN DON'T ADD SB START
        ADDD 0(SVMOD), R1
APCVAL: CBITD 31, R1            ;FIX SB VALUE
        ADDQD 2, R5             ;POINT TO '=' FOR CHANGE COMMAND        
        RESTORE [R6,R7]
        JSR COMPS
        RET     0       
NEXTM:  
        ADDQD 1, R7             ;NEXT LINE
        CMPD R7, LINES  ;
        BLT NX_CMP
        RESTORE [R6,R7]
S_OUT:  RET     0
;
;
;   P R I N T  &  C H A N G E    C O M M A N D S
;
;
;
;
;       REGISTERS PARAMETERS TABLE
;
REGTB:  .BYTE   H'60,H'FF,0,SVPC-SEREA          ; PC DESCRIPTION
USX:    .BYTE   H'60,H'FF,0,SVUS-SEREA          ; US
ISX:    .BYTE   H'60,H'FF,0,SVIS-SEREA          ; IS
        .BYTE   H'60,H'FF,0,SVINTB-SEREA        ; INTB
        .BYTE   H'60,H'FF,-2,SVMOD-SEREA        ; SB
        .BYTE   H'60,H'FF,0,SVFP-SEREA          ; FP
        .BYTE   H'40,H'FF,0,SVMOD-SEREA         ; MOD
        .BYTE   H'40,H'FF,0,SVPSR-SEREA         ; PSR
        .BYTE   H'88,H'FF,0,SVMSR-SEREA         ; MSR
        .BYTE   H'81,H'FF,0,15                  ; EADD
        .BYTE   H'81,1,0,12                     ; PTB
        .BYTE   H'61,1,0,4                      ; PF
        .BYTE   H'81,H'FF,0,8                   ; SC
BREKX:  .BYTE   H'81,1,0,0                      ; BPR
        .BYTE   H'61,H'FF,0,11                  ; BCNT
        .BYTE   H'81,H'FF,0,10                  ; REAL-MSR
        .BYTE   H'62,H'FF,0,0                   ; SP
        .BYTE   H'84,H'FF,0,0                   ; FSR
        .BYTE   H'83,7,0,0                      ; FL
        .BYTE   H'80,7,0,SVR0-SEREA             ; R
        .BYTE   H'25,H'FF,0,0                   ; CNFG
PA_:    .BYTE   H'80,H'F0,0,DUM1-SEREA          ; DUMMY DATA
MF_:    .BYTE   H'80,H'F0,0,DUM2-SEREA          ;   "    "
ML_:    .BYTE   H'80,H'F0,-2,DUM3-SEREA         ;   "    "
MB_:    .BYTE   H'26,H'F0,0,0                   ; MB
        .BYTE   H'46,H'F0,0,2                   ; MW
MD_:    .BYTE   H'86,H'F0,0,4                   ; MD
SFTX:   .BYTE   H'87,15,2,BRKAR-8-SEREA         ; SOFT-BPT
;
BREKT:  .EQU    (BREKX-REGTB) / 4
SFTBT:  .EQU    (SFTX-REGTB) / 4
PA:     .EQU    (PA_-REGTB) / 4
MF:     .EQU    (MF_-REGTB) / 4
ML:     .EQU    (ML_-REGTB) / 4
MB:     .EQU    (MB_-REGTB) / 4
MD:     .EQU    (MD_-REGTB) / 4
;
PRNTC:  SUBB    PRC,R2          ; PUSH GET-PUT PARAMETER
        MOVB    R2,TOS
        ADDR    REGNTB,TOS      ; TBSRCH (REGNTB,REGTLN)
        MOVB    REGTLN,TOS
        BSR     TBSRCH
        CMPQB   TRUE,TOS        ; IF TBSRCH.EXITF=FALSE GOTO SYNTERR
        BNE     SYNTERR
        MOVQD   0,R1
        CMPB    H'FF,REGTB+1[R2:D]
        BEQ     PCH1:B          ; IF REGTB[N1,I]<>H'FF THEN (* THERE IS N*)
        CMPB    R2, PA          ;IF MEMORY CHANGE/PRINT
        BLT     NO_1:B          ;THEN DO SYMSEARCH
        CMPB    R2, MD
        BGT     NO_1:B  
        BSR     SYM_MAT
        CMPB    PA,R2
        BNE     NOTPAD:B
        CMPQD   -1,R1
        BEQ     SYNTERR
        BR      PCH3X:W
NOTPAD: CMPQD   -1, R1          ;IF VALUE MATCHED THEN GO TO PCH
        BNE     PCH0:B
NO_1:   BSR     SHXTOBN         ;    HXTOBN (N) (* ON ERROR GO TO SYNTERR *)
PCH0:   CMPB    H'F0,REGTB+1[R2:D]
        BEQ     PCH1:B          ;    IF REGTB[N1,I]=H'FF THEN
        CHECKB  R0,REGTB+1[R2:D],R1
        BFC     PCH1:B          ;       IF N>REGTB.UPPER OR N<REGTB.LOWER
        CMPB    BREKT,R2        ;       THEN IF I<>BREKT THEN
        BNE     SYNTERR         ;               GOTO SYNTERR
        MOVB    SFTBT,R2        ;            ELSE I=SOFT-BREAK GO TO PCH0;
        BR      PCH0
PCH1:   MOVD    R1,TOS          ; PUSH N PARAMETER
        MOVD    R1,R0           ; {SAVE N}
        CMPQB   PUTI,4(SP)      ; IF L=CHCM (*CHANGE COMMAND *) THEN
        BNE     PCH3:W
        CMPB    "=",0(R5)       ;    IF M(DTRM.SCN)<> "=" GO TO SYNTERR
        BNE     SYNTERR         ;    ELSE
        ADDQD   1,R5            ;       TRM.SCM:=DTRM.SCN+1
        CMPB    SFTBT,R2        ;       THEN IF I<>BREKT THEN
        BNE     NO_2:B
        JSR     COMPS
        BSR     SYM_MAT
        CMPQD   -1, R1          ;IF VALUE MATCHED THEN GO GETPUT
        BNE     DOPU:W
NO_2:   MOVQD   0,DUM1          ;FLAG AS SHORT REAL CONVERSION
        CMPB    R2,MF           ;CHECK FOR IT
        BEQ     AFLOAT:B
        MOVQD   1,DUM1          ;FLAG AS LONG CONVERSION
        CMPB    R2,ML           ;CHECK FOR IT
        BNE     AINT:B
AFLOAT: MOVD    R1, TOS         ;PASS ADDR OF BINARY VALUE
        JSR     COMPS           ; COMPRESS LEADING SPACE'S
        MOVD    R5, TOS         ;START OF STRING
        MOVZBD  30, TOS         ;LENGTH OF STRING
        ADDR    DUM1, TOS       ;RADIX FLAG
        ADDR    DUM2, TOS       ;ERROR RETURN
        BSR     ASC_2_RE
        CMPQD   FALSE,DUM2      ;CHECK
        BNE     ERRORC
        BR      MAINLP  
AINT:   BSR     SHXTOBN         ;       SXTOBN(VALUE) (*ON ERROR GOTO SYNTERR*)
DOPU:   BSR     GETPUT          ;       GETPUT (GET-PUT,N,VALUE);
        BR      MAINLP

PCH3:   MOVQD   0,DUM1          ;SET SHORT CONVERT
        CMPB    MF,R2
        BEQ     UNFLOAT:B
        MOVQD   1,DUM1          ;SET LONG
        CMPB    ML,R2
        BNE     UNINT:B  
UNFLOAT:MOVD    R6, TOS         ;DESTINATION BUFFER
        ADDR    DUM1, TOS       ;RADIX
        MOVD    R1, TOS
        BSR     REAL_2_A
        MOVB    "=",0(R6)
        ADDD    35, R6
        BR      SPIT:W 
UNINT:  BSR     GETPUT          ;    GETPUT (GET_PUT,N,VALUE)
        CMPQB   FALSE,PROCESS   ; IF REAL ALONE AND PROCESS=TRUE
        BEQ     PCH3X:B         ;   THEN OUTPUT REG ID
        MOVD    REGCHR,0(R6)
        ADDQD   4,R6
PCH3X:  MOVB    "=",0(R6)       ;    OUTB(DTRM.OUTLM):="=";
        ADDQD   1,R6            ;    DTRM.OULM:=DTRM.OUTLM+1;

        MOVD    R1,TOS
        EXTSB   REGTB[R2:D],TOS,4,4     ;  (* GET REBTB.LENGTH *)
        MOVQB   2,TOS           ;    BNTOHX (R1,REGTB.LENGTH,2)
        BSR     BNTOHX
SPIT:   BSR     SPRINTA         ;    WRITELN (OUTB)
        BR      MAINLP
;
;
;       G O    C O M M A N D
;
;
;       LOCAL CONSTANTS
;
;
GOLP:   CBITB   PSR_T,SVPSR     ; SVPSR_T:=0 (* DISABLE TRACE *)
        MOVQB   NOTRC,STEPFLG   ; STEPFLG:=STBRK;
STDGO:  MOVZBD  NSFBR,R0                ; FOR I:=NBREAK-2 DOWEN TO 1 DO
GOL1:   TBITB   BPR_BE,BRKAR-4:w[R0:D]  ; migry add :D ; IF BRKAR.BE[I] THEN DO (* B.P. I ENABLE
        BFC     GOL5:W          ;       BEGIN
        MOVD    BRKAR-4:w[R0:D],R1      ; migry add :D ;
        ANDD    H'FFFFFF,R1     ;         R1:=BRKAR[I].ADDR
        MOVB    0(R1),INS-1[R0:B] ;       INS[I]:=M(BRKAR[I].ADDR)
                ; *** MOVSU ***  2
        CMPD    SVPC,R1         ;         IF BRKAR[I].ADDR=PC THEN
        BNE     GOL4:B
        SBITB   PSR_T,SVPSR     ;            PSR_T:=1 (* SET TRACE MODE ONE  *)
        MOVD    R1,ACTBRK       ;            ACTBRK:=I
        ORB     STBRK,STEPFLG   ;            STEPFLG:= STEPBRK (*FLAG GO TRACE
        BR      GOL5:B          ;       ELSE
GOL4:   MOVB    BPTC,0(R1)      ;           M(BRKAR[I].ADDR):=BPT;
        ;       **** MOVSU ****
        CMPB    BPTC,0(R1)      ;           IF NOT WRITTEN  THEN
        BEQ     GOL5:B
        MOVD    R1,R0           ;           ERROR VRF
        MOVB    EVRF,R1
        BR      ERENT
GOL5:   ACBB    -1,R0,GOL1      ; END;
        BSR     MNEXIT
;
;
;       S T E P   N    C O M M A N D
;
;
STEPL:  MOVQD   1,STPCNT        ; STEPCOUNT:=1
        CMPB    CR,0(R5)        ; IF DTRM.SCN= CR GOTO 1 STEP
        BEQ     STP2:B
        BSR     SHXTOBN         ; SHXTOBN (N) (* ON ERROR GO TO STP2 *)
        ABSD    R1, R1
        MOVD    R1,STPCNT       ; STEPCOUNT:= N
STP2:   
        CMPB    CR,0(R5)        ; IF DTRM.SCN<> CR GOTO SYNTERR
        BNE     SYNTERR
        MOVQB   STPN,STEPFLG    ; STEPFLAG:=STEP N
        SBITB   PSR_T,SVPSR     ; SVPSR_T:=1 (* SET TRACE MODE *)
        BR      STDGO           ; GOTO STDGO;
;
;
;       B E G I N    J S R     C X P    C O M M A D S
;
;
BEGINL: MOVQB   FALSE, SPACIT   ;FLAG NOT AUTO THEN CHECK
        CMPQB   TRUE, ASS_BLED
        BNE     NOT_A:W
        CMPQD   -1, A_MOD       ;CHECK FOR AUTO DONE
        BEQ     NOT_A:W
        CMPB    'Z', 0(R5)      ;CHECK FOR ZERO INIT OPTION
        BNE     JUSTB:B
        MOVD    A_SB, R1        ;ZERO MEMORY FROM SB TO SP
ZME:    MOVQD   0, 0(R1)
        ADDQD   4, R1
        CMPD    R1, A_SP
        BLE     ZME
        BR      MOK:B   
JUSTB:  CMPB    CR, 0(R5)       ;CHECK FOR NO PARAMETERS
        BNE     NOT_A:B         ;DONT DO AUTO
MOK:    MOVQB   TRUE, SPACIT    ;FLAG THAT AUTO BEGIN   
        MOVW    H'300,SVPSR     ;SET PSR TO USER MODE
NOT_A:  MOVQB   1,CXPFLG        ; CXPFLG:=1 {FLAG OF BEGIN}
        MOVQD   0,OLDPC         ; OLDPC := 0 ; {RESET PC AFTER END OF PROGRAM}
        BR      CXPL2:B
CXPL:   MOVQB   FALSE, SPACIT   ;NOT AUTO
        CMPQB   2,CXPFLG        ; IF CXPFLG=2 {SECOND CXP} 
        BNE     CXPL1:B         ; THEN ERROR CXP
        MOVZBD  ECXP,R1
        BR      ERENT
CXPL1:  MOVQB   2,CXPFLG        ; ELSE CXPFLG:=2;
        MOVMD   SVPC,OLDPC,3    ; SAVE PC,US,IS,MOD
                        ; XXX 12
CXPL2:  CMPQB   FALSE, SPACIT
        BEQ     NO_A_SP:d       ; migry add :D ;
        MOVD    A_SP, SVUS      ;SET US TO A_SP VALUE
NO_A_SP:ADDR    SVUS,R3         ; R3:=ADDR OF US
        TBITB   PSR_S,SVPSR     ; IF PSR_S=1 THEN
        BFS     CXPL3:B         ;   R3:= ADDR OF IS
        ADDR    SVIS,R3
CXPL3:  MOVD    0(R3),R4        ; R4:=SP
        CMPQB   FALSE, SPACIT   ;
        BEQ     GETMA:B
        MOVD    A_MOD, R1
        BR      SETMA:B
GETMA:  BSR     SHXTOBN         ; SHXTOBN (ADDR)
SETMA:  MOVD    R1,R2           ; R2:=ADDR  (*MOD *)
        CMPB    JSBC,L          ; IF L=CXP THEN
        BEQ     CXPL5:W         ; BEGIN
        CMPQB   FALSE, SPACIT   ;IF AUTO THEN SET OFFSET TO 0
        BEQ     GETOF:B
        MOVQD   0, R1           
        BR      SETOF:B
GETOF:  BSR     SHXTOBN         ;    SHXTOBN (OFFSET)
SETOF:  MOVD    R2,SVMOD        ;    MOD:= READ MOD
        ADDD    8(R2),R1        ;    R1:=OFFSET+(8+(MOD)) (* NEW PC *)
                ; *** MOV US
        CMPB    FALSE, SPACIT   ;BUILD A MOD TABLE IF AUTO
        BEQ     NOB:B
        MOVD    A_SB, 0(R2)     ;ENTER SB START
        MOVQD   0, 4(R2)        ;ZERO LINK TABLE
        MOVD    A_PC, 8(R2)     ;SET PC START

;+++++++++++++
#ifdef DB16000
        ADDR    STACKL(SB),R1   ; SP:=
        ADDR    256(R1), SVIS   ;SET USER IS AREA
#endif
;+++++++++++++

;@@@@@@@@@@@@@@
#ifdef THEFORCE
        MOVD    ALTSTACK,R1
        MOVD    ISTACK,SVIS
#endif
;@@@@@@@@@@@@@@

        MOVD    A_PC, R1        ;SET PC START
        MOVQD   0, 12(R2)       ;ZERO RESERVED AREA     
        MOVQD   0, SVFP         ;SET FP TO 0
NOB:    ADDQD   -4,R4
        SPRD    MOD,0(R4)       ;    PUSH MONITOR MOD ON USER STACK
                ; *** MOV SU
                                ; END;
CXPL5:  MOVD    R1,SVPC         ; GO PC:=R1
        ADDQD   -4,R4
        ADDR    CXPRL:d,0(R4)   ; migry add :D ; PUSH CXPRL AS RETURN ADDRES
                ; *** MOV SU
        MOVD    R4,0(R3)        ; UPDATE USER SP
        CMPQB   2,CXPFLG        ; IF CXPFLG=2 GOTO GOLP {TO USER PROGRAM}
        BEQ     GOLP            ; ELSE GOTO MAINLP
        BR      MAINLP
;
CXPRL:  BPT                     ; FOR END OF PROGRAM AND CALL COMMANDS
;
;
;       S T E P   U N T I L  /  W H I L E
;
;
STULP:  MOVQB   STW,R3          ; R3:=0
        CMPB    STWC,L          ; IF L=STW THEN  (* COMMAND IS STW *)
        BEQ     STU2:B          ;   R3:=1
        MOVQB   STU,R3
STU2:   ADDR    REGNTB,TOS      ; TBSRCH(2,REGTB,REGNLN)
        MOVB    REGTLN,TOS
        BSR     TBSRCH
        CMPQB   TRUE,TOS        ; IF  NOT EXITF THEN  GOTO SYNTERR
        BNE     SYNTERR         ; ELSE
        MOVQD   0,R1            ;   N PARAMETER :=0
        CMPB    H'FF,REGTB+1[R2:D]
        BEQ     STU3:B          ;   IF REGTB[N1,I]=H'FF THEN
        BSR     SHXTOBN         ;   HXTOBN (N) (* ON ERROR GOTO SYNTERR *)
        CMPB    H'F0,REGTB+1[R2:D]; IF REGTB[N1,I]=H'FF THEN
        BEQ     STU3:B
        CHECKB  R0,REGTB+1[R2:D],R1;   IF N>REGTB.UPPER OR N<REGTB.LOWER
        BFS     SYNTERR         ;       THEN GOTO SYNTERR;
STU3:   MOVD    R1,STUADD       ;   STUADD:=N
        MOVB    R2,STUADD+3     ;   STUADD.TYPE:=R2
STU5:                           ; END ;
        MOVQD   3,R0            ; FOR I:=1 TO 3 DO
STU6:   BSR     SHXTOBN         ;     SHXTOBN (VALUE) ;
        MOVD    R1,STUADD[R0:D] ;     STUADD[I]:=VALUE
        ACBB    -1,R0,STU6      ; END ;
        MOVB    R3,STEPFLG      ; STEPFLG:=STU OR STW
        SBITB   PSR_T,SVPSR     ; PSR_T:=1 (* SET TRACE BIT *)
        BR      STDGO
;
;
;
;
;       L O A D    C O M M A N D
;
;       NOT IMPLEMENTED
;
;
LOADLP: BR      SYNTERR
;
;
;
;       D U M P    C O M M A N D
;
;
;
;
DUMPLP:
        MOVQD   0,CHRNUM        ; SET NUMBER FOR ASC DUMP TO 0
DUX:    MOVQB   0,R4    ; TERM:=NDTRM
MDU5:                           ; END; IF
        BSR     SHXTOBN         ; HXTOBN(ADDR1);
        MOVD    R1,R2           ; {R2:=ADDR1}
        ABSD    R2,R2           ;POSITIVE VALUE ONLY
        BSR     SHXTOBN         ; SHXTOBN(ADDR2);
        MOVB    MON_BASE, NEGIT ;SAVE RADIX
        MOVQB   3, MON_BASE     ;SET TO HEX
        CMPQD   1, R1           ;POSITIVE VALUE >= 1 ONLY
        BLE     DULIN:B
        MOVQD   1, R1
DULIN:                          ; REPEAT
        MOVQD   0,R3            ;   CRC:=0;
        ADDR    TERM1,R6        ;   OUTB:=TERM1.OUTB
DUL3:   MOVD    R6,TOS          ; {PUSH START ADDRESS OF PRINT ARRAY FOR PRINTA
        MOVD    CRL,0(R6)       ;   OUTB(OUTLM):= CR,LF,"L";
DUL3X:  ADDQD   3,R6            ;   OUTLM:=OUTLM+3;
        MOVD    R2,TOS          ;   BNTOHX(ADDR1,6,2);
        MOVW    H'602,TOS
        BSR     BNTOHX
        MOVB    SPACE,0(R6)     ;   OUTB(OUTLM):=SPACE;
        ADDQD   1,R6            ;   OUTLM:=OUTLM+1
        MOVZBD  NLIN,R0         ;   L := NLIN {# OF BYTES IN A LINE}
        CMPD    R1,R0           ;   IF N<NLIN
        BGE     DULOOP:B        ;   THEN L := N;
        MOVD    R1,R0
DULOOP: MOVZBD  0(R2),TOS       ;   FOR I=1 TO L DO
        ; *** MOVUS ***
        BSR     DUMPASC:W               ; UPDATE ACSII DUMP BUFFER
        ADDQD   1,R2            ;      ADDR1:=ADDR1+1;
        MOVW    H'200,TOS       ;      BNTOHX(M(ADDR1),2,0);
        BSR     BNTOHX
        MOVB    SPACE,0(R6)
        ADDQD   1,R6
NOSPAC: ADDQD   -1,R1           ;      N := N-1;
        ACBD    -1,R0,DULOOP    ;   END;   {FOR}
        MOVD    H'22202020,0(R6); CLEAR FIRST 4 CHARS TO '"   '
        ADDQD   4,R6            ; UPDATE CHAR COUNT FOR PRINTA
        BSR     MOVASC:W        ; FILL IN ASCII CHARS
        MOVB    '"',0(R6)       ; END BORDER OF ASCII CHAR
        ADDQD   1,R6            ; FIELD
NOASCD: MOVD    R6,TOS          ;   {PARAMETERS FOR PRINTA}
        MOVB    R4,TOS
        CMPQD   0,R1            ;   IF N=0
        BEQ     DUEXT:B         ;   THEN GOTO DUEXT;
        MOVB    0x92,TOS                ; for alignment
        BSR     PRINTA          ;   PRINTA (OUTB(1),OUTB(OUTLM),TERM,OPHND)
        BR      DULIN           ; UNTIL ADDR1>ADDR2
DUEXT:  MOVB    CR,0(R6)        ; OUTB(OUTLM):= CR ;
        ADDQD   1,1(SP)         ; PRINTA (OUTB(1),OUTB(OUTLM+2),TERM);
        MOVB    0x93,TOS                ; for alignment
        BSR     PRINTA
        MOVB    NEGIT, MON_BASE ;RESTORE RADIX
        BR      MAINLP
;
;
;
;   M O V E    F I L L    S E A R C H   C O M M A N D S
;
;
;
;
OPTB:   .BYTE   "B W D "        ; B W D AND V OPTIONS SEARCH TABLE
OPTBL:  .EQU    ($-OPTB) / 2    ; OPTION TABLE LENGTH
BCOM:   .BYTE   3,2,0           ; BEGIN WORD FOR EACH COMMAND
VRFERR1: MOVB   EVRF, R1
         BR     ERENT   
;
;
MOVELP:
FILLP:
SRCHLP:
        ADDR    (-MOVC)(R2),R4  ; L:=COMMAND NUMBER (0 MOVE 1 FILL 2 SRCH
        BSR     SHXTOBN         ; SHXTOBN (ADDR1);
        MOVD    R1,R0           ; R0:=ADDR1
        BSR     SHXTOBN         ; SHXTOBN(ADDR2);
        MOVD    R1,R3           ; R3:=ADDR2;
        BSR     SHXTOBN         ; SHXTOBN(ADDR3)
        ADDR    OPTB,TOS        ; TBSRCH(OPTB,3);
        MOVQB   3,TOS
        BSR     TBSRCH
        CMPB    0(R5),"N"       ; IF INBUF(DTRM.SCN)="N"
        BNE     SPC5:B          ; THEN NO-VERIFY BIT:=TRUE;
        ORB     4,R2
SPC5:   ASHD    2,R2            ; END IF
        ORB     BCOM[R4:B],R2
        CMPQB   MOVC,R4         ; IF MOVE COMMAND 
        BNE     SPC9:B          ; THEN
        MOVD    R0,R5           ;    R5:=ADDR1;
        MOVD    R3,R0           ;    ADDR1:=ADDR2;
        ADDD    R1,R3           ;    ADDR2:=ADDR1+N-1;
        ADDQD   -1,R3           ; ELSE
SPC9:   MOVB    R2,SCRCH1       ; {SAVE CASE WORD}
        ANDB    H'0F,R2
                                ; FOR I:= 1 TO N DO 
                                ; BEGIN
SPCL:   MOVQD   1,TOS           ;   STEP:=1;
;
;        CASE BRANCH TABLE
;
;
SPCS:   CASEB   SPCBTB:B[R2:B]  ;    CASE OF (OPTWORD AND V BIT)
SPCBTB: .BYTE   SRCHB-SPCS      ; SRCH  B
        .BYTE   SERR-SPCS       ; NOT EXISTS
        .BYTE   FILLB-SPCS      ; FILL  B
        .BYTE   MOVEB-SPCS      ; MOVE  B
        .BYTE   SRCHW-SPCS      ; SRCH  W
        .BYTE   SERR-SPCS       ; NOT EXISTS
        .BYTE   FILLW-SPCS      ; FILL  W
        .BYTE   SERR-SPCS       ; MOVE  W
        .BYTE   SRCHD-SPCS      ; SRCH  D
        .BYTE   SERR-SPCS       ; NOT EXISTS
        .BYTE   FILLD-SPCS      ; FILL  D
        .BYTE   SERR-SPCS       ; MOVE  D
MOVEB:  MOVB    0(R5),R1        ;     "B"  X:=M(SOURCE-ADDR)
        ; *** MOVUS ***
        ADDQD   1,R5            ;          SOURCE-ADDR:=SOURCE-ADDR+1;
FILLB:  MOVB    R1,0(R0)        ;          M(DESTINATIN-ADDR):=X;
        ; *** MOVSU ***
SRCHB:  CMPB    R1,0(R0)
        ; *** MOVUS ***
SPCF:   TBITB   4,SCRCH1
        BFS     SPCRP:B         ;         IF F THEN
        BEQ     SPC10:B         ;           IF M(DESTINATION-ADDR)<>X THEN
        CMPQB   SRCHC,R4        ;             IF NOT SRCH COMMAND
        BNE     VRFERR1         ;             THEN GOTO VRFERR;
        BR      SPCRP:B
SPC10:  CMPQB   SRCHC,R4        ;           ELSE
        BNE     SPCRP:B         ;             IF SRCH COMMAND THEN
        MOVB    "=",0(R6)       ;             BEGIN
        ADDQD   1,R6            ;               DTRM.OUTB:= "=";
        MOVD    R0,TOS          ;               DTRM.OUTLM:=DTRM:OUTLM+2;
        MOVW    H'602,TOS       ;               BNTOHX (DESTENATIN-ADDR,6,2);
        BSR     BNTOHX
        BR      MSGENT          ;               SPRINTA; RETURN TO MAINLP;
                                ;             END;
                                ;          END;
SPCRP:  ADDD    TOS,R0          ;          DESTINATION-ADDR:=DESTINATION+STEP
        CMPD    R0,R3           ; END FOR
        BLE     SPCL
        CMPQB   SRCHC,R4        ; IF NOT SRCH COMMAND THEN RETURN TO MAINLP
        BEQ     SPERR:B         ; ELSE 
        BR      MAINLP
SPERR:  MOVZBD  ESRC,R1         ;  ERROR (SRC);
        BR      ERENT
FILLW:  ADDQD   1,0(SP)         ;           STEP:=STEP+1;
        MOVW    R1,0(R0)        ;    "W"    M(DESTINATION-ADDR):=X
        ; *** MOVSU ***
SRCHW:  CMPW    R1,0(R0)
        ; *** MOVSU ***
        BR      SPCF
FILLD:  ADDQD   3,TOS           ;            STEP:=STEP+3;
        MOVD    R1,0(R0)        ;     "D"    M(DESTINATION-ADDR):=X;
        ; *** MOVSU ***
SRCHD:  CMPD    R1,0(R0)
        ; *** MOVSU ***
        BR      SPCF
SERR:   BR      SYNTERR
;
;
; O P E R A T I N G      M O D E   C O M M A N D
;
;
OPC:    
        BSR     SHXTOBN         ;   R1:= CONFIGURATION NUMBER
OP8:    CMPB    0(R5),CR        ; IF INBUF[DTRM.SCN]<>CR SYNTAX ERROR
        BNE     SYNTERR
OP10:   MOVB    R1,OPHND        ; UPDATE OPMOD
        BR      MAINLP
        .ENDSEG

;
;       PROCESS CONTROLLER FOR COMPLEX COMMANDS
                        ;TO PRINT CPU REGS
;

PROCIT: .PROC                   ;PROCIT SIMULATES A SEQUENCE OF SIMPLE
        .VAR [R0,R1,R2]         ;COMMND INPUT TO MAINLP
        .BEGIN
        ADDR OUTB(R7),R0        ;GET ADDRESS OF TERMINAL INPUT
        MOVD R0,R5              ;DTERM.SCN=1
        CMPB PRNTAC,PROCESS     ;IF PRINT debug data else do reglist
        BNE  ALIST:W            ;THEN SET THAT PROCESS
        MOVQB 0,ALONFLG         ;START NEW LINE FLAG    
        CMPQB TRUE, ASS_BLED    ;IF NO ASSEMBLY THEN ERROR
        BNE SYNTERR             
        SAVE [R3,R6,R7]         ;SAVE USED REGISTERS
        MOVQD 0, LINNUM         ;START AT LINE 0
        MOVD LINES, R7          ;DO FOR ALL LINES
        MOVD TXTEND, R6         ;START OF DEBUG DATA
        MOVQD 0, R3             ;INDEX INTO DATA

NX_COMP:
        CMPD SVPC, 0(R6)[R3:Q]
        BNE NEXT:B              ;IF NOT THIS PC TRY NEXTLINE
        MOVD H'200D5054, 0(R0)  ;INLN = TP<CR>" "
        RESTORE [R3,R6,R7]
        BR SYNTERR      
NEXT:   
        ADDQD 1,LINNUM          ;NEXT LINE
        ADDQD 1, R3             ;NEXT INDEX
        CMPD LINNUM, LINES      ;
        BLT NX_COMP
        RESTORE [R3,R6,R7]
        BR ERROR

ALIST:  ADDR PROCBUF,R1         ;GET ADDRESS OF SELECTED PROCESS
        ADDR REGCHR,R2          ;AND OF REGISTER ID
        MOVW SPACES,2(R2)       ;CLEAR REG ID CHARACTERS
        MOVW SPACES,2(R0)       ;CLEAR INLN
PROLOOP:
        CMPB '@',0(R1)          ;IF PROBUF[N]=TERMINATION CHAR
        BEQ PRCDONE:d           ; migry add :D ;             ;       THEN DONE 
        CMPB SPACE,0(R1)        ;ELSE IF CURRENT PROBUF[N] IS SPACES
        BNE STOIT:d             ; migry add :D ;               ;       THEN GET NEXT
        ADDQD 1,R1              ;ELSE MOV COMMND TO TERM BUFFER
        BR PROLOOP
STOIT:
        MOVB 'P',0(R0)          ;MAKE IT A 'PRINT' COMMAND
        CMPB '&',0(R1)          ;IF LEAD IN CHAR & THEN 4CHAR COMMND
        BNE TWOCHR:B            ;ELSE 2CHAR
        MOVB SPACE,0(R1)        ;CANCEL THE &
        ADDQD 1,R1              ;PROBUF[N]=PROBUG[N+1]
        MOVW 0(R1),1(R0)        ;PROBUF[N,N+1]=OUTB1,2
        MOVW 0(R1),0(R2)        ;    "    "   =REGISTER CHAR 1,2
        MOVW SPACES,0(R1)       ;CANCEL PROBUF[N,N+1]
        ADDQD 2,R1              ;UPDATE POINTERS
        ADDQD 2,R0
        ADDQD 2,R2
TWOCHR: MOVW 0(R1),1(R0)        ;MOVE ONLY TWO CHAR
        MOVW 0(R1),0(R2)
        MOVW SPACES,0(R1)       ;TO OUTB
        BR PRCEXT:d             ; migry add :D ;               ;FINISH WITH CR
PRCDONE:
        MOVB FALSE,PROCESS      ;CANCEL PROCESS FLAG
        BR MAINLP               ;RETURN TO MAIN LOOP    
PRCEXT:
        .ENDPROC


;
;       SUBROUTINE TO FILL ASCII CHAR FIELD
;
DUMPASC:        .PROC
        .VAR [R0]
        .BEGIN
        ADDR     ASCDUMP,R0
        ADDD     CHRNUM,R0      ;OFFSET TO NEXT CHAR
        MOVB    SPACE,0(R0)     ; INIT CHAR VALUE TO 'SPACE'
        CMPB    0(R2),H'1F      ; IF BYTE IS LESS THAN/=
        BLE     NOCHR:B         ;   CHR(US) 
        CMPB    0(R2),H'7F      ; OR >= CHR(DEL)
        BGE     NOCHR:B         ; THEN NO CONVERSION
        MOVB    0(R2),0(R0)     ; ELSE MOVE TO DUMP
NOCHR:  ADDQD   1,CHRNUM        ; BUFFER
        .ENDPROC
;
;
;       SUBOUTINE TO FILL TERM1 BUFFER WITH ASCII DUMP CHARS
;
MOVASC: .PROC
        .VAR[R0]
        .BEGIN

        MOVQD   0,R0                    ;SET MOVER COUNTER TO 0
MOVNXT: MOVB    ASCDUMP[R0:B],0(R6)     ;MOVE BYTES TO TERM BUFFER
        ADDQD   1,R6                    ;UPDATE DTERM CHAR COUNT
        ADDQD   1,R0
        ADDQD   -1,CHRNUM
        CMPQB   0,CHRNUM                ;UNTIL CHAR COUNT
        BNE     MOVNXT                  ;IS EQUAL TO 0
        .ENDPROC
; end of acmd.32k
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; start of ahelp.32k


;          M A I N     P R O C E D U R E

MONASM:         .PROC   ;ENTRY PROC TO ASSEMBLE A LINE

        ;INPUT PARAMETERS

CODESTRT:       .BLKD   ;ADDR OF FIRST BYTE TO CODE AT

LIN_STRT:       .BLKD   ;VEC TO START OF INPUT LINE

LIN_END:        .BLKD   ;NUMBER OF INPUT CHAR

                .RETURNS

        ;RETURN PARAMETERS

CODEEND:        .BLKD   ;NUMBER OF BYTES IN INST

A_ERROR:        .BLKD   ; ERROR CODE RETURN 0=OK

        .VAR [R0,R1,R2,R3,R4,R5,R6,R7]  ;SAVE ALL REGS


        .BEGIN
INITAL: MOVXWD  -SBSIZE,R0      ;INITIALIZE SB VARIABLES TO
INVAL:  MOVQB   0,SBEND[R0:B]   ; ZERO
        ACBD    1,R0,INVAL
        MOVD    CODESTRT, PC_ADDR       ;SAVE CURRENT ADDRESS
 
        BR      CODIT:d         ; migry add :D ;         ;GO START PARSE
                ;ERROR MESSAGES
NO_SUCH_INST:   .BYTE   'BAD_INS',CR
SYM_ERR1:       .BYTE   'DUP_SYM',CR
SYM_ERR2:       .BYTE   'BAD_TAB',CR
SYM_ERR3:       .BYTE   'UND_SYM',CR
PSU_ERR:        .BYTE   'BAD_PSU',CR
REAL_BAD:       .BYTE   'BAD_NUM',CR
ERR_SEG:        .BYTE   'ERR_SEG',CR    
BAD_LIN:        .BYTE   'BAD_LIN',CR
;.NOLIST

CODTABL:; 1       2       3       4       5       6       7        8   
.FIELD  [3]4,   [2]2,   [2]1,   [5]11,  [5]6,   [5]0,   [5]0,   [CAT]0
.BYTE   'MOV$'
.BYTE   H'14,H'00

.FIELD  [3]4,   [2]2,   [2]1,   [5]11,  [5]6,   [5]0,   [5]0,   [CAT]0
.BYTE   'CMP$'
.BYTE   H'04,H'00

.FIELD  [3]4,   [2]2,   [2]1,   [5]11,  [5]6,   [5]0,   [5]0,   [CAT]0
.BYTE   'ADD$'
.BYTE   H'00,H'00

.FIELD  [3]5,   [2]2,   [2]1,   [5]11,  [5]6,   [5]0,   [5]0,   [CAT]0
.BYTE   'ADDC$'
.BYTE   H'10,H'00

.FIELD  [3]4,   [2]2,   [2]1,   [5]11,  [5]6,   [5]0,   [5]0,   [CAT]0
.BYTE   'SUB$'
.BYTE   H'20,H'00

.FIELD  [3]5,   [2]2,   [2]1,   [5]11,  [5]6,   [5]0,   [5]0,   [CAT]0
.BYTE   'SUBC$'
.BYTE   H'30,H'00

.FIELD  [3]4,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'NEG$'
.BYTE   H'4E,H'20,H'00

.FIELD  [3]4,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'ABS$'
.BYTE   H'4E,H'30,H'00

.FIELD  [3]4,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'MUL$'
.BYTE   H'CE,H'20,H'00

.FIELD  [3]4,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'DIV$'
.BYTE   H'CE,H'3C,H'00

.FIELD  [3]4,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'MOD$'
.BYTE   H'CE,H'38,H'00

.FIELD  [3]4,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'QUO$'
.BYTE   H'CE,H'30,H'00

.FIELD  [3]4,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'REM$'
.BYTE   H'CE,H'34,H'00

.FIELD  [3]4,   [2]2,   [2]1,   [5]11,  [5]6,   [5]0,   [5]0,   [CAT]0
.BYTE   'AND$'
.BYTE   H'28,H'00

.FIELD  [3]3,   [2]2,   [2]1,   [5]11,  [5]6,   [5]0,   [5]0,   [CAT]0
.BYTE   'OR$'
.BYTE   H'18,H'00

.FIELD  [3]4,   [2]2,   [2]1,   [5]11,  [5]6,   [5]0,   [5]0,   [CAT]0
.BYTE   'BIC$'
.BYTE   H'08,H'00

.FIELD  [3]4,   [2]2,   [2]1,   [5]11,  [5]6,   [5]0,   [5]0,   [CAT]0
.BYTE   'XOR$'
.BYTE   H'38,H'00

.FIELD  [3]4,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'COM$'
.BYTE   H'4E,H'34,H'00

.FIELD  [3]4,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]SWIP
.BYTE   'ASH$'
.BYTE   H'4E,H'04,H'00

.FIELD  [3]4,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]SWIP
.BYTE   'LSH$'
.BYTE   H'4E,H'14,H'00

.FIELD  [3]4,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]SWIP
.BYTE   'ROT$'
.BYTE   H'4E,H'00,H'00

.FIELD  [3]6,   [2]3,   [2]0,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'MOVXBW'
.BYTE   H'CE,H'10,H'00

.FIELD  [3]6,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'MOVX$D'
.BYTE   H'CE,H'1C,H'00

.FIELD  [3]6,   [2]3,   [2]0,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'MOVZBW'
.BYTE   H'CE,H'14,H'00

.FIELD  [3]6,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'MOVZ$D'
.BYTE   H'CE,H'18,H'00

.FIELD  [3]4,   [2]2,   [2]0,   [5]11,  [5]6,   [5]0,   [5]0,   [CAT]0
.BYTE   'ADDR'
.BYTE   H'27,H'00

.FIELD  [3]5,   [2]2,   [2]1,   [5]7,   [5]11,  [5]0,   [5]0,   [CAT]QUICK
.BYTE   'MOVQ$'
.BYTE   H'5C,H'00

.FIELD  [3]5,   [2]2,   [2]1,   [5]7,   [5]11,  [5]0,   [5]0,   [CAT]QUICK
.BYTE   'CMPQ$'
.BYTE   H'1C,H'00

.FIELD  [3]5,   [2]2,   [2]1,   [5]7,   [5]11,  [5]0,   [5]0,   [CAT]QUICK
.BYTE   'ADDQ$'
.BYTE   H'0C,H'00

.FIELD  [3]4,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'MEI$'
.BYTE   H'CE,H'24,H'00

.FIELD  [3]4,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'DEI$'
.BYTE   H'CE,H'2C,H'00

.FIELD  [3]4,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'NOT$'
.BYTE   H'4E,H'24,H'00

.FIELD  [3]4,   [2]2,   [2]1,   [5]11,  [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'SEQ$'
.BYTE   H'3C,H'00

.FIELD  [3]4,   [2]2,   [2]1,   [5]11,  [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'SNE$'
.BYTE   H'BC,H'00

.FIELD  [3]4,   [2]2,   [2]1,   [5]11,  [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'SCS$'
.BYTE   H'3C,H'01

.FIELD  [3]4,   [2]2,   [2]1,   [5]11,  [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'SCC$'
.BYTE   H'BC,H'01

.FIELD  [3]4,   [2]2,   [2]1,   [5]11,  [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'SHI$'
.BYTE   H'3C,H'02

.FIELD  [3]4,   [2]2,   [2]1,   [5]11,  [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'SLS$'
.BYTE   H'BC,H'02

.FIELD  [3]4,   [2]2,   [2]1,   [5]11,  [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'SGT$'
.BYTE   H'3C,H'03

.FIELD  [3]4,   [2]2,   [2]1,   [5]11,  [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'SLE$'
.BYTE   H'BC,H'03

.FIELD  [3]4,   [2]2,   [2]1,   [5]11,  [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'SFS$'
.BYTE   H'3C,H'04

.FIELD  [3]4,   [2]2,   [2]1,   [5]11,  [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'SFC$'
.BYTE   H'BC,H'04

.FIELD  [3]4,   [2]2,   [2]1,   [5]11,  [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'SLO$'
.BYTE   H'3C,H'05

.FIELD  [3]4,   [2]2,   [2]1,   [5]11,  [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'SHS$'
.BYTE   H'BC,H'05

.FIELD  [3]4,   [2]2,   [2]1,   [5]11,  [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'SLT$'
.BYTE   H'3C,H'06

.FIELD  [3]4,   [2]2,   [2]1,   [5]11,  [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'SGE$'
.BYTE   H'BC,H'06

.FIELD  [3]5,   [2]2,   [2]1,   [5]11,  [5]6,   [5]0,   [5]0,   [CAT]0
.BYTE   'TBIT$'
.BYTE   H'34,H'00

.FIELD  [3]5,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'SBIT$'
.BYTE   H'4E,H'18,H'00

;.FIELD [3]6,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
;.BYTE  'SBITI$'        NOT A MULTI PROCESSOR DEMO
;.BYTE  H'4E,H'1C,H'00

.FIELD  [3]5,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'CBIT$'
.BYTE   H'4E,H'08,H'00

;.FIELD [3]6,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
;.BYTE  'CBITI$'        NOT A MULTI PROCESSOR DEMO
;.BYTE  H'4E,H'0C,H'00

.FIELD  [3]5,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'IBIT$'
.BYTE   H'4E,H'38,H'00

.FIELD  [3]4,   [2]3,   [2]0,   [5]11,  [5]19,  [5]14,  [5]0,   [CAT]LNG_I
.BYTE   'CVTP'
.BYTE   H'6E,H'03,H'00

.FIELD  [3]4,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'FFS$'
.BYTE   H'6E,H'04,H'00

.FIELD  [3]4,   [2]3,   [2]2,   [5]11,  [5]19,  [5]14,  [5]24,  [CAT]LNG_I
.BYTE   'EXT$'
.BYTE   H'2E,H'00,H'00

.FIELD  [3]5,   [2]3,   [2]2,   [5]19,  [5]14,  [5]24,  [5]0,   [CAT]SHR_I
.BYTE   'EXTS$'
.BYTE   H'CE,H'0C,H'00

.FIELD  [3]4,   [2]3,   [2]2,   [5]11,  [5]19,  [5]14,  [5]24,  [CAT]LNG_I
.BYTE   'INS$'
.BYTE   H'AE,H'00,H'00

.FIELD  [3]5,   [2]3,   [2]2,   [5]19,  [5]14,  [5]24,  [5]0,   [CAT]SHR_I
.BYTE   'INSS$'
.BYTE   H'CE,H'08,H'00

.FIELD  [3]5,   [2]3,   [2]2,   [5]15,  [5]0,   [5]0,   [5]0,   [CAT]STRNG
.BYTE   'CMPS$'
.BYTE   H'0E,H'04,H'00

.FIELD  [3]5,   [2]3,   [2]2,   [5]15,  [5]0,   [5]0,   [5]0,   [CAT]STRNG
.BYTE   'CMPST'
.BYTE   H'0E,H'84,H'00

.FIELD  [3]5,   [2]3,   [2]2,   [5]15,  [5]0,   [5]0,   [5]0,   [CAT]STRNG
.BYTE   'MOVS$'
.BYTE   H'0E,H'00,H'00

.FIELD  [3]5,   [2]3,   [2]2,   [5]15,  [5]0,   [5]0,   [5]0,   [CAT]STRNG
.BYTE   'MOVST'
.BYTE   H'0E,H'80,H'00

.FIELD  [3]5,   [2]3,   [2]2,   [5]15,  [5]0,   [5]0,   [5]0,   [CAT]STRNG
.BYTE   'SKPS$'
.BYTE   H'0E,H'0C,H'00

.FIELD  [3]5,   [2]3,   [2]2,   [5]15,  [5]0,   [5]0,   [5]0,   [CAT]STRNG
.BYTE   'SKPST'
.BYTE   H'0E,H'8C,H'00

.FIELD  [3]5,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'ADDP$'
.BYTE   H'4E,H'3C,H'00

.FIELD  [3]5,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'SUBP$'
.BYTE   H'4E,H'2C,H'00

.FIELD  [3]6,   [2]3,   [2]2,   [5]11,  [5]19,  [5]14,  [5]0,   [CAT]ARAY_I
.BYTE   'CHECK$'                                                        
.BYTE   H'EE,H'00,H'00

.FIELD  [3]6,   [2]3,   [2]2,   [5]11,  [5]19,  [5]14,  [5]0,   [CAT]ARAY_I
.BYTE   'INDEX$'
.BYTE   H'2E,H'04,H'00

.FIELD  [3]5,   [2]3,   [2]2,   [5]19,  [5]14,  [5]24,  [5]0,   [CAT]OP3_DISP
.BYTE   'CMPM$'
.BYTE   H'CE,H'04,H'00

.FIELD  [3]5,   [2]3,   [2]2,   [5]19,  [5]14,  [5]24,  [5]0,   [CAT]OP3_DISP
.BYTE   'MOVM$'
.BYTE   H'CE,H'00,H'00

.FIELD  [3]4,   [2]2,   [2]0,   [5]11,  [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'JUMP'
.BYTE   H'7F,H'02

.FIELD  [3]3,   [2]1,   [2]0,   [5]8,   [5]0,   [5]0,   [5]0,   [CAT]OP1_DISP
.BYTE   'BEQ'
.BYTE   H'0A

.FIELD  [3]3,   [2]1,   [2]0,   [5]8,   [5]0,   [5]0,   [5]0,   [CAT]OP1_DISP
.BYTE   'BNE'
.BYTE   H'1A

.FIELD  [3]3,   [2]1,   [2]0,   [5]8,   [5]0,   [5]0,   [5]0,   [CAT]OP1_DISP
.BYTE   'BCS'
.BYTE   H'2A

.FIELD  [3]3,   [2]1,   [2]0,   [5]8,   [5]0,   [5]0,   [5]0,   [CAT]OP1_DISP
.BYTE   'BCC'
.BYTE   H'3A

.FIELD  [3]3,   [2]1,   [2]0,   [5]8,   [5]0,   [5]0,   [5]0,   [CAT]OP1_DISP
.BYTE   'BHI'
.BYTE   H'4A

.FIELD  [3]3,   [2]1,   [2]0,   [5]8,   [5]0,   [5]0,   [5]0,   [CAT]OP1_DISP
.BYTE   'BLS'
.BYTE   H'5A

.FIELD  [3]3,   [2]1,   [2]0,   [5]8,   [5]0,   [5]0,   [5]0,   [CAT]OP1_DISP
.BYTE   'BGT'
.BYTE   H'6A

.FIELD  [3]3,   [2]1,   [2]0,   [5]8,   [5]0,   [5]0,   [5]0,   [CAT]OP1_DISP
.BYTE   'BLE'
.BYTE   H'7A

.FIELD  [3]3,   [2]1,   [2]0,   [5]8,   [5]0,   [5]0,   [5]0,   [CAT]OP1_DISP
.BYTE   'BFS'
.BYTE   H'8A

.FIELD  [3]3,   [2]1,   [2]0,   [5]8,   [5]0,   [5]0,   [5]0,   [CAT]OP1_DISP
.BYTE   'BFC'
.BYTE   H'9A

.FIELD  [3]3,   [2]1,   [2]0,   [5]8,   [5]0,   [5]0,   [5]0,   [CAT]OP1_DISP
.BYTE   'BLO'
.BYTE   H'AA

.FIELD  [3]3,   [2]1,   [2]0,   [5]8,   [5]0,   [5]0,   [5]0,   [CAT]OP1_DISP
.BYTE   'BHS'
.BYTE   H'BA

.FIELD  [3]3,   [2]1,   [2]0,   [5]8,   [5]0,   [5]0,   [5]0,   [CAT]OP1_DISP
.BYTE   'BLT'
.BYTE   H'CA

.FIELD  [3]3,   [2]1,   [2]0,   [5]8,   [5]0,   [5]0,   [5]0,   [CAT]OP1_DISP
.BYTE   'BGE'
.BYTE   H'DA

.FIELD  [3]2,   [2]1,   [2]0,   [5]8,   [5]0,   [5]0,   [5]0,   [CAT]OP1_DISP
.BYTE   'BR'
.BYTE   H'EA

.FIELD  [3]5,   [2]2,   [2]1,   [5]11,  [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'CASE$'
.BYTE   H'7C,H'07

.FIELD  [3]4,   [2]2,   [2]1,   [5]7,   [5]11,  [5]16,  [5]0,   [CAT]ACB_INS
.BYTE   'ACB$'
.BYTE   H'4C,H'00

.FIELD  [3]3,   [2]2,   [2]0,   [5]11,  [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'JSR'
.BYTE   H'7F,H'06

.FIELD  [3]3,   [2]1,   [2]0,   [5]8,   [5]0,   [5]0,   [5]0,   [CAT]OP1_DISP
.BYTE   'BSR'
.BYTE   H'02

.FIELD  [3]3,   [2]1,   [2]0,   [5]8,   [5]0,   [5]0,   [5]0,   [CAT]OP1_DISP
.BYTE   'RET'
.BYTE   H'12

.FIELD  [3]3,   [2]1,   [2]0,   [5]8,   [5]0,   [5]0,   [5]0,   [CAT]OP1_DISP
.BYTE   'CXP'
.BYTE   H'22

.FIELD  [3]4,   [2]2,   [2]0,   [5]11,  [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'CXPD'
.BYTE   H'7F,H'00

.FIELD  [3]3,   [2]1,   [2]0,   [5]8,   [5]0,   [5]0,   [5]0,   [CAT]OP1_DISP
.BYTE   'RXP'
.BYTE   H'32

.FIELD  [3]4,   [2]1,   [2]0,   [5]8,   [5]0,   [5]0,   [5]0,   [CAT]OP1_DISP
.BYTE   'RETT'
.BYTE   H'42

.FIELD  [3]4,   [2]1,   [2]0,   [5]0,   [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'RETI'
.BYTE   H'52

.FIELD  [3]6,   [2]2,   [2]1,   [5]11,  [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'ADJSP$'
.BYTE   H'7C,H'05

.FIELD  [3]7,   [2]2,   [2]1,   [5]11,  [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'BICPSR$'
.BYTE   H'7C,H'01

.FIELD  [3]7,   [2]2,   [2]1,   [5]11,  [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'BISPSR$'
.BYTE   H'7C,H'03

.FIELD  [3]4,   [2]2,   [2]0,   [5]8,   [5]0,   [5]0,   [5]0,   [CAT]REGLIST
.BYTE   'SAVE'
.BYTE   H'62,H'00

.FIELD  [3]7,   [2]2,   [2]0,   [5]8,   [5]0,   [5]0,   [5]0,   [CAT]REGLIST
.BYTE   'RESTORE'
.BYTE   H'72,H'00

.FIELD  [3]5,   [2]2,   [2]0,   [5]8,   [5]16,  [5]0,   [5]0,   [CAT]ENT_I
.BYTE   'ENTER'
.BYTE   H'82,H'00

.FIELD  [3]4,   [2]2,   [2]0,   [5]8,   [5]0,   [5]0,   [5]0,   [CAT]REGLIST
.BYTE   'EXIT'
.BYTE   H'92,H'00

.FIELD  [3]4,   [2]2,   [2]1,   [5]7,   [5]11,  [5]0,   [5]0,   [CAT]SPC_REG
.BYTE   'LPR$'
.BYTE   H'6C,H'00

.FIELD  [3]4,   [2]2,   [2]1,   [5]7,   [5]11,  [5]0,   [5]0,   [CAT]SPC_REG
.BYTE   'SPR$'
.BYTE   H'2C,H'00

.FIELD  [3]6,   [2]3,   [2]0,   [5]15,  [5]0,   [5]0,   [5]0,   [CAT]SPC_REG
.BYTE   'SETCFG'
.BYTE   H'0E,H'88,H'00

.FIELD  [3]3,   [2]1,   [2]0,   [5]0,   [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'BPT'
.BYTE   H'F2

.FIELD  [3]4,   [2]1,   [2]0,   [5]0,   [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'FLAG'
.BYTE   H'D2

.FIELD  [3]3,   [2]1,   [2]0,   [5]0,   [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'SVC'
.BYTE   H'E2

.FIELD  [3]3,   [2]1,   [2]0,   [5]0,   [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'NOP'
.BYTE   H'A2

.FIELD  [3]4,   [2]1,   [2]0,   [5]0,   [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'WAIT'
.BYTE   H'B2

.FIELD  [3]3,   [2]3,   [2]0,   [5]15,  [5]19,  [5]0,   [5]0,   [CAT]SPC_REG
.BYTE   'LMR'
.BYTE   H'1E,H'0B,H'00

.FIELD  [3]3,   [2]3,   [2]0,   [5]15,  [5]19,  [5]0,   [5]0,   [CAT]SPC_REG
.BYTE   'SMR'
.BYTE   H'1E,H'0F,H'00

.FIELD  [3]5,   [2]3,   [2]0,   [5]19,  [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'RDVAL'
.BYTE   H'1E,H'03,H'00

.FIELD  [3]5,   [2]3,   [2]0,   [5]19,  [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'WRVAL'
.BYTE   H'1E,H'07,H'00

.FIELD  [3]6,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'MOVSU$'
.BYTE   H'AE,H'0C,H'00

.FIELD  [3]6,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'MOVUS$'
.BYTE   H'AE,H'1C,H'00
          
.FIELD  [3]4,   [2]3,   [2]0,   [5]19,  [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'LFSR'
.BYTE   H'3E,H'0F,H'00
          
.FIELD  [3]4,   [2]3,   [2]0,   [5]14,  [5]0,   [5]0,   [5]0,   [CAT]0
.BYTE   'SFSR'
.BYTE   H'3E,H'37,H'00
          
.FIELD  [3]5,   [2]3,   [2]0,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'MOVLF'
.BYTE   H'3E,H'16,H'00
          
.FIELD  [3]5,   [2]3,   [2]0,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'MOVFL'
.BYTE   H'3E,H'1B,H'00
          
.FIELD  [3]7,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'ROUND#$'
.BYTE   H'3E,H'20,H'00
          
.FIELD  [3]7,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'TRUNC#$'
.BYTE   H'3E,H'28,H'00

.FIELD  [3]7,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'FLOOR#$'
.BYTE   H'3E,H'38,H'00
          
.FIELD  [3]5,   [2]3,   [2]2,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'MOV$#'
.BYTE   H'3E,H'00,H'00
          
.FIELD  [3]4,   [2]3,   [2]0,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'ADD!'
.BYTE   H'BE,H'00,H'00
          
.FIELD  [3]4,   [2]3,   [2]0,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'SUB!'
.BYTE   H'BE,H'10,H'00
          
.FIELD  [3]4,   [2]3,   [2]0,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'MUL!'
.BYTE   H'BE,H'30,H'00
          
.FIELD  [3]4,   [2]3,   [2]0,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'DIV!'
.BYTE   H'BE,H'20,H'00
          
.FIELD  [3]4,   [2]3,   [2]0,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'MOV!'
.BYTE   H'BE,H'04,H'00
          
.FIELD  [3]4,   [2]3,   [2]0,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'NEG!'
.BYTE   H'BE,H'14,H'00
          
.FIELD  [3]4,   [2]3,   [2]0,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'ABS!'
.BYTE   H'BE,H'34,H'00
          
.FIELD  [3]4,   [2]3,   [2]0,   [5]19,  [5]14,  [5]0,   [5]0,   [CAT]0
.BYTE   'CMP!'
.BYTE   H'BE,H'08,H'00    

.LIST

;       SUBROUTINE      SYM_SRCH
;R0=START OF SYMBOL
;RESULT IS RETURNED IN SYM_TAB AND BOOLEAN IN S_FOUND
SYM_SRCH:
        SAVE    [R6,R7]                 ;SAVE TWO USED REGS
        MOVQB   FALSE, S_FOUND          ;ASSUME NOT THERE
        MOVD    SYM_TAB, R6             ;START OF SYMBOLS
        MOVW    1000, R7                ;LOOP SAFETY VALUE
SYM_SR: CMPQD   -1, -3(R6)              ;IF END OF TABLE THEN NOT FOUND
        BEQ     NOT_FND:B
        CMPW    0(R1), -7(R6)           ;ELSE CHECK SYMBOL NAME 
        BEQ     FND_SYM:B               ;IF EQUAL THEN FOUND
        ADDQD   -8, R6                  ;ELSE INDEX TO NEXT ENTRY
        ACBW    -1, R7, SYM_SR          ;IF STILL SANE TRY AGAIN
        BR      NOT_FND:B               ;ELSE NOT FOUND
FND_SYM:MOVQB   TRUE, S_FOUND           ;SET FOUND FLAG AND GET VALUE
        MOVD    -3(R6), SYM_VAL
        MOVB    -4(R6), SYM_TYPE        ;IDENTIFY TYPE OF SYMBOL
        CBITD   31, SYM_VAL             ;CLEAR SB BASE FLAG BIT
NOT_FND:RESTORE [R6,R7]
        RET     0

;
;       SUBROUTINE      MOV(E) (TO) (NEX)T
;
; R1=START OF CURRENT OPERAND   INPUT: ADDR
; R3=END OF CURRENT OPERAND     OUTPUT: ADDR
; R4=START OF NEXT OPERAND      OUTPUT: ADDR
;
MOVTONXT:
        MOVD    R1,R3           ;INIT START TO END
        MOVD    R3,R4
ONEOVER:
        CMPB    1(R3),"("       ;IF NEXT CHAR = (
                                ;THEN DISP2 IS POSSIBLE
        BEQ     DONEF:B         ;SET R4 TO NEXT AND EXIT
        CMPB    1(R3),","       ;ELSE IF NEXT CHAR = ,
        BEQ     DONE:B          ;THEN DONE
        CMPB    1(R3)," "       ;SPACES SIGNAL ENDLIN
        BEQ     DONE:B          ;FOR PACKED STRUCTURE OF PARSE DATA
        CMPB    REGLIST, CAT    ;SKIP THIS IF OP IS 
        BEQ     NO_BRA:B        ;REGLIS
        CMPB    1(R3),"["       ;ELSE IF NEXT CHAR = [
        BEQ     DONE:B          ;THEN DONE
NO_BRA: CMPB    1(R3),")"       ;ELSE IF NEXT CHAR = )
        BEQ     DONEX:B         ;THEN DISP2 FOR EXT ADDR MODE
        CMPD    R3,ENDLIN       ;IF EOL = TRUE THEN DONE
        BGE     DONE:B          ;ELSE UPDATWE POINTERS AND LOOP 
        ADDQD   1,R3
        MOVD    R3,R4
        BR ONEOVER

DONEX:  ADDQD   1,R4            ;OFFSET FOR EXT ADDR MODE PARSE

DONEF:
DONE:   ADDQD   2,R4            ;OFFSET TO NORMAL NEXT DISPLACEMENT
        RET     0


;       SUBROUTINE VALU  --GET A VALUE
;
; R1=START OF VALU IN INPUYT STRING     INPUT: ADDR
; R3=END OF VALUE INPUT(FROM MOVTONXT)  INPUT: ADDR
; R5=THE VALUE OUTPUT:  DOUBLE INTEGER
;
VALU:
        BSR     MOVTONXT        ;GET END OF DATA STRING
        CMPB    '"', 0(R1)      ;CHECK FOR ASCII STRING
        BNE     AN:B
        MOVQD   0, R5           ;ASCCII VALUE PADDE WITH 0
        MOVD    R1, R3          ;DO FOR AT MOST 4 CHARS
        ADDQD   6, R3
PUSH_A: MOVB    0(R1), TOS
        ADDQD   1, R1           ;PUSH ASCII CHAR ONTO STACK TO
        CMPB    '"', 0(R1)      ;ACCOMPLISH IMAGE
        BEQ     ASCIT:B         ;REVERSAL
        CMPD    R1, R3          ;DO A SANITY CHECK
        BGE     ASCIT:B
        BR      PUSH_A
ASCIT:  MOVB    TOS, R3         ;POP CHARS UNTIL STATING CHAR IS FOUND
        CMPB    '"', R3         ;THEN DONE
        BEQ     NOT_PB:B        ;ELSE SHIFT AND OR
        LSHD    8, R5           ;MOST SIG CHAR BECOMES LEAST SIG CHAR FOR
        ORB     R3, R5          ;CORRECT VALUE INTERPERTATION
        BR      ASCIT   
AN:     MOVD    R1,TOS          ;VECIN
        MOVD    R3,TOS          ;EOD

        BSR     A_NUM
        MOVD    TOS,R5          ;GET THE VALUE
        CMPQD   FALSE, ERROR     ; CHECK FOR VALUE ERROR
        BEQ     VAL_OK:B        ;OK FOR NO ERROR
        MOVD    ERROR,A_ERROR   ;ELSE SET FLAG AND ERROR TYPE
        MOVQB   TRUE, ERR_FLG
VAL_OK: CMPQB   TRUE, PC_REL    ;CHECK FOR PC REL TYPE
        BNE     NOT_PB:B        ;IF NOT PC REL THEN DON'T
        SUBD    PC_ADDR, R5     ;CALCULATE OFFSET DISPLACEMENT
        ADDD    PROG_BASE, R5   ;DISP=PROG_BASE-PC_ADDR+XX(PC)
NOT_PB: MOVQB   FALSE, PC_REL
        RET     0


;       SUBROUTINE MOVE A BYTE
;
;THIS ROUTINE MOVES A BYTE OF R5 TO THE APPROPRIATE
;DISPLACEMENT TABLE AREA AS POINTED TO BY R3
;FORMATS DISP AND IMMD VALUES TO CORRECT SEQUENCE
;
; R3=VEC TO DISPLACEMENT TABLE    INPUT: ADDR
; R7=VEC TO LENGTH TABLE   INPUT: ADDR

MOVABYT:
        ADDQB   1,0(R7)         ;UPDATE LENGTH
        LSHD    8,0(R3)         ;SHIFT UP ALL DISPLCEMENT BYTES
        MOVB    R5,0(R3)        ;FILL VACANT BYTE WITH R5 BYTE
        LSHD    -8,R5           ;OUTSHIFT THAT BYTE AND POSITION NEXT
        RET     0



;       SUBROUTINE  (DISPN)PLACEMENT
;
;MOVES A DISPLACEMENT TO CORRECT TABLE AREA
; R6=INDEX TO DISPLACEMENT/LENGTH TABLE INPUT: INTEGER 0..3
; R5=THE DISPLACEMENT   INPTU: INTEGER
; R3=VEC TO DISPLACEMENT TABLE OUTPUT: ADDR
; R7=VEC TO LENGTH TAVLE OUTPTU: ADDR
;

                                                            
DISP1:      ADDR        DISP1X[R6:D],R3         ;ADDRESS OF CURRENT OPERAND
                                                ;DISP1 TABLE ENTRY
            ADDR        LEN1[R6:B],R7           ;ADDR OF LENGTH
            BR          DISPIT:B

DISP2:      ADDR        DISP2X[R6:D],R3         ;DISP2 TABLE ENTRY

            ADDR        LEN2[R6:B],R7

DISPIT:     CMPB        TRUE,DISPLACE           ;IF NOT A DISPLACEMENT
            BEQ         DISPLCR:B               ;THEN SET TO IMMO VALUE
            CMPQB       TRUE,IMM_IS_BYT         ;ACCORDING TO I TYPE
            BEQ         MOVBYT:W        
            CMPQB       DOUBLNG,ITYPE           ;IF ITYPE=DOUBLE
            BEQ         MOVDOUB:W               ;    THEN MOVE DOUBLE
            CMPQB       WRDLONG,ITYPE           ;ELSE IF ITYPE=WORD
            BEQ         MOVWRD:W                ;    THEN MOVE WORD
            BR          MOVBYT:W                ;ELSE MOVE BYTE

DISPLCR:    CMPD        R5,0                    ;IF POSITIVE THEN
            BGE         POSDISP:B               ;FORMAT POSITIVE DISPLACEMENT
            CMPQB       TRUE, DISP_B            ;CHECK FOR LRNGTH
            BEQ         N_BYT:B                 ;DIRECTIVE FROM SYMBOLS 
            CMPQB       TRUE, DISP_W            ;OPERATION
            BEQ         NEGWRD:B
            CMPQB       TRUE, DISP_D
            BEQ         MOVDOUB:W
                                                ;ELSE DO NEG
            CMPD        R5,-8192                ;IF L-8192 THEN
            BLT         MOVDOUB:W               ;    MOVE DOUBLE

            CMPD        R5,-64                  ;ELSE IF LESS THAN -64
            BLT         NEGWRD:B                ;MOVE WORD
N_BYT:      ANDB        H'7F,R5                 ;ELSE MOVE BYTE
            BR          MOVBYT:W

NEGWRD:     ANDW        H'BFFF,R5
            BR          MOVWRD:B                
                
POSDISP:    CMPQB       TRUE, DISP_B            ;CHECK FOR LENGTH DIRECTIVE
            BEQ         MOVBYT:B
            CMPQB       TRUE, DISP_W
            BEQ         POSWRD:B
            CMPQB       TRUE, DISP_D
            BEQ         POS_D:B
            CMPD        R5,63                   ;CHECK FOR RANGE
            BLE         MOVBYT:B                ;AND FORMAT LENGTH
            CMPD        R5,8191                 ;TELLING BITS
            BLE         POSWRD:B                ;ACCORDINGLY
POS_D:      ORD         H'C0000000,R5           ;DOUBLE FORMAT
            BR          MOVDOUB:B

POSWRD:     ORW         H'8000,R5               ;WORD FORMAT
            BR          MOVWRD:B

MOVDOUB:    BSR         MOVABYT                 ;MOVE 4 BYTES
            BSR         MOVABYT
MOVWRD:     BSR         MOVABYT                 ;MOVE 2 BYTES           
MOVBYT:     BSR         MOVABYT                 ;MOVE 1 BYTE
            MOVQD       FALSE, DISP_FLGS        ;CLEAR LENGTH DIRECTIVES
            RET 0


;
;               ADDRESSING MODE TABLE
;

MODTABX:    .BYTE       'R0  ','R1  '           ;REGISTER
            .BYTE       'R2  ','R3  '
            .BYTE       'R4  ','R5  '
            .BYTE       'R6  ','R7  '
            .BYTE       '(R0)','(R1)'           ;REGISTER RELATIVE
            .BYTE       '(R2)','(R3)'   
            .BYTE       '(R4)','(R5)'
            .BYTE       '(R6)','(R7)'
            .BYTE       'FP))'                  ;MEMORY RELATIVE REGISTER
            .BYTE       'SP))'
            .BYTE       'SB))'
IMMX:       .BYTE       '    '                  ;IMMEDIATE
ABSX:       .BYTE       '@   '                  ;ABSOLUTE
EXTX:       .BYTE       'EXT('                  ;EXTERNAL
TOSX:       .BYTE       'TOS '                  ;TOP OF STACK
            .BYTE       '(FP)'                  ;MEMORY REGISTER
            .BYTE       '(SP)'
SBX:        .BYTE       '(SB)'
PCX:        .BYTE       '(PC)'

NUMADM:     .EQU        ($ - MODTABX) /4
IMMINX:     .EQU        (IMMX - MODTABX) /4
ABSINX:     .EQU        (ABSX - MODTABX) /4
EXTINX:         .equ    (EXTX - MODTABX) /4
TOSINX:         .equ    (TOSX - MODTABX) /4
SBINX:          .EQU    (SBX - MODTABX) /4
PCINX:          .EQU    (PCX - MODTABX) /4
;ADDRESSING MODE CODING TABLE
                        
MODCODE:    .BYTE       H'0     ;R0
            .BYTE       H'1     ;R1
            .BYTE       H'2     ;R2
            .BYTE       H'3     ;R3
            .BYTE       H'4     ;R4
            .BYTE       H'5     ;R5
            .BYTE       H'6     ;R6
            .BYTE       H'7     ;R7
            .BYTE       H'8     ;(R0)
            .BYTE       H'9     ;(R1)
            .BYTE       H'A     ;(R2)
            .BYTE       H'B     ;(R3)
            .BYTE       H'C     ;(R4)
            .BYTE       H'D     ;(R5)
            .BYTE       H'E     ;(R6)
            .BYTE       H'F     ;(R7)
            .BYTE       H'10    ;(FP))
            .BYTE       H'11    ;(SP))
            .BYTE       H'12    ;(SB))
            .BYTE       H'14    ;IMMED
            .BYTE       H'15    ;@
            .BYTE       H'16    ;EXT
            .BYTE       H'17    ;TOS
            .BYTE       H'18    ;(FP)
            .BYTE       H'19    ;(SP)
            .BYTE       H'1A    ;(SB)
            .BYTE       H'1B    ;(PC)
INX:        .BYTE       H'1C    ;INXB
            .BYTE       H'1D    ;INXW
            .BYTE       H'1E    ;INXD
            .BYTE       H'1F    ;INXQ

INXB:       .EQU    (INX-MODCODE)

;       SUBTOUTINE SYMBOL
;THIS ROUTINE SERCHES THE SYBOL TABLE IN AN APPROPRIATE MANNER
;DEPENDING ON THE PASS. IT FIRST DETERMINS IF THE OPERAND IS A SYMBOL
;AND SETS A FLAG IF THAT TRUES, ELSE IT SIMPLY IS IGNORED
;INPUT IS R1 VECTOR TO OPERAND OUTPUT IS YES_SYM, SYM_VAL AND OR ERROR
SYMBOL:     MOVQB       FALSE, YES_SYM          ;ASSUME NOT A SYMBOL       
            CMPB        '+', 0(R1)              ;IF SIGNED NUMBER THEN
            BEQ         NOSYM:W                 ;THEN NOT A SYMBOL
            CMPB        '-', 0(R1)              ;CHECK FOR BOTH
            BEQ         NOSYM:W                 ;+ AND - SIGN
            CMPW        H'2748, 0(R1)           ;SYMBOLS FALL THRU PARSE
            BEQ         NOSYM:W                 ;AS AN IMMED OR DISP. HERE
            CMPW        H'2744, 0(R1)           ;IS CHECK FOR H' OR D' NUMBER
            BEQ         NOSYM:W                 ;PREFFIX. THEN CHECK IF VALUE
                                                ;STARTS WITH 0-9 IF TRUE THEN
                                                ;ITSA NUMBER ELSE ITS IS
            CMPB        '9', 0(R1)              ;TREATED AS A SYMBOL
            BGE         NOSYM:W
ASYM:       MOVQB       TRUE, YES_SYM           ;YES A SYMBOL
            MOVB        PCINX, R2               ;SET ADDR MODE TO PC
            BSR         SYM_SRCH                ;SEE IF SYMBOL IS IN TABLE
            CMPQB       FALSE, S_FOUND          ;IF NOT FOUND TRY PC ROUTINE
            BEQ         TRY_PCRT:W      
            CMPQB       PC_SYM, SYM_TYPE        ;IF PC SYMBOL THEN DO 
            BEQ         TRY_PCRT:W              ;PC ROUTINE
            MOVB        SBINX, R2               ;SET SB ADDR MODE
            MOVQD       FALSE, DISP_FLGS        ;SEE IF SB VAL HAS LENGTH
            CMPW        H'423A, 2(R1)           ;LENGTH DIRECTIVE
            BNE         OPT_W3:B    
            MOVQB       TRUE, DISP_B            ;CHECK FOR WRDLONG 
OPT_W3:     CMPW        H'573A, 2(R1)           ;(USED HEX FOR ASCII ASS PROB)
            BNE         N_OPT:B                 ;DEFAULT IS DOUBLE
            MOVQB       TRUE, DISP_W
N_OPT:      MOVD        SYM_VAL, R5             ;PASS VALUE
            BR          DISP__IT:W              ;DONE SB        
TRY_PCRT:   CMPQB       PASS1, PASS_NUM         ;DETERMINE WHICH PASS
            BEQ         DISP_ADD:W              ;PASS1 ROUTINE         
            CMPQB       TRUE, S_FOUND           ;PASS2 ACTION IF SYMBOL NOT 
            BEQ         GET_LT:W                ;THEN SET ERR_FLG FOR UND
            MOVQB       TRUE, ERR_FLG           ;SYMBOL AND ABORT THIS LINE
            ADDR        SYM_ERR3, A_ERROR       ;UND_SYM ERROR
            BR          NOSYM:W 
GET_LT:     CMPD        SYM_VAL, PC_ADDR        ;IF SYM_VAL > PC_ADDR THEN
            BLE         PUT_IT:B                 ;THEN BACKWARD REF SYM
            MOVQD       FALSE, DISP_FLGS        ;DISPLACEMNTS FLAGS FALSE
            CMPW        H'423A, 2(R1)           ;BYTE LONG OPTIMAZATION OPTION
            BNE         OPT_W2:B    
            MOVQB       TRUE, DISP_B            ;CHECK FOR WRDLONG 
OPT_W2:     CMPW        H'573A, 2(R1)           ;(USED HEX FOR ASCII ASS PROB)
            BNE         OPT_D2:B                ;DEFAULT IS DOUBLE
            MOVQB       TRUE, DISP_W
OPT_D2:                                         ;IF VALUE IS PRESENT THEN PUTIT
            CMPQD       FALSE, DISP_FLGS
            BNE         PUT_IT:B    
            MOVQB       TRUE, DISP_D
PUT_IT:     MOVD        SYM_VAL, R5             ;CALCULATE DISPLACMENT
            SUBD        PC_ADDR, R5
            BR          DISP__IT:B
DISP_ADD:   MOVQD       FALSE, DISP_FLGS        ;PASS1 ACTION
            CMPQB       TRUE, S_FOUND           ;IF SYMBOL IS BACKWARD REF THEN
            BEQ         PUT_IT                  ;YOU HAVE VALU ELSE CHECK FOR
            CMPW        H'423A, 2(R1)           ;BYTE LONG OPTIMAZATION OPTION
            BNE         OPT_W:B    
            MOVQB       TRUE, DISP_B            ;CHECK FOR WRDLONG 
OPT_W:      CMPW        H'573A, 2(R1)           ;(USED HEX FOR ASCII ASS PROB)
            BNE         OPT_D:B                 ;DEFAULT IS DOUBLE
            MOVQB       TRUE, DISP_W
OPT_D:                                          ;IF VALUE IS PRESENT THEN PUTIT
            MOVQD       0, R5
            CMPQD       FALSE, DISP_FLGS
            BNE         DISP__IT:B
            MOVQB       TRUE, DISP_D

                                 
NOSYM:
DISP__IT:   RET         0                       


;SUBROUTINE OPERATE     
;PARCES AND ENCODES WITHIN BASIC CODE THE ADDRESSINENCE TO CODE TABLE
;R1=VEC TO START OF CURRENT OPERAND    INPUT:ADDR
;R6=TABLE INDEX     INPUT INT: 0..3
;R4=OFFSET TO CURRENT OPERAND FIELD    INPUT INT: 0..32
;R2 USED AS INDEX INTO MODE TABLES

OPERATE:    EXTB        R4,0(R0),OPFIELD,FLGTHO ;GET OPERAND START OFFSET
            CMPQB       FALSE,OPFIELD           ;IF ZERO YOU ARE DONE
            BEQ         FINISH:W
            MOVD        R1,OPSTRT               ;SAVE VEC IN TO OPERAND
            MOVQB       TRUE,DISPLACE           ;YES DO EXPECT A DISPLACEMENT 
            MOVQB       FALSE,IMM_IS_BYT        ;    (DEFAULT)

        CMPQB   0, R6           ;SEE IF THIS IS THE FIRST OPERAND
        BNE     OP2_CHK:B
        CMPB    QUICK, CATGORY  ;SEE IF OPERAND IS QUICK TYP
        BEQ     AQUICK:W
        CMPB    REGLIST, CATGORY        ; THIS SEQUENCE OF CODE CHECKS
        BEQ     ALIST1:W         ;TO SEE IS A CERTAIN CATEGORY OF OPERAND
        CMPB    STRNG, CATGORY  ;IS PRESENT INTHE PARSE LINE.
        BEQ     ASTRNG:W        ; IF IT IS THE PROGRAM FLOW
        CMPB    SPC_REG, CATGORY        ;IS ALTERED TO DO THAT SPECIAL
        BEQ     ASPC_REG:W      ;OPERATION.
        CMPB    SWIP, CATGORY   ;IF NONE OF THE CONDITIONS ARE TRUE A NORMAL
        BNE     OP2_CHK:B       ;ADDR MODE CHECK IS DONE
        MOVQB   TRUE, IMM_IS_BYT
OP2_CHK:
OP3_CHK:
        CMPQB   2, R6
        BNE     OP4_CHK:B
        CMPB    LNG_I, CATGORY
        BEQ     A_ADDR_MODE:B
        CMPB    SHR_I, CATGORY
        BEQ     SHR_FLD:W
        CMPB    ACB_I, CATGORY  ;IF QUICK AND OP3_DISP THEN DISP
        BEQ     A_ADDR_MODE:B   ;   ELSE A BLOCK INST
        BR      ABLOCK:W
OP4_CHK:
        CMPQB   3, R6
        BNE     A_ADDR_MODE:B
        CMPB    LNG_I, CATGORY
        BNE     A_ADDR_MODE:W
        MOVQB   TRUE, OP_IS_DISP
        MOVQB   TRUE, A_LONG_F
A_ADDR_MODE:
                CMPQB   TRUE, OP_IS_DISP
                BEQ     OPISDISP:W              ;SEQUENCE OF UNARY ID TYPES
                MOVZBD  PCINX+1, R2             ;CHECK FOR PROGRAM BASE
                CMPB    '*', 0(R1)              ;DISPLACEMENT
                BNE     ABS_CAS:B
                ADDQD   1, R1                   ;OFFSET TO THE VALUE
                BR      STAR_T:W                ;SKIP OPSTRT RESET
ABS_CAS:        movzbd  ABSINX+1,r2             ;CHECK FOR ABSOLUTE MODE
                cmpb    '@',0(r1)
                beq     CASMOD:w                ;CHECK FOR EXT( MODE
                movzbd  EXTINX+1,r2
                cmpmb   0(r1),EXTX,3
                beq     CASMOD:w                ;CHECK FOR TOS
                movzbd  TOSINX+1,r2
                cmpmb   0(r1),TOSX,3
                beq     CASMOD:w

                movzbd  8,r2                    ;CHECK FOR THE EIGHT REGS
NX_R:           cmpmb   0(r1),MODTABX -4[r2:d],2
                beq     CASMOD:b
                acbb    -1,r2,NX_R


nx_chr:                                         ;ELSE INIT MODE COUNTER
            MOVZBD      NUMADM ,R2              ;    TO MAX

modwalk:        cmpmb   0(r1),MODTABX -4[r2:d],4
                bne     NX_MOD:b                ;CHECK FOR FINAL PARSE OF
                cmpb    4(r1),')'               ;FRAME MEM RELATIVE
                beq     NX_MOD:b                ;TYPE
                CMPB    PCINX+1, R2             ;CHECK FOR PCREL TYPE
                BNE     CASMOD:B                ;IF TRUE THEN SET PCREL FLAG
                MOVQB   TRUE, PC_REL
                br      CASMOD:b
NX_MOD:         acbb    -1,r2,modwalk
                
            ADDQD       1,R1                    ;MOVE SEARCH FIELD OVER 1 CHAR
            CMPB        0(R1),','               ;CHECK IF END OF OPERAND FIELD
            BEQ         IMMSET:B                ;IF TRUE THEN IMMD MODE
            CMPD        R1,ENDLIN               ;IF EOL
            ble         nx_chr                  ;THEN IMMD MODE

IMMSET:     MOVZBD      IMMINX+1,R2

CASMOD:     MOVD        OPSTRT,R1                

STAR_T:     ADDQD       -1,R2                   

CASEM:           CASEW  BRTAB:B[R2:W]

BRTAB:      .WORD       REG0-CASEM
            .WORD       REG1-CASEM
            .WORD       REG2-CASEM
            .WORD       REG3-CASEM
            .WORD       REG4-CASEM
            .WORD       REG5-CASEM
            .WORD       REG6-CASEM
            .WORD       REG7-CASEM
            .WORD       REGREL0-CASEM
            .WORD       REGREL1-CASEM
            .WORD       REGREL2-CASEM
            .WORD       REGREL3-CASEM
            .WORD       REGREL4-CASEM
            .WORD       REGREL5-CASEM
            .WORD       REGREL6-CASEM
            .WORD       REGREL7-CASEM
            .WORD       FPMEM-CASEM
            .WORD       SPMEM-CASEM
            .WORD       SBMEM-CASEM
            .WORD       IMMED-CASEM
            .WORD       ABS-CASEM       
            .WORD       EXTMOD-CASEM
            .WORD       TOSMOD-CASEM
            .WORD       FPREL-CASEM
            .WORD       SPREL-CASEM
            .WORD       SBREL-CASEM
            .WORD       PCREL-CASEM
ABLOCK:
        BSR     VALU
        MOVQB   1, R1                   ;CHECK FOR BYT LONG
        CMPQB   BYTLONG, ITYPE
        BEQ     FIXIT:B
        MOVQB   2, R1                   ;ENCODE THIS VALUE
        CMPQB   WRDLONG, ITYPE          ; ENCODED VALUE :=
        BEQ     FIXIT:B                 ;    DISP*i -i
        MOVQB   4, R1
FIXIT:  MULB    R1, R5
        NEGB    R1, R1
        ADDB    R1, R5
        ANDB    H'F,R5
        MOVB    PCINX+1, R2
        BSR     DISP1
        BR      PARSEND:W

ALIST1:
        MOVQB   0, ADDRMODE     ;SET REG FIELD TO 0
LOOK:   CMPB    'R',0(R1)       ;DO SIMPLE CHECKS FOR
        BNE     NEXT_:B         ;REGISTERS
        MOVB    1(R1), R2
        SUBB    H'30, R2        ;SET THAT BIT NUM IN ADDRMODE
        CMPB    H'62, BASECODE  ;CHECK FOR SAVE INST
        BEQ     NOFLOP:B
        CMPQB   OP2_DISP, ADISP
        BEQ     NOFLOP:B        ;CHECK FOR ENTER INST
        ADDQB   -7, R2          ;ELSE FLOP REG ORDER AROUND
        ;ABSB   R2,R2           ; DSI-32 assembler won't allow this !!!
NOFLOP: SBITB   R2, ADDRMODE
NEXT_:  CMPB    ']', 0(R1)      ;STOP AT END OF LIST
        BEQ     DONREG:B
        ADDQD   1, R1
        CMPD    R1, ENDLIN      ;UNTIL ENDLIN
        BLT     LOOK
DONREG: MOVQD   -1, R2          ;NOT NORMAL ADDR MODE FLAG
        MOVQB   TRUE, INS_8BIT  ;
        BR PARSEND:W

ASPC_REG:
AQUICK:
        BSR     VALU
        MOVQD   -1, R2          ;NOT A NORMAL ADDR MODE
        MOVQB   TRUE, INS_4BIT
        MOVB    R5, ADDRMODE
        BR      PARSEND:W

ASTRNG:
        MOVD    OPSTRT, R1      ;START OF STRING INST
        MOVQB   0, ADDRMODE     ;START WITH ADDR MODE 0
        CMPB    'T', -2(R1)
        BNE     OTHER_OP:B
        SBITB   0, ADDRMODE
OTHER_OP:
        CMPB    'B', 0(R1)
        BNE     W_:B
        SBITB   1, ADDRMODE     ;SET THE B BIT OPTIN
W_:     CMPB    'W', 0(R1)
        BNE     U_:B            
        SBITB   2, ADDRMODE     ;SET THE W OPTION
U_:     CMPB    'U', 0(R1)      ;SET THE U OPTION
        BNE     NEX_O:B
        SBITB   2, ADDRMODE     ;U OPTION FIELD = 3
        SBITB   3, ADDRMODE                             
NEX_O:  ADDQD   1, R1
        CMPD    R1, ENDLIN
        BLE     OTHER_OP        
        MOVQD   -1, R2
        MOVQB   TRUE, INS_4BIT
        BR      PARSEND:W

SHR_FLD:
        BSR     VALU
        LSHB    5, R5           ;ADJUST THE OFFSET
        MOVB    R5, DISP1D      ;STORE IT AS FINAL DISP
        MOVD    R4, R1          ;POINTER TO OFFSET
        BSR     VALU            ;GET VALU
        ADDQD   -1, R5          ;DECREMENT LENGTH
        ORB     R5, DISP1D      ;MAKE ONE BYT
        MOVQB   1, LEN1D        ;FLAG THAT THERE IS A DISP
        BR      PARSEND:W

REG0:
REG1:
REG2:
REG3:
REG4:
REG5:
REG6:
REG7:
TOSMOD:
            BR          PARSEND:W               ;CODING
                                        ;GO FINISH PARSE



REGREL0:
REGREL1:
REGREL2:
REGREL3:
REGREL4:
REGREL5:
REGREL6:
REGREL7:
FPREL:
SPREL:
SBREL:
PCREL:
            BSR         VALU                    ;R1=OPSTRT
            BSR         DISP1                   ;GET VALU
                                                ;SHOVE TO DISP1
            BR          PARSEND:W               ;FINISH PARSE

FPMEM:
SPMEM:
SBMEM:
            BSR         VALU                    ;GET FIRST VALUE
            BSR         DISP2                   ;ITS DISP2
            MOVD        R4,R1                   ;POINT TO NEXT VALU
            BSR         VALU                    ;ITS DISP1
            BSR         DISP1                   
            BR          PARSEND:W               ;FINISH PARSE

EXTMOD:     ADDQD       4,R1                    ;MOVE VECIN TO START OF VALU
            BSR         VALU                    ;GET FIRST DISP
            BSR         DISP1                   ;STORE IT
            MOVD        R4,R1                   ;SET VEC TO NEXT DISPL
            BSR         VALU                    
            BSR         DISP2                   ;STORE IT
            BR          PARSEND:W               ;FINISH PARSE

IMMED:      BSR         SYMBOL
            CMPQB       FALSE, ERR_FLG          ;CHECK FOR SYMBOL ERROR
            BNE         FINISH:W                ;ALLDONE IF ERROR
            CMPQB       TRUE, YES_SYM           ;IF SYMBOL WAS FOUND
            BEQ         DISP___IT:B             ;THEN SET DISPLACEMENT
            BSR         VALU                    
            MOVQB       FALSE,DISPLACE          ;SET TO IMMEDVALUE
DISP___IT:  BSR         DISP1                   ;FORMAT
            BR          PARSEND:B

OPISDISP:   MOVB        PCINX, R2               ;SET TO PC ADDR MODE
            CMPB        '*', 0(R1)              ;CHECK FOR DISP TYPE
            BEQ         ABS:B
            BSR         SYMBOL
            CMPQB       FALSE, ERR_FLG          ;CHECK FOR SYMBOL ERROR
            BNE         FINISH:W                ;ALLDONE IF ERROR
            CMPQB       TRUE, YES_SYM           ;IF SYMBOL WAS FOUND
            BEQ         L_DISP:B                ;THEN SET DISPLACEMENT
            BR          OP_IS_D:W
ABS:        ADDQD       1,R1                    ;VECIN TO DISP START
OP_IS_D:    BSR         VALU
            CMPQB       TRUE, A_LONG_F
            BNE         L_DISP:B
            ANDB        H'1F, R5        
L_DISP:     MOVQB       FALSE, A_LONG_F
            BSR         DISP1

PARSEND:   CMPQB        -1, R2
           BEQ          MODE_SET:B       
           MOVB         MODCODE[R2:B],ADDRMODE  ;SET ADDR MODE CODING
MODE_SET:
            MOVD        OPSTRT,R1               ;VEC TO START OF 
                                                ;    CURRENT OPERAND    
NEXON:      CMPB        REGLIST,CATGORY         ;IGNOE COMMAS IF REGLIS
            BEQ         NOCOM:B         
            CMPB        0(R1),','               ;IF COMMA YOU ARE DONE
            BEQ         DONEPARS:W
            CMPB        0(R1),'['               ;IF [ THEN ADDR MODE INDEX
            BEQ         INDEXMOD:B              ;I
            BR          E_L:B                   ;PARSEND FOR REGLIST
NOCOM:      CMPB        0(R1),']'               ;CHECK FOR END OF
            BNE         E_L:B
            ADDQD       1, R1
            BR          DONEPARS:W      
E_L:        CMPD        R1,ENDLIN               ;IF EOL
            BGE         DONEPARS:W              ;    THEN DONE
            ADDQD       1,R1                    ;LOOP TIL END IS FOUND
            BR          NEXON           

INDEXMOD:   MOVB        ADDRMODE,SUFFIX[R6:B]   ;SUFFIX=ADDRMODE
            MOVQB       TRUE, SUFF_FLGS[R6:B]   ;FLAG SUFFIX AS PRESENT
            MOVZBD      INXB,R2                 ;INDEX TABLE TO INX:B
            CMPB        4(R1),'Q'               ;FIND I TYPE
            BEQ         QUADINX:B               ;FROM '0' VAD
            CMPB        4(R1),'D'               ;TO 'B' BYTE
            BEQ         DOUBINX:B
            CMPB        4(R1),'W'
            BEQ         WORDINX:B
            BR          BYTEINX:B

            QUADINX:    ADDQD 1,R2
            DOUBINX:    ADDQD 1,R2              
            WORDINX:    ADDQD 1,R2                      ;MAKE ADDR MODE INDX
            BYTEINX:    MOVB    MODCODE[R2:B],ADDRMODE  ;SHIFLT INDEX OFF OF
            LSHB        3, SUFFIX[R6:B]                 ;TO ITS FIELS
            MOVB        2(R1), R4               ;SET INDEX REG INTO THAT FIELD
            SUBB        H'30, R4                ;MUST EXPECT REG
            ORB         R4, SUFFIX[R6:B]
            ADDQD       6,R1                    ;VECT TO START OF
DONEPARS:   ADDQD       1,R1                    ;NEXT OPERAND
                                                ;INSERT MODE CODE INTO 
            MOVZBD      OPFIELD,R4              ;    BASIC INST         
            CMPQB       TRUE, INS_4BIT          ;CHECK FOR SPECIAL CASE
            BNE         TRY_8:B                 ;OF ADDRMODE
            INSB        R4,ADDRMODE,BASECODE,4
            BR          INSED:B
TRY_8:      CMPQB       TRUE, INS_8BIT
            BNE         NORM_ADDR:B             
            INSB        R4,ADDRMODE,BASECODE,8
            BR          INSED:B 
NORM_ADDR:  INSB        R4,ADDRMODE,BASECODE,5
INSED:      MOVQW       FALSE, INS_4BIT         ;CANCEL BOT SPECIAL FLAGS
FINISH:     RET         0


;SUBROUTINE MOVDISPLACEMENT
;MEM:=DISPLACEN
;CODESTRT:=CODESTRT+LEN
;R4=VEC TO LENGTH
;R5=VEC TO DISP

MOVDISP:    ADDQB       1,0(R4)
MOVLOOP:    ACBB        -1,0(R4),MOVADIP:B
            BR          MOVOVER:B
MOVADIP:    MOVB        0(R5),0(CODESTRT)
            ADDQD       1,R5
            ADDQD       1,CODESTRT
            BR          MOVLOOP
MOVOVER:    RET         0               

;       R O U T I N E      M O V __ A S C
;THIS ROUTINE IS PART OF PSUEDO OP OPERATION. IT TAKES CARE OF THE ASCII 
;STRING OPTION FOR THE .BYTE DIRECTIVE
MOV_ASC:
                ADDQD   1, R1           ;START OF ASCII LINE
ASC_LP:         CMPB    '"', 0(R1)      ;CHECK FOR ENDLIN
                BEQ     SET_NX:W   
                CMPD    R1, ENDLIN
                BGE     SET_NX:W    
                MOVB    0(R1), 0(CODESTRT)
                ADDQD   1, R1
                ADDQD   1, CODESTRT
                BR      ASC_LP

;       R O U T I N E      P S U E D O P
;KEY WORDS FOR PSUEDO OPS
STAT_:  .BYTE   'STAT'
ENDS_:  .BYTE   'ENDS'
BLKB_:  .BYTE   'BLKB'
BLKW_:  .BYTE   'BLKW'
BLKD_:  .BYTE   'BLKD'
;BYT_:  .BYTE   'BYTE'  
;WRD_:  .BYTE   'WORD'
;DOU_:  .BYTE   'DOUB'  
;FLT_:  .BYTE   'FLOA'
;LNG_:  .BYTE   'LONG'

PSUEDOP:
                MOVQD   FALSE, A_ERROR
                ADDQD   1, VECIN        ;REMEMBER TO SET R1 TO VALUE START
                MOVD    VECIN, R1        
                CMPD    STAT_, 0(R1)    ;IF STATIC SEG THEN SET SEGMENT ,
                BNE     TRYEND:B        ;SAVE LAST AND EXIT
                MOVB    SEGMENT, LASTSEG
                MOVQB   SB_SEG, SEGMENT ;SET SB
                BR      ALLDONE:W               
TRYEND:         CMPD    ENDS_, 0(R1)    ;IF END THEN REST LAST MODE
                BNE     SBSEG:B
                MOVB    LASTSEG, SEGMENT
                BR      ALLDONE:W
SBSEG:          MOVQD   1, FORM         ;TRY BLKB
                CMPD    BLKB_, 0(R1)
                BEQ     FINBLK:W
                MOVQD   2, FORM         ;TRY BLKW
                CMPD    BLKW_, 0(R1)
                BEQ     FINBLK:W
                MOVQD   4, FORM
                CMPD    BLKD_, 0(R1)
                BNE     PCSEG:W
FINBLK:         CMPQB   SB_SEG, SEGMENT ;CHECK FOR CORRECT SEGMENT
                BEQ     A_SB_SEG:B
SEGERR:         ADDR    ERR_SEG, A_ERROR
                BR      ALLDONE:W       ;ELSE ERR SEG
A_SB_SEG:       CMPQB   PASS1, PASS_NUM ;NO SB COUNT IN PASS 2
                BNE     ALLDONE:W
                MOVQD   1, R5           ;SET REPEAT TO 1
                ADDQD   5, R1
                CMPB    ' ', 0(R1)      ;IF END OF LINE THEN SKIP REPEAT
                BEQ     NOREAP:B        ;FACTOR
                CMPD    R1, ENDLIN
                BGT     NOREAP:B        
                BSR     VALU
                CMPQB   FALSE, ERR_FLG  ;IF GOOD VALUE THEN MOVIT
                BNE     ALLDONE:W       ;EXIT IF ERROR IN REPEAT VALUE  
NOREAP:         MULD    FORM, R5
                ADDD    R5, SBCOUNT
                BR      ALLDONE:W       
PCSEG:          CMPD    H'45545942, 0(R1)       ;H'"BYTE"
                BNE     A_WRD_:B
                ADDQD   5, R1
                CMPB    '"', 0(R1)
                BEQ     MOV_ASC
                MOVQB   TRUE, DISP_B
                BR      GET_VAL:W
A_WRD_:         CMPD    H'44524F57, 0(R1)       ;H'"WORD"
                BNE     A_DOU_:B
                MOVQB   TRUE, DISP_W
                ADDQD   5, R1
                BR      GET_VAL:W
A_DOU_:         CMPD    H'42554F44, 0(R1)       ;H'"DOUB"
                BEQ     A_DOUB:W
                CMPD    H'414F4C46, 0(R1)       ;H'"FLOA"
                BEQ     A_FLT:B
                CMPD    H'474E4F4C, 0(R1)       ;H'"LONG"
                BEQ     A_LNG:W
                ADDR    PSU_ERR, A_ERROR
                BR      ALLDONE:W
A_FLT:          ADDQD   6, VECIN
                MOVQD   SHRT_REAL, FORM
                BR      HFLOATIT:B
A_LNG:          ADDQD   5, VECIN
                MOVQD   LONG_REAL, FORM
HFLOATIT:       MOVB    CR, 1(ENDLIN)
                CMPQB   PASS1, PASS_NUM
                BEQ     REAL_G:B
                ADDR    A_REAL_NUM, TOS
                MOVD    VECIN, TOS
                MOVZBD  50, TOS
                ADDR    FORM, TOS
                ADDR    F_ERROR, TOS
                BSR     ASC_2_RE
                CMPQD   FALSE, F_ERROR
                BEQ     REAL_G:B
                ADDR    REAL_BAD, A_ERROR
                BR      ALLDONE:W
REAL_G:         MOVD    A_REAL_NUM, 0(CODESTRT)
                ADDQD   4, CODESTRT
                CMPQD   SHRT_REAL, FORM
                BEQ     SET_NX:W
                MOVD    A_REAL_NUM+4, 0(CODESTRT)
                ADDQD   4, CODESTRT
                BR      SET_NX:W
A_DOUB:         MOVQB   TRUE, DISP_D
                ADDQD   7, R1
GET_VAL:        MOVQD   0, R5
                CMPQB   PASS1, PASS_NUM
                BEQ     MOV_COUNT:W
                BSR     SYM_SRCH
                CMPQB   TRUE, S_FOUND
                BEQ     OK_OP:B
                BSR     VALU
                CMPQB   FALSE, ERR_FLG          ;IF GOOD VALUE THEN MOVIT
                BEQ     MOV_COUNT:B             ;ELSE TRY A SYMBOL
                BR      ALLDONE:W
OK_OP:          MOVD    SYM_VAL, R5
                CMPB    '-', 2(R1)              ;CHECK FOR CASE WORK
                BNE     MOV_COUNT:B
                ADDQD   3, R1
                BSR     SYM_SRCH                ;LOOK FOR SECOND SYMBOL
                CMPQB   TRUE, S_FOUND
                BEQ     CALC_V:B
                ADDR    SYM_ERR3, A_ERROR
                BR      ALLDONE:W
CALC_V:         SUBD    SYM_VAL, R5             ;DO SUBTRACTION ANDDONE

MOV_COUNT:                             
                CMPQB   TRUE, DISP_B
                BNE     MOV_2:B
                MOVB    R5 ,0(CODESTRT)
                ADDQD   1, CODESTRT
                BR      SET_NX:B
MOV_2:          CMPQB   TRUE, DISP_W
                BNE     MOV_4:B
                MOVW    R5, 0(CODESTRT)
                ADDQD   2, CODESTRT
                BR      SET_NX:B
MOV_4:          MOVD    R5, 0(CODESTRT)
                ADDQD   4, CODESTRT
SET_NX:         MOVD    CODESTRT, CODEEND
                MOVQD   FALSE, A_ERROR
                CMPQB   PC_SEG, SEGMENT
                BNE     SEGERR
                BR      ALLDONE:W
                        
;       R O U T I N E      A D D S Y M
BAD_SYM:        ADDR    SYM_ERR2, A_ERROR       ;BAD SYMBOL TABLE
                BR      ALLDONE:W   
DUP_SYM:        ADDR    SYM_ERR1, A_ERROR       ;SET ERROR FLAG
                BR ALLDONE:W                    ;EXIT

ADDSYM:         CMPQB   PASS2, PASS_NUM         ;IF PASS 2 THEN DONT
                BEQ     DONT:W                  ;ADD TO TABLE
                MOVD    SYM_TAB, R0             ;START OF SYM AREA
                MOVW    1000, R1                ;SET SANITY COUNT
        SYM_S:  CMPQD   -1, -3(R0)              ;LOOK FOR END OF TABLE
                BEQ     EMPTY:B                 ;ADD SYM WHEN FOUND
                CMPW    0(VECIN), -7(R0)        ;ELSE CHECK FOR DUPLICATE
                BEQ     DUP_SYM                 ;IF FOUND SET ERROR AND ABORT
                ADDQD   -8, R0                  ;ELSE POINT TO NEXT ENTRY
                ACBW    -1, R1, SYM_S           ;AND LOOK AGAIN
                BR      BAD_SYM                 ;IF 1000 ENTRIES WITH NO RESULT
                                                ;THEN ABORT WITH ERROR MESSAGE
        EMPTY:  CMPQB   PC_SEG, SEGMENT         ;ENTER VALUE ACCORDING TO
                BEQ     ENTERPC:B               ;CURRENT SEGMENT
                MOVD    SBCOUNT, SBC            ;PASS SB LABEL VALU
                SBITD   31, SBC                 ;SB SYM FLAG
                MOVD    SBC, -3(R0)
                BR      DONAME:B
        ENTERPC:MOVD    PC_ADDR, -3(R0)         ;ENTER INTO TABLE
        DONAME: MOVW    0(VECIN), -7(R0)        ;THE VALUE AND SYMBOL
                MOVW    0(VECIN), LABEL         ;EXPORT FOR DEBUG TABLE
                MOVB    SEGMENT, -4(R0)         ;SET SYMBOL TYPE
                ADDQD   -8, R0                  ;SET NEW END FLAG
                MOVQD   -1, -3(R0)              ;DONE
        DONT:   ADDQD   3,VECIN
                BR      ADDRET:W

;       R O U T I N E      L E A D __ S P A C
LEAD_SPAC:
NX_SPC: CMPB    ' ', 0(VECIN)           ;SQUASH LEADING SPACES
        BNE     NOT_SPC:B
        ADDQD   1, VECIN                ;CHECK FOR EMPTY
        CMPD    VECIN, ENDLIN           ;LINE
        BGT     NOT_SPC:B               ;QUICK IF EMPTY
        BR      NX_SPC
NOT_SPC:
        RET     0

;       R O U T I N E      S P A C E   P A C K
SPAC_PAK:
        PACK:   CMPD    R0, ENDLIN
                BGE     EOL:B
                CMPB    '"', 0(R0)
                BNE     NO_STR:B
SKIP_STR:       ADDQD   1, R0
                CMPB    '"', 0(R0)
                BEQ     NO_STR:B
                CMPD    R0, ENDLIN
                BGT     EOL:B
                BR      SKIP_STR
NO_STR:         CMPB    ' ', 0(R0)              ;CHECK FOR ASCII STRING
                BNE     INC:B
                MOVD    R0, R1
       SQ:      MOVB    1(R1), 0(R1)
                ADDQD   1, R1
                CMPD    R1, ENDLIN
                BLE     SQ
                ADDQD   -1, ENDLIN
                BR      PACK
        INC:    ADDQD   1, R0
                BR      PACK
        EOL:    RET     0                       ;ALL SPACES SQUASHED    

;       R O U T I N E   U P P E R C A S E
UPCASE:
                MOVD    VECIN, R0
        DELO:   CMPB    'a', 0(R0)              ;CONVERT TO UPPER CASE
                BGT     ACAP1:B                 ;IF VECIN < 'a' THEN ACAP
                ADDB    -H'20, 0(R0)            ;ELSE SET TO CAP
        ACAP1:  ADDQD   1, R0                   ;DO UNTIL ENDLIN
                CMPD    R0, ENDLIN
                BLE     DELO
                RET     0

;       R O U T I N E   R E A L E N D 
REALEND:
                MOVD    VECIN, R4               ;CHECK FOR COMMENT ON INST
        ACOM:   CMPB    ';', 0(R4)              ;IF COMMENT THEN CHANGE ENDLIN
                BNE     TILFIN:B
                MOVD    R4, ENDLIN              ;SET NEW ENDLIN
                MOVB    ' ', 0(R4)              ;CLEAR IT TO A SPACE
                RET     0                       ;RETURN
        TILFIN: ADDQD   1, R4
                CMPD    R4, ENDLIN              ;DO FOR WHOLE LINE
                BLE     ACOM
                RET     0

;       M A I N    R O U T I N E   C O D I T
;
; REGISTER DUTY LIST
; R0= VEC TO CODE TABLE
; R1= VEC TO INPUT STRING
; R3= COUNTER FOR SEARCH COUNTROL
; R4= GENERAL DUTY
; R6= COMMON INDEXER TO INPUT/NEUMONIC MATCHING

CODIT:  
        MOVD    LIN_STRT, R1            ;MOVE SOURCE TO PARSE BUFFER
        MOVD    LIN_END, R0     
        ADDR    BAD_LIN, A_ERROR        ;ASSUME A BAD LIN FOR START
        SUBD    R1, R0                  ;CHR_CNT
        ADDR    TXT_BUF, ENDLIN         ;SET END OF INPUT LINE
        ADDD    R0, ENDLIN              ;SET LINE END
        ADDQD   -1, ENDLIN
        ADDQD   1, R0
        ADDR    TXT_BUF, R2             ;DESTINATION
        MOVD    R2, R3
        MOVSB
        ADDR    TXT_BUF, VECIN          ;SET LINE START
        MOVB    ' ', 1(ENDLIN)          ;CANCEL THE LAST CHAR (CR)
        BSR     LEAD_SPAC               ;SQUASH LEADING SPACES
        CMPD    VECIN, ENDLIN           ;CHECK FOR EMPTY LINE
        BLE     A_COM:B                 ;IGNORE IT      
        MOVQD   FALSE, A_ERROR          ;NO ERROR
        BR      ALLDONE:W
A_COM:  BSR     UPCASE                  ;CONVERT LINE TO UPPER CASE ENTRY
        CMPB    ';', 0(VECIN)
        BNE     A_SYM:B                 ;SKIP COMMENT LINE
        MOVQD   FALSE, A_ERROR
        BR      ALLDONE:W
A_SYM:  CMPB    ':', 2(VECIN)           ;CHECK FOR LINE SYMBOL
        BEQ     ADDSYM
ADDRET: CMPB    ' ', 0(VECIN)           ;SQUASH LEADING SPACES TILL
        BNE     THE_INS:B               ;UNTILL THE INSTRUCTION IS FOUND
        ADDQD   1, VECIN                        ;CHECK FOR END OF LINE
        CMPD    VECIN, ENDLIN           ;IF END THEN QUIT
        BLT     ADDRET
        BR      ALLDONE:W
THE_INS:MOVD    VECIN, R0               ;GET POINTER STARTED FOR OPERAND FIELD
INSX:   CMPB    ' ', 0(R0)              ;GO TO START OF OPERAND FIELD
        BEQ     O_FLD:B                 ;IF SPACE THEN START OF OPERANDS
        ADDQD   1, R0                   ;GO PAST THE INS
        CMPD    R0, ENDLIN              ;SEE IF END OF LINE
        BGE     SRET:B                  ;IF EOL THEN SKIP SPACPAK
        BR      INSX                    ;OF OPERANDS AND GO FOR NO OP INS
O_FLD:  ADDQD   1, R0                   ;INC TO START OF OP FIELD
        BSR     SPAC_PAK
SRET:   BSR     REALEND                 ;GET NEW ENDLIN IN CASE OF COMMENT
        CMPB    '.', 0(VECIN)           ;CHECK FOR PSUEDO OP
        BEQ     PSUEDOP
        CMPQB   PC_SEG, SEGMENT         ;IF NOT PC SEGMENT THEN
        BNE     SEGERR                  ;THEN ERROR
        ADDR    CODTABL,R0              ;POINTER TO START OF CODE TABLE
        MOVW    NUMOFINST,R3            ;R3=COUNTER FOR SEARCH CONTROL

INSTLOOP:
        EXTSB   0(R0),NUMLETS,F1OFF,F1LGTH      ;GET LENGTH OF ASCII NEUMONIC
        EXTSB   0(R0),OPCLGTH,F2OFF,F2LGTH      ;GET LENGTH OF BACIS CODE
        MOVQD   0,R6                    ;COMMON INDEX TO INPUT/TABLE
        MOVD    VECIN,R1                ; START OF INPUT STRING
        MOVQW   FALSE, CONREAL          ;DELETE ANY PREVIOUS REAL NUM FLGS

NEXCHAR:
        CMPB    4(R0)[R6:B],'$'         ;CHECK FOR BWD CODING
        BNE     A_REAL:B                ;IF TRUE THEN SET ITYPE
        MOVQB   DOUBLNG,ITYPE
        CMPB    0(R1)[R6:B],'D'         ;DOUBLE IS DEFAULT
        BEQ     NEXONE:W                ;IF EQUAL LOOK AT NEXT CHAR
        MOVQB   WRDLONG,ITYPE           ;CHECK FOR WORD LONG
        CMPB    0(R1)[R6:B],'W'         ;IF NOT WORD
        BEQ     NEXONE:W                ; THEN MUST BE BYTE
        MOVQB   BYTLONG,ITYPE
        CMPB    0(R1)[R6:B],'B'         ;IF NOT WORD
        BEQ     NEXONE:W                ; THEN MUST BE BYTE
        BR      NEXTINST:W
A_REAL:
        CMPB    4(R0)[R6:B],'#'         ;CHECK FOR CONVERSION TYPE REAL INST
        BNE     REAL_REAL:B             ;IF FALSE THEN CHECK FOR REAL TO REAL
        CMPB    0(R1)[R6:B],'L'         ;IF LONG THEN SET NOT FLAG
        BEQ     NEXONE:B                ;ELSE IF SHORT TYPE
        CMPB    0(R1)[R6:B],'F'         ;SET FLAG TO SET F BIT
        BNE     NEXTINST:B
        MOVQB   TRUE,CONREAL
        BR      NEXONE:B
REAL_REAL:
        CMPB    4(R0)[R6:B],'!'         ;IF NOT REAL TO REAL SHORT THEN
        BNE     OTHER:B
        CMPB    0(R1)[R6:B],'L'         ;IF LONG THEN SET NOT FLAG
        BEQ     NEXONE:B                ;ELSE IF SHORT TYPE
        CMPB    0(R1)[R6:B],'F'         ;SET FLAG TO SET F BIT
        BNE     NEXTINST:B
        MOVQB   TRUE,SHRTREAL
        BR      NEXONE:B

OTHER:  CMPB    4(R0)[R6:B],0(R1)[R6:B] ;IF INPUT <> NEUMONIC CHAR
        BNE     NEXTINST:B              ; MOVE ON TO NEXT INST

NEXONE: ADDQD   1,R6                    ;ELSE IF ALL CHAR MATCHED THEN
        CMPB    NUMLETS,R6              ;IT IS FOUND
        BEQ     FOUNDIT:B               ;ELSE LOK AT NEXT CHAR
        BR      NEXCHAR 

NEXTINST:
        ADDB    NUMLETS,OPCLGTH         ;PREPARE OFFSET TO
        MOVZBD  OPCLGTH,R4              ;TO NEXT INST IN
        ADDQD   4,R4                    ;TABLE
        ADDD    R4,R0                   ;UPDATE TABLE POINTER
        ACBW    -1,R3,INSTLOOP          ;IF COUNT=0 THEN
        ADDR    NO_SUCH_INST, A_ERROR           ;INST NOT FOUND
        BR      ALLDONE:W               ; SET ERROR AND QUIT

FOUNDIT:
        CMPB    ' ',0(R1)[R6:B]         ;IF NOT END OF INPUT STR
        BNE     NEXTINST                ;THEN GET NEXT INST
AFIND:  MOVB    OPCLGTH,CODELGTH        ; SAVE CODE LENGTH
        MOVQD   0,R6                    ;SET COMMON INDEX TRANSFER
        ADDR    4(R0),R4                ;CALC ADDR OF INST CODE
        MOVZBD  NUMLETS,R5              ;OFFSET N# OS ASCII CHAR
        ADDD    R5,R4
        addd    r5,r1

MOVECODE:
        MOVB    0(R4)[R6:B],BASECODE[R6:B]
        ADDQD   1,R6                    ;MOVE BYTE SEQUENCIAL FOR
        ACBB    -1,OPCLGTH,MOVECODE     ;OPCLGHT # OF BYTES

        EXTSB   0(R0),ICODE,F3OFF,F3LGTH        ;GET BWD CATEGORY
        CMPQB   FALSE,ICODE             ;IF FALSE GO ON TO
        BEQ     OPERANS:B               ;OPERANDS PARSE

        CMPQB   BIT0,ICODE              ;IF BWD IS NOT CODED @ BIT 0
        BNE     BIT8C:B                 ;THEN MUST BE AT BIT 8
        INSSB   ITYPE,BASECODE,0,2      ;INSET BWD @ BIT 0
        BR      OPERANS:B
BIT8C:  INSSB   ITYPE,BASECODE+1,0,2    ;INSET BWD @ BIT 8
        

OPERANS:    CMPQB       TRUE,CONREAL    ;SET CONVERSION TYP REAL INST
            BNE         S_R:B           ;TO SHORT
            SBITD       10, BASECODE    ;ELSE CHECK FOR REAL TO REAL SHORT
       S_R: CMPQB       TRUE, SHRTREAL
            BNE         ALLSET:B
            SBITD       8, BASECODE
ALLSET:     addqd       1,r1            
            MOVQD       0,R6                    ;TABLE INDEX OPERAND 1
            MOVZBD      CATOFF, R4
            EXTB        R4,0(R0),CATGORY,CAT    ;GET SPECIAL CATEGORY
            MOVB        CATGORY, ADISP          ;SRIP DOWN TO 2 BIT VAL
            ANDB        3, ADISP
            ANDB        28, CATGORY                     ;STRIP OF DISPDATA
            MOVQB       FALSE, OP_IS_DISP       ;CHECK IF THIS
            CMPQB       OP1_DISP, ADISP         ;OPERAND IS OF DISP
            BNE         DO1:B                   ;TYPE
            MOVQB       TRUE, OP_IS_DISP          

DO1:        MOVZBD      0, R6                   ;SET TABLE INDEX TO FIRST OP
            MOVZBD      F4OFF,R4                ;DATA FIELD OF FIRST OPERAND
            BSR         OPERATE                 ;PARSE OPERAND 1

            CMPQB       TRUE, ERR_FLG           ;IF ERROR IN OP THEN ABORT
            BEQ         ALLDONE:W
            MOVQB       FALSE, OP_IS_DISP       ;CHECK IF THIS
            CMPQB       OP2_DISP, ADISP         ;OPERAND IS OF DISP
            BNE         DO2:B                   ;TYPE
            MOVQB       TRUE, OP_IS_DISP          

DO2:        MOVQD       1,R6                    ;PARSE OPERAND 2
            MOVZBD      F5OFF,R4
            BSR         OPERATE

            CMPQB       TRUE, ERR_FLG           ;IF ERROR IN OP THEN ABORT
            BEQ         ALLDONE:W
            MOVQB       FALSE, OP_IS_DISP       ;CHECK IF THIS
            CMPQB       OP3_DISP, ADISP         ;OPERAND IS OF DISP
            BNE         DO3:B                   ;TYPE
            MOVQB       TRUE, OP_IS_DISP          

DO3:        MOVQD       2,R6                    ;3
            MOVZBD      F6OFF,R4
            BSR         OPERATE

            CMPQB       TRUE, ERR_FLG           ;IF ERROR IN OP THEN ABORT
            BEQ         ALLDONE:W
            MOVQB       FALSE, OP_IS_DISP       ;CANCEL DISP FLAG
            MOVQD       3,R6                    ;4
            MOVZBD      F7OFF,R4
            BSR         OPERATE
            CMPQB       TRUE, ERR_FLG
            BEQ         ALLDONE:W

;THE FINISHING TOUCH     
            MOVQD       0,R6
            MOVQD       0,R0

CODEBUILD:  MOVB        BASECODE[R0:B],0(CODESTRT)   ;MOV BYT WISE BASIC CODE
            ADDQD       1,R0                         ;TO DESTINATION MEM
            ADDQD       1,CODESTRT
            ACBB        -1,CODELGTH,CODEBUILD

                                                     ;MOV SUFFIXES IF PRESENT
            CMPQB       FALSE,S_FLG1
            BEQ         SUFF2:B
            MOVB        SUFFIX1,0(CODESTRT)
            ADDQD       1,CODESTRT
SUFF2:      CMPQB       FALSE,S_FLG2
            BEQ         SUFF3:B
            MOVB        SUFFIX2,0(CODESTRT)
            ADDQD       1,CODESTRT
SUFF3:      CMPQB       FALSE,S_FLG3
            BEQ         NOSUF:B
            MOVB        SUFFIX3,0(CODESTRT)
            ADDQD       1,CODESTRT

NOSUF:
            MOVQD       4,R7
            MOVQD       0,R6

NEXTDISP:   CMPB        FALSE,LEN1[R6:B]
            BEQ         NEXTD:B
            ADDR        LEN1[R6:B],R4
            ADDR        DISP1X[R6:D],R5
            JSR         MOVDISP
            CMPB        FALSE,LEN2[R6:B]
            BEQ         NEXTD:B
            ADDR        LEN2[R6:B],R4
            ADDR        DISP2X[R6:D],R5
            JSR         MOVDISP
NEXTD:      ADDQD       1,R6
            ACBB        -1,R7,NEXTDISP
            MOVD        CODESTRT, CODEEND       
            MOVQD       FALSE,A_ERROR

ALLDONE:
            .ENDPROC

; end of ahelp.32k
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; start of ahelpio.32k

;-----------------------------------------------------------------------
;       S U P E R V I S O R       F U N C T I O N S
;
COMD_IN:                .PROC
        LIN_STRT:       .BLKD           ;START OF MONITOR LINE
                        .RETURNS
        COMD_OK:        .BLKB           ;SYNTAX FLAG
                        .VAR [R1,R2,R3,R4,R5,R6,R7]
                        .BEGIN
                        MOVB    ' ', DELIMIT
                        MOVB    80, R2
                        MOVD    LIN_STRT, VECIN3
                        MOVD    VECIN3, R1               ;CHECK FOR LINE
        CR_SRCH:        CMPB    CR, 0(R1)               ;TERMINATED WITH CR
                        BEQ     END__L:W
                        CMPB    ' ', 0(R1)              ;REPLACE TABS AND
                        BLE     NOTTAB:B                ;FILTER OUT SPECIAL
                        MOVB    ' ', 0(R1)              ;CHARACTERS WITH
                NOTTAB: ADDQD   1, R1                   ;A SPACE
                        ACBB    -1, R2, CR_SRCH
                        BR      NOT_CMD:W
        END__L:         MOVD    R1, VECEN
                        MOVQB   TRUE, COMD_OK
                        CMPB    'a', 0(VECIN3)           ;CONVERT COMMAND TO
                        BGT     ACAP3:B                 ;TO UPPER CASE
                        ADDB    -H'20, 0(VECIN3)
                ACAP3:  CMPB    'a', 1(VECIN3)           ;CONVERT SECOND CHAR
                        BGT     START:W                 ;TO UPPER CASE
                        ADDB    -H'20, 1(VECIN3) 
                        BR      START:W
        NOT_CMD:        MOVQB   FALSE, COMD_OK
        COMD_LOOP:
                        MOVQB   FALSE,NOTECHO
                        .ENDPROC        
;-----------------------------------------------------------------------

;------------------ E R R O R  M E S S A G E S ------------------------
        BAD_LOOP:       .BYTE 'BAD_SEQ',CR      ;ERROR MESSAGE FOR BAD LOOP 
        BADMEM:         .BYTE 'BAD_MEM',CR      ;MEMORY CONFLICT AT ASM TIME

;------------------- C O M M A N D  T A B L E ----------------------------
        COMTAB: .BYTE   'RS'    ;**********************************
                .BYTE   'IN'    ;******* W A R N I N G ************
                .BYTE   'TP'    ;**********************************
                .BYTE   'KI'    ;DO NOT MOVE THESE FIRST 5 COMMANDS
                .BYTE   'RP'
                .BYTE   'AS'
                .BYTE   'RL'
                .BYTE   'TR'
                .BYTE   'TW'
                .BYTE   'RX'
                .BYTE   'IT'
                .BYTE   'ZO'
                .BYTE   'ZI'
                .BYTE   '@R'
                .BYTE   '@M' 
#ifdef THEFORCE
                .BYTE   'ZM' 
                .BYTE   'EI' 
#endif
        CMD_N:  .EQU    ($ - COMTAB)/2

;-------------START OF AHELP ROUTINES----------------------------------

;+++++++++++++
#ifdef DB16000
;+++++++++++++
;MEMSIZE NEEDED FOR ASMBLER FOR START OF SYMBOL LIST

MEM_SIZ:        
        CMPQD   -1,MEMSIZ
        BEQ     DOFIND:B
        MOVD    MEMSIZ,R0
        RET     0               ;DB32 VERSION MEMSIZ = 512K
DOFIND: MOVD    ram_top, R0     ;ROUTINE TO GET HIGH MEM ADDRESS (migry)
HALF:   MOVB    78, 0(R0)       ;WRITE A UNIQUE TEST VALUE TO ADDR
        MOVB    0(R0), R1
        CMPB    78, R1          ;IF VERIFIED THEN FOUND
        BEQ     GOT_CRU:B
        LSHD    -1, R0          ;HALF MEMSIZE LOWER
        BR      HALF
GOT_CRU:
        MOVB    78, 0(R0)       ;NOW GET DOWN TO EXACT SIZE 
        MOVB    0(R0), R1
        CMPB    78, R1          ;IF VERIFIED THEN FOUND
        BNE     GOT_SIZ:B
        MOVQB   0, 0(R0)                ;LEAVE NO TRAIL
        ADDQD   1, R0                   ;BYTE MEMSIZE LOWER
        BR      GOT_CRU
GOT_SIZ:
        ADDQD   -1, R0                  ;LAST BYTE
        RET     0       
#endif
;+++++++++++++

;-----------------------E R R O R  R O U T I N E S--------------------

ERR_MES:
        CMPQD   FALSE, ERROR    ;GENERAL PURPORE ERROR MESSAGE OUTPUT
        BEQ     NO_ERR:B        ;AND FLAG SETTER
        MOVQB   FALSE, A_PARAM  ;IF THERE IS A ERROR MESSAGE THEN
        ADDQD   1, ERR_CNT      ;OUTPUT IT
        BSR     BUF_CLR:W       ;CLEAR LINE
        MOVD    ERROR, R0
        MOVMB   0(R0), IOBUF, 7
        BSR     WRIT_LN:B
NO_ERR: RET     0

INSANE: ADDR    BAD_LOOP, ERROR         ;DUE TO IMPROPER SEQUENCE
        BSR     ERR_MES                 ;OF COMMANDS
        BR      COMD_LOOP

BAD_MEM: 
        ADDR    BADMEM, ERROR
        BSR     ERR_MES
        BR      COMD_LOOP

;--------------- W R I T E   L I N E   R O U T I N E ------------
WRIT_LN:                        ;ROUTINE TO WRITE CONTENTS OF IOBUF
        MOVQD   WRITE, R0       ;THRU SVC FUNCTION
        ADDR    IOBUF, R1       ;LINE LENGTH IS 80
        MOVZBD  80, R2          ;USED WITH BUF CLR ROUTINE
        MOVQD   MAIN, R3
        SVC
        RET     0
;---------------L I S T I N G   R O U T I N R -------------------
ALISTING:
        MOVD    HISTF, R0       ;CLEAR NO LF BIT IN NAME
        CBITD 31, R0
        CMPD    AUX_PORT:W, R0  ;IF HISTORY ENABLED
        BNE     PRI_C:B         ;CHECK FOR PRINTER FLAG
        MOVQD   WRITE, R0
        ADDR    IOBUF, R1
        MOVZBD  80, R2
        MOVQD   AUX, R3         ;WRITE TO BLX351
        TBITD   31, HISTF       ;CHECK FOR NO LF BIT
        BFS     NOLF0:B
        MOVB    LF, IOBUF+78
NOLF0:  SVC                     ;CALL SUPER FOR WRITE
PRI_C:  CMPD    PRINTER:W, R0
        BNE     WRT_EN:B        ;IF NOT SET THEN END WRITE
        ADDR    IOBUF, TOS      ;PASS BUFFER VEC
        MOVZBD  80, TOS         ;AND CHR CNT TO PRINTER ROUTINE
        TBITD   31, HISTF       ;CHECK FOR NO LF BIT
        BFC     A_LF:B
        SBITD   31, 0(SP)       ;SET FLAG FOR LF WITH CR
A_LF:   BSR     PRINTC
WRT_EN: 
        RET     0

;-------------------- C L E A R   B U F F E R   R O U T I N E -----------------

BUF_CLR:                        ;THIS ROUTINE CLEARS (SETS THE 
        ADDR    IOBUF, R0       ;IOBUF LINE TO ALL SPACES
        MOVB    80, R1
SPACITH: MOVB    ' ', 0(R0)      ;AND TERMINATES IT WITH A CARRIAGE RETURN
        ADDQD   1, R0
        ACBB    -1, R1, SPACITH
        MOVB    CR, IOBUF+79    ;LEAVE ROOM FOR LF
        RET     0


;------ R O U T I N E        L I N E __ P A R S -------------------------------
LINE_PARS:                              ;PARSE FOR LINE PARAMETRS
        MOVQD   FALSE, ERROR
        MOVQB   FALSE, A_PARAM          ;ASSUME NO PARAMETER PRESENT
        CMPD    VECIN3, VECEN            ;IF CHR POINTER > EOL THEN
        BGE     DEF_L:W                 ;  ALLDONE
        CMPB    DELIMIT, 0(VECIN3)       ; IF FIRST CHAR IS DELIMITER THEN
        BNE     DO_F:B   
        ADDQD   1, VECIN3                ; SET TO NEXT PARM AND EXIT
        BR      DEF_L:W
DO_F:   MOVD    VECIN3, TOS              ; ELSE TRY TO GET PARAM VALUE
LOOKMO:
        CMPB    1(VECIN3), DELIMIT       ;IF CHR+1 = DELIMITER THEN
        BEQ     GET_LN:B                ;  GET THE NUMBER
        CMPB    1(VECIN3), CR            ;ELSE CHECK FOR EOL
        BEQ     GET_LN:B                ; GET NUMBER IF TRUE
        ADDQD   1, VECIN3                ;ELSE BUMP CHR POINTER LOOK MORE
        CMPD    VECIN3, VECEN            ;AVOID ENDLESS LOOP DISASTER
        BGE     GET_LN:B                ;LEAVE VECIN3 AT NEXT PARAMETER
        BR      LOOKMO
GET_LN:                      
        MOVD    VECIN3, TOS              ;SET EOL
        BSR     A_NUM                   ;CALL CONVERSION ROUTINE
        MOVD    TOS, PAR_VAL  
        ADDQD   2,VECIN3                 ;START OF NEXT PARAM IF ANY
        MOVQB   TRUE, A_PARAM           ;YES DID FIND A PARAMETER
        BSR     ERR_MES
DEF_L:  RET     0

;-------------------------------------------------------------------------
;       R O U T I N E     B E G I N
 
BEGIN:  MOVW    12345,FIRST
        MOVQD   -1,MEMSIZ
        MOVQD   0, HISTF                ;NO HISTORY SELECTED
        MOVQB   FALSE, LEADZERO         ;DECODE COMMAND LINE
        MOVQB   FALSE, ASS_BLED         ;INITIALIZE STAND ALONE 
        MOVB    ' ', DELIMIT            ;INITIAL DELIMTER FOR PARSING
        MOVQD   -1, A_MOD               ;SET TO NOT AUTO MOD CONSTRUCT
        ADJSPB  8                       ;PUSH DUMMY FOR EDIT CALL TO RESET
        MOVQW   0 ,TOS                  ;0 = RESET COMAND
        BSR     EDIT   
        ADJSPB  -8                      ;POP RETURN VARIBLES
        BSR     BUF_CLR                 ;OUTPUT ID
        MOVQB   HEX, MON_BASE           ;MONITOR COMMANDS IN HEX
        RET     0
;-----------------------------------------------------------------------------
;       R O U T I N E     I N __ L I N  
IN_LIN:         BSR     BUF_CLR
                movqd   READ, r0                ;SVC INPUT
                addr    IOBUF, r1               
                movd    READ_NUM, r2
                movqd   MAIN, r3
                svc
                MOVD    R1, VECIN3               ;SET UP ATART OF INPUT LINE
                MOVD    R1, VECEN               ;SET UP END OF LINE
                ADDQD   -1, R2                  ;ADD CHAR COUNT TO START
                ADDD    R2, VECEN
                RET     0
;---------------------------------------------------------------------------

START:          
        MOVQD   0, R7
FIND:   MOVB    CMD_N, R6
        MOVD    VECIN3, R0
        CMPW    0(R0), COMTAB[R7:W]
        BEQ     FOUND:B
        ADDQB   1, R7
        CMPB    R7, R6
        BGT     NOT_CMD
        BR      FIND:B
FOUND:  CMPB    10, R7  ;CHECK FOR INIT COMMAND
        BEQ     CMD_V:B
        CMPW    12345, FIRST
        BNE     NOT_CMD
CMD_V:  CASEW   CMD_VEC:B[R7:W]
CMD_VEC:        .WORD   EDINI  - CMD_V   ; "RS" R7 IS RESERVED FOR COM#
                .WORD   EDINS  - CMD_V   ; "IN" DO NOT CHANGE THE ORDER OF THESE
                .WORD   EDDIS  - CMD_V   ; "TP" FIRST 5 ENTRIES
                .WORD   EDDEL  - CMD_V   ; "KI"
                .WORD   EDREP  - CMD_V   ; "RP"
                .WORD   ASMIT  - CMD_V   ; "AS"
                .WORD   SLHST  - CMD_V   ; "RL"
                .WORD   TAPER  - CMD_V   ; "TR"
                .WORD   TAPEW  - CMD_V   ; "TW"
                .WORD   RADIX  - CMD_V   ; "RX"
                .WORD   INIT   - CMD_V   ; "IT"
                .WORD   ZOUT   - CMD_V   ; "ZO"
                .WORD   ZIN    - CMD_V   ; "ZI"
                .WORD   ATR    - CMD_V   ; "@R"
                .WORD   ATM    - CMD_V   ; "@M"
#ifdef THEFORCE
                .WORD   ZMEM   - CMD_V   ; "ZM"
                .WORD   ENINTS - CMD_V   ; "EI"
#endif
;--------------------------------------------------------------------------
;       I N I T    C O M M A N D

INIT:   BSR     BEGIN
        BR      COMD_LOOP
;--------------------------------------------------------------------------
;       S E L E C T    L I S T I N G
AUX_PORT:       .BYTE   'ASN:'
PRINTER:        .BYTE   'LPT:'
SLHST:
        MOVD    AUX_PORT, HISTF
        CMPD    AUX_PORT, 3(VECIN3)
        BEQ     CR_CHK:B
        MOVD    PRINTER, HISTF
        CMPD    PRINTER, 3(VECIN3)
        BEQ     CR_CHK:B
        MOVQD   0, HISTF
        BR      COMD_LOOP
CR_CHK: CMPB    'C', 8(VECIN3)
        BNE     COMD_LOOP
        SBITD   31, HISTF
        BR      COMD_LOOP

;---------------------------------------------------------------------------
;       E D I T O R    C O N T R O L    P R O C E S S
;
EDINI:  ;EDIT INITIALIZE COMMAND
        ADJSPB  8
        MOVQW   0, TOS
        BSR     EDIT
        MOVQB   FALSE, ASS_BLED
        BR      COMD_LOOP   

EDINS:  ;EDITOR INSERT COMAND
EDREP:  ;EDITOR REPLACE COMAND
        MOVB    DEC, BASE
        MOVQD   FALSE, ERROR
        ADDQD   3, VECIN3                ;START OF INPUT OR PARAMETERS
        CMPB    0(VECIN3), '0'           ;CHECK FOR A NUMBER
        BLT     USE_DEF:B               ;IF INPUT < '0' THEN NOPARAM
        CMPB    0(VECIN3), '9'           ;IF INPUT > '9' THEN NOPARAM
        BGT     USE_DEF:B
        MOVB    ' ', DELIMIT
        BSR     LINE_PARS               ;GET THE PARAMETER
        CMPQB   TRUE, A_PARAM           ;CHECK IF PARAMTER WAS FOUND
        BNE     USE_DEF:B               ; NO THEN USE DEFAULT
        MOVD    PAR_VAL, NEXT_LN
USE_DEF: 
        CMPQD   FALSE, ERROR
        BNE     COMD_LOOP
        MOVD    NEXT_LN, LINNUM         ;SET NEXT LINE AS DEF FOR OPERATION
        MOVD    VECIN3, TOS              ;PASS LINE PARAMETERS TO EDITOR
        MOVD    VECEN, TOS
        MOVW    R7, TOS                 ;PASS COMMAND
        BSR     EDIT
        CMPQD   TRUE, ERROR             ;IF EDIT ERROR THEN
        BEQ     NO_SEQ:B                ;NO AUTO SEQUENCE
        MOVQB   FALSE, ASS_BLED         ;ASSEMBLY NOT VALID
        MOVD    LINNUM, NEXT_LN         ;AUTO SEQUENCE UP
        ADDQD   1, NEXT_LN               
NO_SEQ: MOVQB   1, R6                   ;SET LOOP CONTROL TO 1
        BR      ED_END:W   

EDDEL:  ;EDITOR DELETE LINE COMMAND
        MOVB    DEC, BASE
        ADDQD   3, VECIN3                ;START OF OPTIONAL PARAMETER
        MOVB    ' ', DELIMIT
        BSR     LINE_PARS               ;GET THE PARAMETER
        CMPQB   TRUE, A_PARAM
        BNE     DEL_DEF:B
        MOVD    PAR_VAL, LINNUM
DEL_DEF: 
        CMPQD   FALSE, ERROR
        BNE     COMD_LOOP
        MOVQB   1, R6                   ;SET LOOP CONTROL
        ADJSPB  8
        MOVQW   3, TOS
        BSR     EDIT
        CMPQD   FALSE, ERROR
        BNE     ED_END:W
        MOVQB   FALSE, ASS_BLED         ;ASSEMBLY NOT VALID
        BR      ED_END:W

EDDIS:  ;EDITOR DISPLAY LINE COMMAND
        MOVB    DEC, BASE
        MOVQB   1, R6                   ;LOOP CONTROL SET TO 1
        ADDQD   3, VECIN3
        MOVB    '/', DELIMIT            ;PARAMETER 2 DELMTER
        BSR     LINE_PARS               ;GET FIRST PARAMETER
        CMPQB   TRUE,   A_PARAM         ;CHECK IF FOUND
        BNE     DIDEF:B
        MOVD    PAR_VAL, LINNUM         ;SET TO FOUND VALUE
DIDEF:  CMPQD   FALSE, ERROR
        BNE     COMD_LOOP
        MOVB    ' ', DELIMIT            ;CHECK FOR PARAMETER 2
        BSR     LINE_PARS
        CMPQB   TRUE, A_PARAM
        BNE     DI_ERR:B
        MOVD    PAR_VAL, R6
;       ABSB    R6, R6                  ;NO NO NEGATIVE NUMBER
; DSI-32 assembler won't allow ABSB !!!!
DI_ERR:
        CMPQD   FALSE, ERROR
        BNE     COMD_LOOP
DI_LOOP:                                ;SET THE LINE NUMBER
                                        ;SET UP FOR NEXT LINE
        ADJSPB  8                       ;PUSH DUMMY
        MOVQW   2, TOS                  ;DISPLAY COMMAND NUMBER
        BSR     EDIT
        BSR     BUF_CLR                 ;CLEAN LINE
        MOVD    LINNUM, TEMP4           ;SAVE LINNUM FOR DEBUG INFO
        MOVD    LINNUM, TOS             ;PASS LINE NUMBER
        MOVQB   DEC, BASE               ;LINE NUMBER IN DECIMAL
        BSR     N_TO_ASC                ;FOR CONV TO ASCII
        MOVD    TOS, R4                 ;GET CHR_CNT
        MOVD    LINES, ASM_LIN
        ADDQD   -1, ASM_LIN
        CMPD    LINNUM, ASM_LIN  
        BLT     INDX:B  
        MOVQD   1, R6
        BR      LAST:B
INDX:   ADDQD   1, LINNUM
LAST:   MOVD    '0000', IOBUF           ;SET LINE TO ZEROES
        MOVD    '    ', IOBUF+4         ;SEPERATION SPACES
        ADDR    NUMCH, R5               ;SDDRESS OF SOURCE
        CMPQB   1, R4                   ;MOVE SKEWED TO LELT
        BNE     TWO:B
        MOVB    0(R5), IOBUF+ 3
TWO:    CMPQB   2, R4
        BNE     TRE:B
        MOVW    0(R5), IOBUF + 2
TRE:    CMPQB   3, R4
        BNE     FOU:B
        MOVMB   0(R5), IOBUF + 1, 3
FOU:    CMPQB   4, R4
        BNE     SKE:B
        MOVMB   0(R5), IOBUF + 0, 4
SKE:    CMPQB   FALSE, ASS_BLED         ;IF ASSEMBLY IS VALID
        BEQ     ED_END:W                 ;THEN OUTPUT LINE CODE ADDR
        MOVD    TEMP4, R0
        MOVD    TXTEND, R1
        MOVD    0(R1)[R0:Q], TEMP4      ;GET LINEADDR
        TBITD   31, TEMP4               ;IF BIT 32 THEN NOT A CODE LINE
        BFS     ED_END:W                ;AND DON'T OUTPUT ADDR
        MOVD    TEMP4, TOS              ;PASS LINE ADDRES
        MOVQB   HEX, BASE               ;ADDRESS IN HEX
        BSR     N_TO_ASC                ;FOR CONV TO ASCII
        MOVD    TOS, R4                 ;GET CHR_CNT
        MOVMB   NUMCH, IOBUF+8, 8

ED_END: 
        MOVD    TOS, VECEN              ;GET RETURN MESSAGE FROM EDITOR
        MOVD    TOS, VECIN3              ;IF VECIN 0 THEN NO MESSAGE
        CMPQD   0, VECIN3                ;SO BRANCH OUT TO COMMAND LOOP
        BGE     COMD_LOOP               ;ELSE SET WRITE PARAMETRS
        CMPQD   TRUE, ERROR             ;IF ERROR THE CLEAR BUFFER
        BNE     SH_ALL:B
        BSR     BUF_CLR
SH_ALL: MOVD    VECIN3, R1               ;SOURCE
        SUBD    VECIN3, VECEN
        MOVD    VECEN, R0               ;CHAR COUNT
        ADDR    IOBUF+18, R2            ;DESTINATION
        MOVSB
        BSR     WRIT_LN
        CMPQD   TRUE, ERROR
        BNE     CONT_LOOP:B
        MOVQB   1, R6                   ;CANCEL THE LOOP IF ERROR
CONT_LOOP:
        ACBB    -1, R6, DI_LOOP         ;LOOP TILL DONE
        BR      COMD_LOOP:W
;-----------------------------------------------------------------------
;    A S S E M B L E R    C O N T R O L    P R O C E S S
;
PASS1_MES:      .BYTE   'PASS 1'
PASS2_MES:      .BYTE   'PASS 2'
        
ASMIT:  
        MOVQD   0, A_MOD+4              ;KEEP MOD TABLE NEET
        MOVQD   0, A_PC+4
        MOVQD   0, SBCOUNT              ;INIT SB COUNTER TO 0
        MOVQB   1, SEGMENT              ;INT SEGMENT TO PC CODE AREA
        ADDQD   3, VECIN3                ;POINT TO OPTIONAL PARAMETER
        MOVB    HEX, BASE               ;GET PARAMETERS AS HEX
        BSR     LINE_PARS
        MOVB    DEC, BASE               ;RESET BASE TO DECIMAL FOR START
        MOVD    LINES, R0               ;CHECK FOR MEMORY CONFLICT
        MULD    8, R0                   ;GET SIZE OF DEBUG DATA
        MOVD    TXTEND, R1              ;ADD THAT TO END OF TEXT
        ADDQD   4, R1
        ADDQD   4, R1
        ADDD    R0, R1
        MOVQD   -1, A_MOD               ;SET NOT AUTO MODE
        CMPQD   FALSE, ERROR            ;CHECK FOR VALUE ERROR
        BNE     OUT_ASM:d               ; migry add :D ;
        CMPQB   TRUE, A_PARAM           ;IF NOT A VALUE THEN ABORT
        BEQ     NOT_AUTO:W
        MOVD    R1, R7                  ;CALCULATE MOD TABLE ADDRESS
        ADDR    MODTAB, A_MOD           ;SET MOD TABLE ADDRESS
        ANDD    H'FFFF00, R7            ;IF LESS THAN 64K USE 1/2 PAGE
        CMPD    R7, H'FF00              ;BOUNDRY ELSE USE SYS AREA
        BGE     SYSA:B
        ADDD    H'100, R7
        MOVD    R7, A_MOD
        ADDD    32, R7
SYSA:   ANDD    H'FFFE00, R7
        ADDD    H'200, R7
        MOVD    R7, PAR_VAL             ;PASS ALONG AS PARVAL
        MOVD    R7, A_PC
NOT_AUTO:
        CMPD    PAR_VAL, R1             ;IF CODESTART IS < TEXT AND 
        BLT     BAD_MEM                 ;AND DEBUG DATA THEN ERROR
        MOVD    PAR_VAL, CODESTAR       ;ELSE STORE IT
        MOVD    CODESTAR, PROG_BASE     ;SET PC START FOR ASSEMBLER
        MOVQB   FALSE, ASS_BLED ;EXPECT ABORTED ASSEMBLY

;+++++++++++++
#ifdef DB16000
        BSR     MEM_SIZ         ;GET MEMORY SIXE FOR SYM_TAB ADDR
#endif
;+++++++++++++

;@@@@@@@@@@@@@@
#ifdef THEFORCE
        MOVD    RAMTOP-2,R0       ; TheForce top of memory (0x00bffe)
#endif
;@@@@@@@@@@@@@@

        MOVD    R0, A_SP        ;SAVE AS AUTO SP VAL
        ADDQD   -3, A_SP        ;ALIGN TO double           (0x00bffc)
        MOVQD   -1, -3(R0)      ;TAG TABLE AS EMPTY
        MOVD    R0, SYM_TAB     ;PASS ADDR TO ASSEMBLER
        MOVQB   PASS1, PASS_NUM
        BSR     BUF_CLR         ;CLEAR BUFFER
        MOVMB   PASS1_MES, IOBUF, 6
        BSR     WRIT_LN         ;OUTPUT PASS 1
        BSR     ALISTING        ;DO LISTING
PASS_2: MOVQD   0, ERR_CNT
        MOVD    CODESTAR, R7    ;CODESTART
        ADDR    TEXT, R6        ;VECIN3
        ADDR    TEXT, R5        ;[DTEXT START
        MOVD    LINES, COUNTER
        MOVQD   0, ASM_LIN      ;LINE OUNTER
        CMPQD   0, LINES        ;CHECK FOR INSANITY
        BGE     INSANE          ;AVIOD ENDLESS LOOPS
NEXT_LINE:
        BSR     BUF_CLR
        MOVB    DEC, BASE       ;DEFAULT BASE FOR ASSEMBLY IS DECIMAL
        MOVD    ASM_LIN, TOS            ;PASS LINE NUMBER
        BSR     N_TO_ASC                ;FOR CONV TO ASCII
        MOVD    TOS, R4                 ;GET CHR_CNT
        MOVD    '0000', IOBUF           ;SET LINE TO ZEROES
        CMPQB   1, R4                   ;MOVE SKEWED TO LELT
        BNE     ATWO:B
        MOVB    NUMCH, IOBUF+ 3
ATWO:   CMPQB   2, R4
        BNE     ATRE:B
        MOVW    NUMCH, IOBUF + 2
ATRE:   CMPQB   3, R4
        BNE     ASKE:B
        MOVMB   NUMCH, IOBUF + 1, 3
ASKE:   CMPQB   PASS1, PASS_NUM         ;IF PASS1 THEN DO NOT OUTPUT ADDR
        BEQ     NO_ADD:B
        MOVB    HEX, BASE
        MOVQB   TRUE, LEADZERO
        MOVD    R7, TOS                 ;CODE ADDRES       
        BSR     N_TO_ASC                ;FOR CONV TO ASCII
        MOVD    TOS, R4                 ;GET CHR_CNT
        MOVQB   FALSE, LEADZERO
        MOVMB   NUMCH, IOBUF+6 ,8
NO_ADD: ADDR    IOBUF+16, R0
        MOVQD   0, R2                   ;SET SANITY CONTROL
XXX:    CMPB    CR, 1(R5)
        BEQ     ENDL:B
        MOVB    0(R5), 0(R0)            ;PLACE TEXT BYTE INTO 
        ADDQD   1, R0                   ;OUTPUT BUFFER
        ADDQD   1, R5                   ;INCREMENT ALL POINTERS
        ADDQD   1, R2                   ;CHECK IF LOOP IS EXCESSIVE
        CMPB    78, R2                  ;IF IT IS THEN GO INSANE
        BLT     INSANE
        BR      XXX
ENDL:   MOVB    0(R5), 0(R0)            ;MOVE FINAL BYTE
        MOVQD   FALSE, ERROR
        ADDQD   1, R5
        MOVD    R7, R4          ;SAVE THIS CODE START
        MOVB    DEC, BASE       ;ASSEMBLY BASE
        MOVD    R7, TOS         ;CODESTART
        MOVD    R6, TOS         ;VECIN3
        MOVD    R5, TOS         ;ENDLIN
        BSR     MONASM
        MOVD    TOS, ASM_ERR    ;ERROR MESSAGE
        MOVD    TOS, R7         ;NEXT ADDR FOR CODE
        CMPQD   FALSE, ASM_ERR  ;IF ERROR LINE THEN OTUPUT ADDR
        BNE     CODEL:B
        CMPD    R4, R7          ;IF ADDR IS UNCHANGED THEN THIS WAS A
        BNE     CODEL:B         ;COMMENT LINE 
        MOVD    '    ', IOBUF+6 ;CANCEL ADDR VALUE
        MOVD    '    ', IOBUF+10
CODEL:  BSR     WRIT_LN         ;OUT PUT THE LINE
        BSR     ALISTING        ;DO LISTING
        MOVQB   TRUE, A_PARAM   ;FLAG THE LINE AS ERROR FREE
        MOVD    ASM_ERR, ERROR  ;OUT PUT ASM16 ERROR IF ANY
        BSR     ERR_MES
        ADDQD   1, R5           ;START OF NEXT LINE
        MOVD    R5, R6          ;SET START
        MOVD    ASM_LIN, R0
        MOVD    TXTEND, R1
        CMPQB   PASS1, PASS_NUM         ;IF PASS 2 THEN CREATE DEBUG INFO
        BEQ     ENTERL:W                ;PASS 1 MAKE SYMBOLIC DEBUG DATA
        CMPQB   2, SEGMENT      ;SKIP IF SB SEG
        BEQ     NO_INFO:W
        MOVQD   -1, 0(R1)[R0:Q] ;NO LABEL IN PC LINE/COMMENT LINE       
        CMPD    '    ', IOBUF+6 ;IF PC ADDR CANCELED THEN NOCODE LINE
        BEQ     ENTR_SG:B       ;ENTER -1 INTO DEBUG TABLE
        MOVD    R4, 0(R1)[R0:Q] ;CREATE TABLE OF DEBUG INFO     
        BR      ENTR_SG:B       ;ENTER SYMBOL IF ANY
ENTERL: MOVQD   -1, 0(R1)[R0:Q] ;NO LABEL IN  LINE      
        CMPQB   0, LABEL        ;IF LABEL NOT CHR(0) THEN IS LABEL 
        BEQ     ENTR_SY:B
        CMPQB   1, SEGMENT      ;IF PC SEG THEN 
        BEQ     ENTR_SY:B               ;NO ENTRY IF PC SECTION
        MOVD    SBC, 0(R1)[R0:Q];STATIC BASE DEBUG DATA
ENTR_SY:MOVW    LABEL, 4(R1)[R0:Q]      ;ENTER LINE LABEL IF ANY        
ENTR_SG:MOVB    SEGMENT, 7(R1)[R0:Q]    ;ENTER LABEL TYPE       
NO_INFO:ADDQD   1, ASM_LIN
        BSR     BUF_CLR         ;CLEAR BUFFER FOR HEX CODE OUTPUT
        MOVQB   TRUE, LEADZERO
        MOVQB   HEX, BASE
        ADDR    IOBUF+16, R1
        CMPD    R4, R7          ;IF CODE ADDR IS UNCHANGED THEN DO NOT
        BEQ     NO_CODE_OUT:W   ;OUTPUT CODE (ERROR OR COMMENT LINE ENCOUNTERED
        CMPQB   PASS1, PASS_NUM         ;IF PASS1 THEN NO CODE OUT
        BEQ     NO_CODE_OUT:W
        CMPQB   TRUE, A_PARAM   ;IF LINE HADE ERROR THEN NO CODE OUT
        BNE     NO_CODE_OUT:W
        MOVQD   0, R2
C_LOOP: MOVZBD  0(R4), TOS      ;DURING ASSEMBLY)
        BSR     N_TO_ASC        
        CMPQD   2, TOS
        MOVW    NUMCH+6, 0(R1)
        ADDQD   1, R4
        ADDQD   2, R1
        ADDQD   1, R2
        CMPB    22, R2
        BGE     OUT_C:B
        BSR     WRIT_LN
        BSR     ALISTING        ;DO LISTING
        BSR     BUF_CLR
        ADDR    IOBUF+16, R1
        MOVQD   0, R2
OUT_C:  CMPD    R4, R7
        BLT     C_LOOP
        CMPQB   TRUE, A_PARAM           ;IF ERROR IN LINE THEN
        BNE     NO_CODE_OUT:B           ;NO CODE OUT
        BSR     WRIT_LN
        BSR     ALISTING        ;DO LISTING
NO_CODE_OUT:
        ACBD    -1, COUNTER, NEXT_LINE
        CMPQB   PASS2, PASS_NUM         ;IF PASS 2 THEN ASSEMBLY FINI
        BEQ     DID_ASM:B        
        CMPQD   FALSE, ERR_CNT          ;IF ERROR THEN ABORT PASS2
        BNE     DID_ASM:B
        BSR     BUF_CLR                 ;ELSE OURPUT AND START PASS2
        MOVMB   PASS2_MES, IOBUF, 6
        BSR     WRIT_LN
        BSR     ALISTING        ;DO LISTING
        MOVQB   PASS2, PASS_NUM         ;SET PASS 2 FLAG AND DO IT
        BR      PASS_2
END_MES:        .BYTE   'END_ASSEMBLY'
END_MESA:       .BYTE   'ERRORS'
DID_ASM:
        BSR     BUF_CLR
        MOVMB   END_MES, IOBUF, 12      ;SET END MESSAGE INTO BUFFER
        MOVMB   END_MESA, IOBUF+30, 6
        MOVQB   DEC, BASE       
        MOVD    ERR_CNT, TOS
        BSR     N_TO_ASC
        MOVD    TOS, R0
        MOVD    NUMCH, IOBUF+15
        BSR     WRIT_LN
        BSR     ALISTING        ;DO LISTING
        CMPQD   0, ERR_CNT
        BNE     OUT_ASM:B
        CMPQD   -1, A_MOD       ;CHECK FOR AUTO MODE
        BEQ     NOT_A1:B
        ANDD    H'FFFE00, R7    ;R7 IS LAST ADDR
        ADDD    H'200, R7
        MOVD    R7, A_SB        ;SB START AT PAGE       
NOT_A1: MOVQB   TRUE, ASS_BLED
OUT_ASM:
        BR      COMD_LOOP:W
;------------------------------------------------------------------------------
;   T A P E    I / O    P R O C E S S
;
;       TAPE READ ERROR MESSAGES
T_OUT:  .BYTE   'TIM_OUT'
B_FRM:  .BYTE   'BAD_FRM'
E_CRC:  .BYTE   'CRC_ERR'
                                ;SEE TIO.ASM FOR MORE INFO ON CYCLE TIMINGS
TAPER:  ;TAPE READ
        MOVB    HEX, BASE               ;GET PARAMETERS AS HEX
        MOVQB   FALSE, TEMP2            ;ASSUME NO PARAMETER
        ADDQD   3, VECIN3               ;CHECK FOR PARRAMETER
        BSR     LINE_PARS
        CMPQB   TRUE, A_PARAM           ;IF PARAMETER IS PRESENT THEN
        BEQ     BINLOAD:B               ;LOAD DATA AT THAT ADDRESS
        ADDR    TEXT, R0
        MOVD    R0, TOS
        BR      LOADT:B                 ;LOAD TEXT BUFFER
BINLOAD:
        MOVD    TXTEND, R0              ;CHECK FOR
        MOVD    LINES, R1               ;TEXT PLUS DEBUG RANGE
        MULD    8, R1
        ADDD    R1, R0  
        ADDD    8,R0
        CMPD    PAR_VAL, R0             ;CHECK FOR VALID SPACE
        BLE     BAD_MEM                 ;TEXT IS SAFE AND SO IS DEBUG DATA 
        MOVQB   TRUE, TEMP2             ;DOING A BIN LOAD
        MOVD    PAR_VAL, TOS
        ;
LOADT:  ADDR    ERROR, TOS              ;ERROR RETURN
        BSR     TREAD                   ;START TAPE READ ROUTINE
        MOVD    TOS, TEMP3              ;GET LAST ADDR LOADED
        CMPQD   ASYNC, ERROR            ;CHECK FOR VERY BAD ERROR
        BNE     FORMC:B                 ;A TIMOUT?
        ADDR    T_OUT, ERROR
        BSR     ERR_MES
        BR      COMD_LOOP
FORMC:  CMPQD   FREC, ERROR
        BNE     FIT:B                   ;CHECK FOR BAD TAPE FORMAT
        ADDR    B_FRM, ERROR
        BSR     ERR_MES
        BR      COMD_LOOP
FIT:    CMPQB   TRUE, TEMP2
        BEQ     ABIN:w                  ;DID A BINARY LOAD
        MOVD    TEMP3, TXTEND           ;ELSE SET END OF TEXT BUFFER;
        ADDR    TEXT, R0                ;SET LINE NUMBER
        MOVD    TXTEND, R1
        MOVQD   0, LINES                ;SET LINES TO START
MOL:    CMPQB   0, 0(R0)                ;CHECK FOR NUL FILLER
        BEQ     ENDT:B 
        CMPB    CR, 0(R0)               ;COUNT CR FOR RANGE OF
        BNE     NOTL:B                  ;TEXT BUFFER. 1 CR = 1 LINE
        ADDQD   1, LINES                ;ADD TO LINES
NOTL:   ADDQD   1, R0
        CMPD    R0, R1
        BLE     MOL
ENDT:   MOVD    R0, TXTEND              ;SET TRUE TEXT END
        MOVQD   0, LINNUM               ;START LINE
        MOVQB   FALSE, ASS_BLED         ;INITIALIZE TEXT NOT ASSEMBLED
ABIN:   CMPQD   RCRC, ERROR             ;CHECK FOR ERROR
        BEQ     ECRC_:B
        BR      COMD_LOOP:W
ECRC_:  ADDR    E_CRC, ERROR
        BSR     ERR_MES
        BR      COMD_LOOP

TAPEW:  ;TAPE WRITE PROCESS
        MOVD    CYCLE, R7               ;SET DEFAULT BAUD
        ADDQD   3, VECIN3
        CMPB    '@', 0(VECIN3)           ;CHECK FOR BAUD SETTING
        BNE     NOBAUD:B
        ADDQD   1, VECIN3                ;START OF BAUD VALUE
        MOVB    DEC, BASE               ;IN DECIMAL
        BSR     LINE_PARS               ;GET IT
        CMPQB   FALSE, A_PARAM
        BEQ     NOT_CMD
        MOVD    PAR_VAL, R7
NOBAUD: MOVB    HEX, BASE               ;GET ADDRS AS HEX
        BSR     LINE_PARS               ;GET START ADDR
        CMPQD   FALSE, ERROR
        BNE     NOT_CMD
        CMPQB   FALSE, A_PARAM          ;IF NOT ADDR THEN DO TEXT WRITE
        BEQ     WTEXT:W
        MOVD    PAR_VAL, TEMP2          ;SAVE START ADDR
        BSR     LINE_PARS               ;GET SECOND ADDR
        CMPQD   FALSE, ERROR
        BNE     NOT_CMD
        CMPQB   FALSE, A_PARAM          ;IF NO SECOND PARAMETER THEN NOT A 
        BEQ     NOT_CMD                 ;COMMAND
        CMPD    TEMP2, PAR_VAL          ;CHECK FOR GOT SEQUENCE
        BGT     NOT_CMD                 ;
        ADDR    TEXT, R0 
        CMPD    TEMP2, R0               ;CHECK FOR VALID RAM DUMP
        BLT     NOT_CMD
        MOVD    TEMP2, TOS              ;PASS START ADDR
        MOVD    PAR_VAL, TOS            ;PASS LAST ADDR
        BR      T_W:B   
WTEXT:  ADDR    TEXT, R0
        MOVD    R0,TOS                  ;START OF TEXT DATA
        MOVD    TXTEND, TOS             ;END OF TEXT DATA
T_W:    MOVD    R7, TOS                 ;BAUD RATE
        ;       ======
        BSR     TWRITE
        ;       ======
        BR      COMD_LOOP
        .endseg
;
;---------------------------------------------------------------------------

RADIX:                                  ;SELECT RADIX COMMAND
        ADDQD   3, VECIN3
        CMPB    'H', 0(VECIN3)
        BEQ     SHEX:B
        CMPB    'h', 0(VECIN3)
        BEQ     SHEX:B
        CMPB    'D', 0(VECIN3)
        BEQ     SDEC:B
        CMPB    'd', 0(VECIN3)
        BEQ     SDEC:B
        BR      NOT_CMD
SHEX:   MOVQB   HEX, MON_BASE
        BR      COMD_LOOP
SDEC:   MOVQB   DEC, MON_BASE   
        BR      COMD_LOOP
        
;
;---------------------------------------------------------------------------
;       RS-232 PORT ACCESS COMMANDS
;

;       PORT ACCESS MESSAGES
BYT_ZOUT: .BYTE 'BYTES_WRITTEN     '    ;COMPLETION MESSAGE FOR WRITE
BYT_ZIN:  .BYTE 'BYTES_READ        '    ;    "          "     "  READ 
BAD_SYN:  .BYTE 'BAD_SYN'               ;HANDSHAKE ERROR MESSAGE        

;ROUTINE TO DO COMMON PARSING
ZCOM:   MOVB    HEX, BASE               ;INTERPRET NUMBERS AS HEX
        ADDQD   2, VECIN3                ;START OF COMMON FEATURES
        MOVQD   0,TEMP4                 ;SET TO HANDSHAKE MODE
        CMPB    'S',0(VECIN3)            ;CHECK IF S IS SPECIFIED
        BEQ     ZPAR1:B                 ;YESY THEN GET FIRST PARAM
        CMPB    's',0(VECIN3)            ;CHECK FOR LOWER CASE
        BEQ     ZPAR1:B                 ;YES, THEN GET FIRST PARAM
        ORB     1,TEMP4                 ;NOW SET NO HANDSHAKE MODE
        CMPB    'F',0(VECIN3)            ;YES, THEN GET FIRST PARAM
        BEQ     ZPAR1:B                 ;ELSE CHECK FOR LOWER CASE
        CMPB    'f',0(VECIN3)
        BEQ     ZPAR1:B                 ;IF NO MATCH THEN
ZERR1:  MOVD    TOS,R0                  ;CLEAR STACK OF RETURN ADDR
        BR      NOT_CMD                 ;AND DO ERROR RETURN
ZPAR1:  ADDQD   1,VECIN3                 ;POINT TO NEXT ELEMENT
        CMPB    'm',0(VECIN3)            ;GO WITH DEFAULT IF SPACE
        BEQ     ZPAR2:B
        CMPB    'M',0(VECIN3)            ;GO WITH DEFAULT IF SPACE
        BEQ     ZPAR2:B
        ORB     2,TEMP4                 ;SET AND CHECK FOR PORT 1 (AUX)
        CMPB    'A',0(VECIN3)            ;YES THE GET NEXT PARAM 
        BEQ     ZPAR2:B
        CMPB    'a',0(VECIN3)            ;CHECK FOR LOWER CASE
        BNE     ZERR1                   ;IF NO MATCH THEN NOT COMMAND
ZPAR2:  ADDQD   2,VECIN3                 ;START OF LAST TWO PARAM
        BSR     LINE_PARS
        CMPQB   FALSE,A_PARAM           ;IF NO PARAMETERS THEN DONE
        BEQ     ZDOIT:W                 ;ELSE CHECK FOR PARAM ERROR
        CMPQD   FALSE,ERROR             ;IF NO ERROR PROCEED TO NEXT PARAM
        BEQ     ZOK1:B
ZERR2:  MOVD    TOS,R0                  ;CLEAR STACK
        BR      COMD_LOOP
ZOK1:   ORB     4,TEMP4                 ;BINARY DATA TRANSFER   
        MOVD    PAR_VAL,TEMP2           ;ENTER PARAM AS START ADDR
        BSR     LINE_PARS               ;GET SECOND PARAMETER
        CMPQB   TRUE,A_PARAM            ;NO, THEN NOT A COMMAND
        BNE     ZERR1
        CMPQD   FALSE,ERROR             ;VALUE ERROR?
        BNE     ZERR2                   ;YES
        MOVD    PAR_VAL,TEMP3           ;ELSE SAVE PARAMETER
        CMPD    TEMP2,TEMP3             ;VALID ORDER?
        BGE     ZERR1                   ;NO, THEN ERROR
        MOVD    LINES,R0                ;CHECK THAT GIVEN ADDRESS
        MULD    8,R0                    ;RANGE DOES NOT CONFLICT WITH
        MOVD    TXTEND,R1               ;EDIT BUFFER OR
        ADDD    8,R1                    ;DEBUG DATA
        ADDD    R0,R1
        CMPD    TEMP2,R1                ;IF START IS LESS THAN NEEDE MEM
        BGT     ZDOIT:B                 ;THEN OK, ELSE
        MOVD    TOS,R1                  ;CLEAR STACK
        BR      BAD_MEM
ZDOIT:  TBITB   1,TEMP4
        BFS     ZECHO:d                 ; migry add :D ;
        MOVQB   TRUE,NOTECHO
ZECHO:  RET     0

;-----------------------------------------------------------------------------
;               THE WRITE ROUTINE
;
ZOUT:   BSR     ZCOM
        MOVQD   0,R4
        TBITB   2,TEMP4                 ;IS THIS A DATA WRITE?
        BFS     ZOBIN:B                 ;NO, THEN SET UP EDIT BUFFER 
        ADDR    TEXT,TEMP2              ;PARAMETERS
        MOVD    TXTEND,TEMP3            ;START OF TEXT AND,
        CMPD    TEMP2,TEMP3             ;IS THERE SOMETHING IN BUFFER?
        BGE     NOT_CMD                 ;NO, THEN ERROR
        ADDQD   -1,TEMP3                ;END OF TEXT
                                        ;TEMP4 PORT NUMBER
                                        ;TEMP2 START
                                        ;TEMP3 END
ZOBIN:                                  ;READ HANSHAKE
        TBITB   0,TEMP4
        BFS     ZOFAST:d                ; migry add :D ;
        MOVQD   READ, R0                ;SVC INPUT
        ADDR    IOBUF, R1               
        MOVQD   -2, R2
        MOVQD   MAIN, R3
        MOVQB   TRUE,NOTECHO
        TBITB   1,TEMP4
        BFC     ZO0:B
        MOVQD   AUX,R3
        MOVQB   FALSE,NOTECHO
ZO0:    SVC
        CMPB    '*',IOBUF
        BEQ     ZO5:B
        ADDR    BAD_SYN,ERROR           ;ELSE OUTPUT ERROR MESSAGE
        BSR     ERR_MES
ZOFAST:
ZO5:    BSR     BUF_CLR                 ;CLEAR BUFFER
        ADDR    IOBUF,R7
        MOVB    '>',0(R7)               ;START OF DATA
        ADDQD   1,R7                    ;POINT TO NEXT BUFFER SPACE
        MOVB    16,R1
ZO1:    CMPD    TEMP2,TEMP3             ;IF NOT DONE THEN
        BLE     ZO2:B
        MOVQB   0,R0
        BR      ZO3:B
ZO2:    MOVB    0(TEMP2),R0
ZO3:    MOVZBD  R0,TOS
        MOVQB   HEX,BASE
        MOVQB   TRUE,LEADZERO   
        BSR     N_TO_ASC
        MOVQB   FALSE,LEADZERO  
        MOVD    TOS,R0
        MOVW    NUMCH+6,0(R7)
        ADDQD   1,TEMP2
        ADDQD   2,R7    
        ACBB    -1,R1,ZO1
        MOVB    CR,0(R7)
        MOVQD   WRITE, R0       ;THRU SVC FUNCTION
        ADDR    IOBUF, R1       ;LINE LENGTH IS 80
        MOVZBD  34, R2          ;USED WITH BUF CLR ROUTINE
        MOVQD   MAIN, R3
        TBITB   1,TEMP4
        BFC     ZO4:B
        MOVQD   AUX,R3
ZO4:    SVC
        ADDQD   1,R4
        MOVB    '.',IOBUF
        MOVQD   WRITE, R0       ;THRU SVC FUNCTION
        ADDR    IOBUF, R1       ;LINE LENGTH IS 80
        MOVZBD  1, R2           ;USED WITH BUF CLR ROUTINE
        CMPD    R4,60
        BLT     ZO11:B
        MOVB    CR,IOBUF+1
        MOVQD   0,R4
        ADDQD   1,R2    
ZO11:   MOVQD   MAIN, R3
        TBITB   1,TEMP4
        BFC     ZO10:d          ; migry add :D ;
        SVC
ZO10:   CMPD    TEMP2,TEMP3
        BLE     ZOBIN
        TBITB   0,TEMP4
        BFS     ZOFAST1:d       ; migry add :D ;
        MOVQD   READ, R0        ;SVC INPUT
        ADDR    IOBUF, R1               
        MOVQD   -2, R2
        MOVQD   MAIN, R3
        MOVQB   TRUE,NOTECHO
        TBITB   1,TEMP4
        BFC     ZO6:B
        MOVQB   FALSE,NOTECHO
        MOVQD   AUX,R3
ZO6:    SVC
        CMPB    '*',IOBUF
        BEQ     ZO7:B
        ADDR    BAD_SYN,ERROR   ;ELSE OUTPUT ERROR MESSAGE
        BSR     ERR_MES
ZOFAST1:
ZO7:    BSR     BUF_CLR
        ADDR    IOBUF,R7
        MOVB    '<',0(R7)
        MOVB    CR,1(R7)
        MOVQD   WRITE, R0       ;THRU SVC FUNCTION
        ADDR    IOBUF, R1       ;LINE LENGTH IS 80
        MOVZBD  2, R2           ;USED WITH BUF CLR ROUTINE
        MOVQD   MAIN, R3
        TBITB   1,TEMP4
        BFC     ZO8:B
        MOVQD   AUX,R3
ZO8:    SVC
        BR      COMD_LOOP               ;DONE

;-------------------------------------------------------------------------
;       PORT READ ROUTINE
;
ZIN:    BSR     ZCOM
        TBITB   2,TEMP4                 ;IS THIS A DATA WRITE?
        BFS     ZIST:B                  ;NO, THEN SET UP EDIT BUFFER 
        ADDR    TEXT,TEMP2              ;PARAMETERS
        MOVD    H'FFFFF,TEMP3           ; TEMP4 PORT NUMBER
ZIST:   MOVQD   0,COUNTER                       ; TEMP2 START
        MOVQD   0,R4
                                        ; TEMP3 END
ZIBIN:  
        MOVQD   READ, R0                ;SVC INPUT
        ADDR    IOBUF, R1               
        MOVD   -40, R2
        MOVQD   MAIN, R3
        MOVQB   TRUE,NOTECHO
        TBITB   1,TEMP4
        BFC     ZI0:B
        MOVQB   FALSE,NOTECHO
        MOVQD   AUX,R3
ZI0:    SVC
        ADDR    IOBUF,R7
        CMPB    '<',0(R7)
        BEQ     ZI100:W
        CMPB    '>',0(R7)
        BEQ     ZI1:B
        ADDR    BAD_SYN,ERROR           ;ELSE OUTPUT ERROR MESSAGE
        BSR     ERR_MES
ZI1:    ADDQD   1,R7
        MOVB    16,R6

ZI4:    MOVD    '    ',IOBUF2
        MOVD    '    ',IOBUF2+3
        MOVB    'H',IOBUF2
        MOVB    "'",IOBUF2+1
        MOVW    0(R7),IOBUF2+2
        MOVB    CR,IOBUF2+4
        ADDR    IOBUF2,R5
        MOVD    R5,TOS
        ADDQD   3,R5
        MOVD    R5,TOS
        BSR     A_NUM   
        MOVD    TOS,R0
        CMPQD   FALSE,ERROR
        BEQ     ZI8:B
        ADDR    B_FRM, ERROR
        BSR     ERR_MES
        BR      COMD_LOOP
ZI8:    MOVB    R0,0(TEMP2)
        CMPB    CR,R0
        BNE     ZI11:B
        ADDQD   1,COUNTER
ZI11:   ADDQD   1,TEMP2
        ADDQD   2,R7
        CMPD    TEMP2,TEMP3
        BGT     ZI200:W
        ACBB    -1,R6,ZI4
        TBITB   0,TEMP4
        BFS     ZIFAST:d        ; migry add :D ;
;----
        ADDQD   1,R4
        MOVB    '.',IOBUF
        MOVQD   WRITE, R0       ;THRU SVC FUNCTION
        ADDR    IOBUF, R1       ;LINE LENGTH IS 80
        MOVZBD  1, R2           ;USED WITH BUF CLR ROUTINE
        CMPD    R4,60
        BLT     ZI21:B
        MOVB    CR,IOBUF+1
        MOVQD   0,R4
        ADDQD   1,R2    
ZI21:   MOVQD   MAIN, R3
        TBITB   1,TEMP4
        BFC     ZI22:B
        SVC
ZI22:
        BSR     BUF_CLR
        ADDR    IOBUF,R7
        MOVB    '*',0(R7)
        MOVB    CR,1(R7)
        MOVQD   WRITE, R0       ;THRU SVC FUNCTION
        ADDR    IOBUF, R1       ;LINE LENGTH IS 80
        MOVZBD  2, R2           ;USED WITH BUF CLR ROUTINE
        MOVQD   MAIN, R3
        TBITB   1,TEMP4
        BFC     ZI9:B
        MOVQD   AUX,R3
ZI9:    SVC
ZIFAST:
        BR      ZIBIN
ZI100:  TBITB   2,TEMP4
        BFS     ZI200:d         ; migry add :D ;
        MOVD    TEMP2,TXTEND
        MOVQD   0,LINNUM
        MOVD    COUNTER,LINES
        MOVQB   FALSE,ASS_BLED
ZI200:
        TBITB   0,TEMP4 
        BFS     ZI40:d          ; migry add :D ;    
        ADDR    IOBUF,R7
        MOVB    '*',0(R7)
        MOVB    CR,1(R7)
        MOVQD   WRITE, R0       ;THRU SVC FUNCTION
        ADDR    IOBUF, R1       ;LINE LENGTH IS 80
        MOVZBD  2, R2           ;USED WITH BUF CLR ROUTINE
        MOVQD   MAIN, R3
        TBITB   1,TEMP4
        BFC     ZI50:B
        MOVQD   AUX,R3
ZI50:    SVC
ZI40:
        BR      COMD_LOOP               ;DONE

;@@@@@@@@@@@@@@
#ifdef THEFORCE
;@@@@@@@@@@@@@@
ENINTS:
        MOVB    TRCRI,STEPFLG  
        MOVQD   1,STPCNT        ; STEPCOUNT:=1
        SPRW    PSR,SXPSR       ; SAVE PSR
        BISPSRW PSRI            ; enable maskable interrupts
        NOP
        NOP
        SPRW    PSR,SXPSR       ; SAVE PSR
        NOP
        NOP
        BR      COMD_LOOP       ;DONE

; Add new command to zero tape and fill memory with known values (followed by reset)
ZMEM:
        ADDR    @TAPE_SAV,R5    ; start address of virtual tape
        MOVD    0xfff,R4        ; zero first 4k bytes
FILLA:
        MOVQB   0,0(R5)[R4:B]
        ACBD    -1, R4, FILLA
        MOVQB   0,0(R5)[R4:B]
        ;
        ; fill memory with 0xaa to help with debug of memory usage
        MOVD    RAMBOT,R5    
        MOVD    (RAMTOP-RAMBOT)-2,R4 ; LENGTH OF RAM IN bytes
FILLM:
        MOVB    0xaa,0(R5)[R4:B]
        ACBD    -1, R4, FILLM
        MOVB    0xaa,0(R5)[R4:B]
        JUMP    @0              ; RESET!
#endif

ATR:
        ADDQD   2,VECIN3
        CMPB    CR,0(VECIN3)
        BEQ     AT01
        ADDQD   1,VECIN3
        BSR     LINE_PARS
        CMPQB   TRUE,A_PARAM            ;NO, THEN NOT A COMMAND
        BNE     NOT_CMD
        CMPQD   FALSE,ERROR             ;VALUE ERROR?
        BNE     NOT_CMD                 ;YES
        MOVD    PAR_VAL,R0              ;ELSE SAVE PARAMETER
        CMPQD   -1,R0
        BEQ     NOT_CMD
        BR      AT02:B
AT01:   MOVQD   -1,R0
AT02:   BSR     INITAUXU                ;initialise second UART channel
        BR      COMD_LOOP               ;DONE

ATM:
        ADDQD   2,VECIN3
        CMPB    CR,0(VECIN3)
        BEQ     ATMX:d                  ; migry add :D ;
        ADDQD   1,VECIN3
        BSR     LINE_PARS
        CMPQB   TRUE,A_PARAM            ;NO, THEN NOT A COMMAND
        BNE     NOT_CMD
        CMPQD   FALSE,ERROR             ;VALUE ERROR?
        BNE     NOT_CMD                 ;YES
        MOVD    PAR_VAL,MEMSIZ          ;ELSE SAVE PARAMETER
        BR      COMD_LOOP
ATMX:
        MOVQD   -1,MEMSIZ
        BR      COMD_LOOP               ;DONE

; end of ahelpio.32k
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; start of asub.32k

SRDLIN:
        ;++++++++++++++++
        MOVXBW  (-LINLIM),TOS
        MOVQB   TRMA,TOS        ;   RDLIN (-LINLIM,NDTRM,INBUF)
        ADDR    INBUF(R7),TOS                   
        ;migry;SPRD    MOD,TOS         ;{FOR CXP}              
        BSR     RDLIN:B
        ;----------------
        ADDR    INBUF(R7),R5    ;   DTRM.SCN :=1
        MOVZWD  TOS,INLM(R7)
        ADDD    R5,INLM(R7)     ;   DTRM.INLM:=RDN
        RET     0
;
;
;    R D L I N       ( READ LIN PROCEDURE  )
;
;       LOCAL CONSTANTS
;
;
;
;
;       ARGUMENTS DEFINITIONS
;
;
RDLIN:  .PROC                           ; PROCEDURE DEFINITION
RDN:    .BLKW   ;WORD                   ; RDN : INTEGER*2 MAX # OF BYTES
RDTRM:  .BLKB   ;BYTE                   ; RDTRM : INTEGER*1 TERMINAL #
RDVEC:  .BLKD   ;DOUBLE                 ; VAR RDVEC : CHAR[1..RDN]
;
;       LOCAL VARIABLES
;
        .RETURNS
        .BLKW   ;WORD                   ; RETURN # OF READ BYTES
        .VAR    [R1,R2,R3]
        .BEGIN
          MOVQB   FALSE,R1                ; READLNF:=FALSE
          CMPQW   0,RDN                   ; IF RDN<= THEN
          BLE     RDLINA:B                ; BEGIN
          MOVQB   TRUE,R1                 ;   READLNF:=TRUE;
          NEGW    RDN,RDN                 ;   RDN:=-RDN;
                                          ; END
RDLINA: 
          MOVQD   0,R2                    ; N:=0
                                        ; REPEAT
RDLIN1: 
          ;++++++++++++++++
          MOVQW   TRUE,TOS                ; {RDCHR (CHR,FALSE,RDTRM)}
          MOVB    RDTRM,TOS
          ;migry;SPRD    MOD,TOS
          BSR     RDCHR
          ADJSPB  -1                      ; {REMOVE ENDF}
          MOVB    TOS,R3                  ; CHR:=RDCHR (FALSE,RDTRM);
          ;----------------
          MOVB    RDTRM,TOS
          CMPB    DELETE,R3
          BNE     RDLIN3:b 
          MOVB    BACKSP,R3
RDLIN3:   BSR     DOECHO:W                ; DOECHO(CHR,RDTRM)
          CMPQB   TRMA, RDTRM
          BNE     RDLIN2:W
          CMPB    BACKSP,R3
          BNE     RDLIN2:B
          CMPQB   TRUE,R1                 ;   IF READLNF
          BNE     RDLIN2:B                ;    THEN
          CMPQD   0,R2                    ;     IF N> 0
;       BGE     RDLIN2:B                ;       THEN
          BGE     RDLINEX:B               ;       THEN
          ADDQD   -1,RDVEC                ;         N:=N-1;
          ADDQD   -1,R2                   ; ELSE
          BR      RDLIN1                  ; BEGIN
RDLIN2:   MOVB    R3,0(RDVEC)             ;    VEC(N):=CHR;
          ADDQD   1,RDVEC                 ;    N:=N+1;
          ADDQB   1,R2                    ; END;
          CMPW    RDN,R2                  ; UNTIL
          BLE     RDLINEX:B               ;     (N>=RDN)
          CMPQB   TRUE,R1                 ;   OR (READLNF AND (CHR=CR))
          BNE     RDLIN1
          CMPB    R3,CR
          BNE     RDLIN1
RDLINEX:
          MOVW    R2,RDN                  ; RDLIN:=N
        .ENDPROC
;
;    D O E C H O  ( EC_CHR,EC_TRM)
;        EC-CHR  INPUT : BYTE IN R3 {CHAR TO BE ECHO}
;        EC_TRM  INPUT : BYTE  {TERMINAL NUMBER}
;    FUNCTION  - CHECK IF ECHOB OF THIS TERMINAL ON THEN ECHO
;                IF EC_CHR IS BACK_SPACE ECHO WITH SPACE TO
;                IF EC_CHR IS CR AND ECHOLF BIT ON ECHO WITH CR LF
;
;
DOECHO: .PROC           ; PROCEDURE DOECHO (EC_CHR,EC_TRM : BYTE)
EC_TRM: .BLKB   ;BYTE
        .VAR    [R1,R3]
        .BEGIN
        MOVB    OPHND,R1        ; {SAVE OPMOD OF TERM IN R1 BITS 0..3}
        CMPQB   TRMA,EC_TRM
        BNE     ECEX:W
        CMPQB   TRUE,NOTECHO
        BEQ     ECEX:w
;       LSHB    -4,R1
;EC2:   TBITB   ECHOB,R1        ; IF ECHO THEN
;       BFC     ECEX:W          ; BEGIN
EC3:    
        TBITB   2, R1           ;IF BIT 2 SET
        BFC     DOALL:B         ;THEN ECHO CR WITH CR
        CMPB    CR, R3          ;ELSE ECHO CR WITH SPACE
        BNE     DOALL:B
        MOVB    ' ', R3 
DOALL:  
        ;++++++++++++++++
        MOVQB   TRUE,TOS
        MOVB    R3,TOS
        MOVB    EC_TRM,TOS      ;   PRCHR (TURE,EC_CHR,EC_TRM)
        ;migry;SPRD    MOD,TOS
        MOVB    0x81,TOS
        BSR     PRCHR
        CMPQB   TRUE,TOS        ;   {ADJUST STACK}
        ;----------------
        CMPB    R3,CR           ;   IF EC_CHR=CR THEN
        BNE     EC4:B
        TBITB   0,R1            ;     AND ECHOLF ON 
        BFS     ECEX:w          ;   THEN ECHO WITH LF
        MOVB    LF,R3
        BR      EC3
EC4:                            ;   IF EC_CHR=BACKSP THEN
        CMPB    BACKSP, R3      ;   BEGIN
        BNE     ECEX:B
ZAP:    
        ;++++++++++++++++
        MOVQB   TRUE,TOS
        MOVB    SPACE,TOS
        MOVB    EC_TRM,TOS      ;   PRCHR (TURE,EC_CHR,EC_TRM)
        ;migry;SPRD    MOD,TOS
        MOVB    0x82,TOS
        BSR     PRCHR
        CMPQB   TRUE,TOS        ;   {ADJUST STACK}
        ;----------------
        ;++++++++++++++++
        MOVQB   TRUE,TOS
        MOVB    BACKSP, TOS
        MOVB    EC_TRM,TOS      ;   PRCHR (TURE,EC_CHR,EC_TRM)
        ;migry;SPRD    MOD,TOS
        MOVB    0x83,TOS
        BSR     PRCHR
        CMPQB   TRUE,TOS        ;   {ADJUST STACK}
        ;----------------
ECEX:
        .ENDPROC
;
;
;
;  SKIP ON SPACE SUBROUTINE
;
COMP1:  ADDQD   1,R5                    ; DTRM.SCN:=DTRM.SCN+1;
COMPS:  CMPB    R5,INLM(R7)             ; WHILE DRTM.SCN<DTRM.INLM
        BGE     COMPEX:B
        CMPB    0(R5),CR                ;   AND INBUF(DTRM.SCN)<=SPACE
        BEQ     COMPEX:B                ;     DTRM.SCN:=DTRM.SCN+1;
        CMPB    0(R5),SPACE             ;   AND INBUF(DTRM.SCN)<=SPACE
        BLE     COMP1                   ;     DTRM.SCN:=DTRM.SCN+1;
COMPEX: RET     0                       ; END WHILE
;
;
;       P R I N T A
;
;       PRINT ARRAY PROCEDURE
;
;       CALLING SEQUENCE PRINTA (ARRP,ENDP,PRTRM)
;          ARRP  - POINTER TO ARRAY TO BE PRINTED
;          ENDP  - POINTER TO LAST BYTE TO BE PRINTED
;          PRTRM - # OF TERMINAL TO PRINT ON
;          HND   - BOOLEAN FLAG IF HAND-SHAKING NEDDED
;
;
        .ALIGN 2
PRINTA: .PROC
ARRP:   .BLKD   ;DOUBLE         ; VAR: ARRAY OF CHR
ENDP:   .BLKD   ;DOUBLE         ;  POINTER
PRTRM:  .BLKB   ;BYTE           ;  INTEGER [0..1]
DUMMY1: .BLKB   ;BYTE for alignment - migry
        .VAR    [R1,R2,R3,R4]
        .BEGIN
#ifdef DEBUGTHEFORCE
        MOVW    0xdead,@DEBUGD   ; migry - debug
#endif
        MOVD    ARRP,R1         ; R1:=POINTER TO PRINT ARRAY
        MOVB    OPHND,R2        ; R2:= OPMOD [PRTRM]
        CMPQB   TRMA,PRTRM
        BEQ     PRNTLP:B
        MOVQD   2 ,R2           ;NO LINE FEED TO AUX PORT
        ;
        ; main print loop
        ;
PRNTLP: MOVB    0(R1),R4
        ;++++++++++++++++
        MOVB    TRUE,TOS
        MOVB    R4,TOS          ;   PRCHR(TRUE,M(ARRP),PRTRM)
        MOVB    PRTRM,TOS
        ;migry;SPRD    MOD,TOS
        MOVB    0x84,TOS
        BSR     PRCHR           ;   {REMOVE ENDF FROM STACK}
        CMPQB   TRUE,TOS        ; END
        CMPB    R4,CR           ; IF NOT (HAND[PRTRM] AND M[ARRP]=CR]
        ;----------------
        BNE     PRNT8:B         ; THEN
        TBITB   1, R2           ; BEGIN
        BFS     PRNT8:B         ;IF SET THEN NO LF
        MOVB    LF,R4           ;   ECHO WITH LF
        ;++++++++++++++++
        MOVB    TRUE,TOS
        MOVB    R4,TOS          ;   PRCHR(TRUE,M(ARRP),PRTRM)
        MOVB    PRTRM,TOS
        ;migry;SPRD    MOD,TOS
        MOVB    0x85,TOS
        BSR     PRCHR           ;   {REMOVE ENDF FROM STACK}
        CMPQB   TRUE,TOS        ; END
        ;----------------
PRNT8:  ADDQD   1,R1
        CMPQD   0,ENDP          ; IF ENDP<>0 THEN
        BEQ     PRTA5:B
        CMPD    R1,ENDP         ;  REPEAT UNTILE ARRP>ENDP
        BGE     PRTAEX:B
        BR      PRNTLP
PRTA5:  CMPB    0(R1),PRINTE    ; ELSE
        BNE     PRNTLP          ;  REPEAT UNTILE M(ARRP)=END INDICATOR
PRTAEX:
#ifdef DEBUGTHEFORCE
        MOVW    0xbeef,@DEBUGD  ; migry - debug
#endif
        .ENDPROC
;
;
;       S P R I N T A
;       STANDARD CALL TO PRINTA PROCEDURE
;
;       FUNCTION - PRINT OUTPUT BUFFER OF CURRENTLY WORKING TERMINAL
;
;       PARAMETERS - NONE
;
;       LOCAL VARIABLES - NONE
;
;
        .ALIGN 2
SPRINTA:
        ;++++++++++++++++
        ADDR    OUTB(R7),TOS
        MOVD    R6,TOS          ; PRINTA (DTRM.OUTB,DTRM.OUTLM,DTRM)
        MOVQB   TRMA,TOS
        MOVB    0x99,TOS        ; migry - for alignment
        ;migry;SPRD    MOD,TOS
        BSR     PRINTA
        ;----------------
        RET     0
;
;
HEXAN: .BYTE '0123456789ABCDEF'
;       H X T O B N  (HEXA OR DECIMAL TO BINARY)
;
;

HXTOBN:  .PROC
WORD_HB: .BLKD  ;DOUBLE ; WORD_HB : DINTEGER
EXRR_HB: .BLKB  ;BYTE           ; EXRR : INTEGER
VECP_HB: .BLKD  ;DOUBLE ; VECP : VAR :POINTER
ENDP_HB: .BLKD  ;DOUBLE ; ENDP : POINTER
        .RETURNS
        .BLKB   9
        .VAR    [R0,R1,R4]
        .BEGIN
        MOVQB   TRUE,EXRR_HB    ; EXRR:= TRUE
        MOVD    VECP_HB, R0
NLOOP:  CMPB    ' ', 0(R0)
        BEQ     ENDN:B
        CMPB    CR, 0(R0)
        BEQ     ENDN:B
        CMPB    '=', 0(R0)
        BEQ     ENDN:B
        ADDQD   1, R0
        BR      NLOOP
ENDN:   MOVD    R0, ENDP_HB
        ADDQD   -1, R0
        MOVD    VECP_HB, TOS
        MOVD    R0, TOS
        MOVB    MON_BASE, BASE
        BSR     A_NUM   
        MOVD    TOS, WORD_HB
        CMPQD   FALSE, ERROR
        BNE     A_NUMERR:B
        MOVQB   FALSE,EXRR_HB   ; EXRR:=FALSE
A_NUMERR:
        MOVD    ENDP_HB,VECP_HB ; UNTILE VECP>= ENDP
        .ENDPROC
;
;
;       B N T O H X   (BINARY TO HEX or DECIMAL CONVERSION)
;
;
BNTOHX:  .PROC
WORD_BH: .BLKD  ;DOUBLE ; WORD : DINTEGER
N_BH:    .BLKB  ;BYTE           ; N : INTEGER
TYPE_BH: .BLKB  ;BYTE           ; TYPE : INTEGER[0..2]
         .VAR   [R1,R2]
SV_R6:   .BLKD
         .BEGIN

        MOVD    '    ', 0(R6)
        MOVD    '    ', 4(R6)
        MOVD    '    ', 8(R6)
        MOVD    R6, SV_R6
        ADDD    12, SV_R6
        CMPQB   DEC, MON_BASE
        BNE     DOHEX:W
        MOVQB   FALSE, LEADZERO
        MOVD    WORD_BH, R2
        CMPQB   4, N_BH
        BLT     DO_IT:B
        MOVXWD  R2, R2
        CMPQB   2, N_BH
        BLT     DO_IT:B
        MOVXBD  R2, R2
DO_IT:  ADDQD   4, N_BH
        MOVD    R2, TOS
        MOVB    MON_BASE, BASE
        BSR     N_TO_ASC
        MOVD    TOS, R2         ;CLEAN STACK
        MOVQD   0, R1
MOCH:   MOVB    NUMCH[R1:B], 0(R6)
        ADDQD   1, R1
        ADDQD   1, R6
        CMPB    R1, N_BH
        BLT     MOCH
        BR      BTHEX:W
DOHEX:
        MOVQB   TRUE, LEADZERO
        MOVD    WORD_BH, TOS
        MOVB    MON_BASE, BASE
        BSR     N_TO_ASC
        MOVD    TOS, R2         ;CLEAN STACK
        CMPQB   6, N_BH
        BNE     NOT6:B
        ADDQD   2, N_BH
NOT6:   MOVQD   0, R1
        CMPQB   4, N_BH
        BLT     BTHLP:B
        MOVQD   4, R1
        CMPQB   2, N_BH
        BLT     BTHLP:B
        MOVQD   6, R1
BTHLP:  MOVZBD  N_BH,R2 ; (* R2:=VECP *)
        CMPQD   0,R2    ;  WHILE N>0 DO
        BGE     BTHEX:B
        ADDQD   -1,R2
        CMPB    '0',NUMCH[R1:B]
        BNE     BTH2:B  ; IF R2:=0 AND N>1 THEN
        CMPQB   1,N_BH  
        BEQ     BTH2:B
        CMPQB   1,TYPE_BH ; CASE TYPE OF
        BGT     BTH2:B    ;   <1 PUT LEADING ZEROS
        BLT     BTH4:B    ;   >1 SUPRESS LEADING ZEROS
        MOVB    " ",0(R6) ;   =1 INSERT SPACE FOR LEADING ZEROS
        BR      BTH3:B
BTH2:   MOVB    NUMCH[R1:B],0(R6) ; M(VECP):=HEXAN[R2]
        MOVQB   0,TYPE_BH
BTH3:   ADDQD   1,R6    ; VECP:=VECP+1
BTH4:   ADDQB   -1,N_BH ; N:=N-1
        ADDQD   1, R1
        BR      BTHLP
BTHEX:
        MOVQB   FALSE, LEADZERO
        CMPQB   TRUE, PROCESS
        BNE     BTHEX2:B
        MOVD    SV_R6, R6
BTHEX2:
        .ENDPROC
;
;
;       T B S R C H  (TABLE SEREACH PROCEDURE )
;
;
TBSRCH:  .PROC
TABADR: .BLKD   ;DOUBLE         ; TABADDR : POINTER
LENGTH: .BLKB   ;BYTE           ; LENGTH : INTEGER
        .RETURNS
EXITF:  .BLKB   ;BYTE           ; EXITF : BOOLEAN
        .VAR
SAVER5: .BLKD
        .BEGIN
        MOVD    R5, SAVER5      ;SAVE ENRTY POINT
        CMPB    'a', 0(R5)      ;CONVERT COMMAND CHARS TO UPPER CASE
        BGT     ACAP5:B         
        ADDB    -H'20, 0(R5)    
ACAP5:  CMPB    'a', 1(R5)      ;CONVERT COMMAND CHARS TO UPPER CASE
        BGT     ACAP2:B         
        ADDB    -H'20, 1(R5)    
ACAP2:  MOVQD   0,R2            ; I:=0
                                ; REPEAT
SRCHL:  CMPW    0(TABADR)[R2:W],0(R5)
        BEQ     SRFND:B         ;  IF TAB(I_I+1)<>INBUF(I_I+1)
        CMPB    0(TABADR)[R2:W],0(R5); THEN IF TAB(I)=INBUF(I)
        BNE     SRC2:B          ;           THEN
        CMPB    1(TABADR)[R2:W],SPACE;          IF TAB(I+1):=SPACE
        BEQ     SRFND2:B        ;                GOTO FOUND;
SRC2:   ADDQD   1,R2            ;      ELSE
        CMPB    R2,LENGTH       ;       I:=I+1;
        BLT     SRCHL           ; UNTIL I=LENGTH;
        MOVQB   FALSE,EXITF     ; EXITF:=FALSE;
        MOVQD   0,R2
        MOVD    SAVER5, R5      ;RESTORE ENTRY POINT
        BR      SRCHEX:B
SRFND:  ADDQD   1,R5            ; DTRM.SCN:=DTRM.SCN+1;
SRFND2: ADDQD   1,R5            ; DTRM.SCN:=DTRM.SCN+1;
        MOVQB   TRUE,EXITF      ; EXITF:=TRUE
        BSR     COMPS           ; COMPS  {COMPRESS SPACE}
SRCHEX:
        .ENDPROC
;
;
;       G E T P U T     P R O C E D U R E
;
;       FUNCTION - GET REGISTER OR MEMORY VALUE TO R1
;                  PUT REGISTER OR MEMORY VALUE FROM R1
;
;                  REGISTER IS ONE OF :
;                  PC,US,IS,INTB,SB,FP,MOD,PSR,MSR,EADD,PTB,PF,
;                  SC,BPR,BCNT,REAL-MSR,SP,FL,FSR,R,F,FSR,CFG,SOFT-BPR
;
;                  MEMORY IS : BYTE WORD DOUBLE
;
;                  R2 CONTAINS REGISTER # (OR MEMORY)
;
;       CALLING SEQUENCE GETPUT (GET_PUT,TYPE,N,VALUE)
;             GETPUT -  0 GET
;                       1 PUT
;             TYPE   -  REGISTER TYPE (IN R2)
;             N      -  REGISTER NUMBER
;             VALUE  -  VALUE GET (OR PUT) IN R1
;
;
GETPUTX: 
GETPUT:  .PROC
GET_PUT: .BLKB  ;BYTE                           ; GET-PUT : INTEGET [0..1]
N_GP:    .BLKD  ;DOUBLE                 ; N       : DINTEGER
         .VAR   [R0,R3]
TEMP:    .BLKD
MSET:    .BLKB
         .BEGIN
        MOVQB   FALSE,MSET
        MOVD    N_GP,R0
        MOVQD   0,R3
        EXTSB   REGTB[R2:D],R3,0,4      ; GET OPERATION TYPE
        CMPB    7,R3                    ; SOFT BREAK POINT              
        BNE     LGPX:B                  ; THEN SET STAND ALONE SOFT ACTION
        MOVQB   TRUE,SPACIT            ; FLAG TO TRUE
LGPX:   CMPQB   GETI,GET_PUT            ; (* SET CC IF OPERATION IS GET *)
LGP:    CASEW   CASE_GP:B[R3:W]         ; CASE OF OPERATIN NUMBER
CASE_GP: .WORD  GMPUL-LGP               ; MPU OPERATION
         .WORD  GMMUL-LGP               ; MMU   "
         .WORD  GSPL-LGP                ; SP    "
         .WORD  GFPUL-LGP               ; FPU   "
         .WORD  GFSRL-LGP               ; FSR   "
         .WORD  PCFGL-LGP               ; CFG   "
         .WORD  GML-LGP                 ; MEMORY "
         .WORD  BRL-LGP                 ; SOFT-BREAK
         .WORD  GMSRL-LGP               ; MSR
GMSRL:  SMR     MSR,SCRCH1      ; TRAP IF NO MMU
GMPUL:  NEGD    R0,R0
BRL:    MULD    4,R0
        MOVZBD  REGTB+3[R2:D],R3
        ADDD    R3,R0           ;    R0:=REGTB.OFFSET+4*R0
GMPUL2: ADDR    SEREA[R0:B],R0
        CMPQB   -2,REGTB+2[R2:D]
        BNE     GMPUL3:B        ; IF REGTB.L2=-2 THEN  {SB INDIRECT READ} 
        MOVD    0(R0),R0        ;    R0  := M[R0]        
GMPUL3: CMPQB   GETI,GET_PUT
        BNE     PMPUL:B         ; IF GET COMMAND THEN
        MOVD    0(R0),R1        ;    R1:=SEREA[REGTB.OFFSET]
        CMPB    TRUE,SPACIT    ; IF REAL ALONE THEN STRIP BE BIT
        BNE     GPREX:W
        ANDD    H'FFFFFFF,R1
        BR      GPREX:W
PMPUL:  CMPB    TRUE,SPACIT    ;IF REAL ALONE ADD BE BIT
        BNE     PMPULX:B
        CMPQD   0,R1            ;IF BP RESET THEN DON'T ENABLE
        BEQ     PMPULX:B
        ORD     H'20000000,R1
PMPULX: MOVD    R1,0(R0)        ; ELSE  SEREA[REGTB.OFFSET]:=R1;
        BR      GPREX:W
;
; GET PUT SP
;
GSPL:   MOVB    USX+3,R0
        TBITB   PSR_S,SVPSR     ; IF PSR_S THEN
        BFS     GMPUL2          ;    R0:=US-OFFSET
        MOVB    ISX+3,R0        ; ELSE
        BR      GMPUL2          ;    R0:=IS-OFF_SET
;
; GET PUT FPU REG
;
MOVFI1: MOVF    F0,4(SP)
MOVFI2: MOVF    4(SP),F0
;
GFPUL:  MOVD    R1,TOS          ;MOVE DATA TO STACK
        BNE     PFPUL:B         ; IF GET THEN
        MOVD    MOVFI1,JMPRAM   ; COPT MOVFF INS TO RAM
        NOP
        NOP
        INSSB   R0,JMPRAM+2,3,5 ;   CHANGE GEN 1
        BR      GFPU4:B         ; ELSE
PFPUL:  MOVD    MOVFI2,JMPRAM   ; COPT MOVFF INS TO RAM
        NOP
        NOP
        INSSB   R0,JMPRAM+1,6,5 ;   CHANGE GEN 2
GFPU4:  MOVW    RET0:B,JMPRAM+4 ; COPY RET 0 INS
        JSR     JMPRAM          ; EXECUTE MOVFF INS
GFPU6:  MOVD    TOS,R1          ; COPY FROM STACK TO R1
        BR      GPREX:W
;
;
; GET PUT FSR
;
;
GFSRL:  BNE     PFSRL:B         ; IF GET THEN
        SFSR    TOS             ;   MOVE FSR TO STACK
        BR      GFPU6           ; ELSE
PFSRL:  MOVD    R1,TOS          ; MOVE R1 TO FSR VIA STACK
        LFSR    TOS
        BR      GPREX:W
;
; GET PUT MMU REG
;
SMRL:   SMR     BPR0,TEMP               ; SMR INSTRUCTION
LMRL:   LMR     BPR0,TEMP               ; LMR INSTRUCTION
RET0:   RET     0               ; RET 0 INSTRUCTION
;
GMMUL:  MOVD    R1, TEMP
        MOVD    SMRL,JMPRAM     ; IF GETPUT:=GET THEN
        BEQ     MMUL2:B         ;    COPY SMR TO RAM
        MOVD    LMRL,JMPRAM     ; ELSE COPY LMR TO RAM
        CMPB    15, R2          ;CHECK FOR MMSR
        BNE     MMUL2:B
        MOVD    R1, MNMSR
MMUL2:  ADDB    REGTB+3[R2:D],R0 ;R0:=N+REGTB.OFFSET
MMUL3:  MOVW    RET0,JMPRAM+4   ; COPY RET 0
        LSHW    7, R0
        ANDW    H'F87F, JMPRAM+1
        ORW     R0, JMPRAM+1    ; INSERT REG NUMBER
        JSR     JMPRAM          ; JUMP TO RAM
        MOVD    TEMP, R1
        CMPQB   FALSE,MSET
        BEQ     GPREX:W
        MOVQD   0, TEMP
        LMR     MSR, TEMP
        MOVQD   0, MNMSR
        MOVQD   0, SVMSR
        BR      GPREX:W
;
; GET PUT CFG
;
PCFGL:  MOVD    R1,R0           ; (* MOVE OPERAND TO R0 *)
        BEQ     GCFG:B          ; IF GETPUT=PUT THEN
        MOVD    R1,CONFIG       ;   CONFIG:=R1
        TBITB   CNFMMU, R1      ;IF SETTING MMU THEN INIT MSR
        BFC     NOM:B           ;AND SET SAVED MSR
        MOVQB   TRUE,MSET 
NOM:    MOVD    SCFGL:B,JMPRAM  ;   COPY SETCFG INSTRUCTION TO RAM
        BR      MMUL2           ;   GOTO MMUL2
SCFGL:  SETCFG  []              ; (* SETCFG INSTRUCTIN *)
        NOP
GCFG:   MOVZBD  CONFIG,R1       ; ELSE R1:=CONFIG;
        BR      GPREX:B
;
; GET PUT MEMORY
;
GML:    MOVB    REGTB+3[R2:D],R3        ; GET B W D INDICATOR
        ADDB    GET_PUT,R3      ; R3:= B W D +GET_PUT
GMCASE: CASEB   GM2:B[R3:B]     ; CASE OF (B W D ) + GET_PUT
GM2:    .BYTE   GB-GMCASE               ; GET BYTE
        .BYTE   PB-GMCASE               ; PUT BYTE
        .BYTE   GW-GMCASE               ; GET WORD
        .BYTE   PW-GMCASE               ; PUT WORD
        .BYTE   GD-GMCASE               ; GET DOUBLE WORD
        .BYTE   PD-GMCASE               ; PUT DOUBLE  WORD
GB:     MOVZBD  0(R0),R1        ; R1:=M(ADDR) *** MOVUS ***
        BR      GPREX:B
PB:     MOVB    R1,0(R0)        ; M(ADDR):=R1 *** MOVSU ***
        BR      GPREX:B
GW:     MOVZWD    0(R0),R1        ; R1:=M(ADDR) *** MOVUS ***
        BR     GPREX:B
PW:     MOVW    R1,0(R0)        ; M(ADDR):=R1 *** MOVSU ***
        BR      GPREX:B
GD:     MOVD    0(R0),R1        ; R1:=M(ADDR) *** MOVUS ***
        BR      GPREX:B
PD:     MOVD    R1,0(R0)        ; M(ADDR):=R1 *** MOVSU ***
GPREX:  MOVQB   FALSE,SPACIT   ; CANCEL ACTION OF STAND ALONE MODE
        .ENDPROC

; end of asub.32k
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; start of autil.32k



AUERROR: .BYTE 'ERR_VAL',CR

A_NUM:                  .PROC
        DSTRT:          .BLKD  
        D_END:          .BLKD  
                        .RETURNS
        D_VAL:          .BLKD
                        .VAR [R1,R2,R3,R4,R5]
                        .BEGIN
                        MOVQD 0,R3
                        MOVQD   FALSE, R5       ;FLAG FOR NOP
                        ADDR    AUERROR, ERROR
                        MOVQB   FALSE,NEGIT
                        MOVD    DSTRT,R4
                        CMPW    H'2748, 0(R4)   ;ASSMBLER ERR H'2748 = "H'"
                        BEQ     A_HEX:W
                        CMPW    H'2744, 0(R4)   ;             H'2744 = "D'"
                        BEQ     A_DEC:B
                        CMPW    H'2768, 0(R4)   ;ASSMBLER ERR H'2748 = "h'"
                        BEQ     A_HEX:W
                        CMPW    H'2764, 0(R4)   ;             H'2744 = "d'"
                        BEQ     A_DEC:B
                        CMPQB   HEX, BASE        
                        BEQ     HEX_NUM:W
                        BR      DEC_NUM:B
        A_DEC:          ADDQD   2, R4
        DEC_NUM:        CMPB    '-', 0(R4)
                        BNE     PLUS_SIGN:B
                        MOVQB   TRUE, NEGIT
                        ADDQB   1, R4
                        BR      INTLOOP:B
        PLUS_SIGN:      CMPB    '+', 0(R4)
                        BNE     INTLOOP:B
                        ADDQD   1, R4
        INTLOOP:                    
                        MOVB 0(R4),R2
                        CMPD R4,D_END
                        BGT DONE1:W
        POSI:                                 
        ANUM:           MOVQD   TRUE, R5
                        SUBB    H'30,R2
                        CMPQB   0, R2
                        BGT     NONEG:W
                        CMPB    9, R2
                        BLT     NONEG:W
                        MULD    10,R3
                        MOVZBD  R2,R2
                        ADDD    R2,R3
                        ADDQD   1,R4
                        BR      INTLOOP
;-----------------HEX
        A_HEX:          ADDQD   2, R4
        HEX_NUM:        CMPB    '-', 0(R4)
                        BNE     HEXPLUS:B
                        MOVQB   TRUE,NEGIT
                        ADDQD   1, R4
                        BR      HEXLOOP:B
        HEXPLUS:        CMPB    '+', 0(R4)
                        BNE     HEXLOOP:B
                        ADDQD   1, R4
        HEXLOOP:                    
                        MOVB 0(R4),R2
                        CMPD R4,D_END
                        BGT DONE1:W
                        MOVQD   TRUE, R5
                        CMPB '9', R2
                        BLT  HEXLET:B
                        SUBB H'30,R2
                        CMPQB   0, R2
                        BGT  NONEG:w
                        CMPB    9, R2
                        BLT  NONEG:B
                        BR  MAKEHEX:B
        HEXLET:         CMPB 'a', R2    ;CHECK FOR LOWER CASE
                        BGT UP:B                
                        ADDB -H'20, R2
                UP:     SUBB H'37, R2
                        CMPB 10, R2
                        BGT NONEG:B
                        CMPB 15, R2
                        BLT     NONEG:B
        MAKEHEX:        LSHD  4,R3
                        MOVZBD R2,R2
                        ADDD R2,R3
                        ADDQD   1,R4
                        BR HEXLOOP

        DONE1:                             
                        CMPQD   FALSE, R5
                        BEQ     NONEG:B
                        MOVQD   FALSE, ERROR
                        CMPQB FALSE,NEGIT
                        BEQ NONEG:B
                        NEGD R3,R3
        NONEG:          MOVD R3,D_VAL
                        .ENDPROC

N_TO_ASC:               .PROC
        BIN_VAL:        .BLKD
                        .RETURNS
        CHRCOUNT:       .BLKD
                        .VAR[R0,R1,R2,R3,R4,R5,R6,R7]
                        .BEGIN
                        MOVZBD 80, R0
                        ADDR NUMCH, R1
                CLRIT:  MOVB ' ', 0(R1)
                        ADDQD 1, R1
                        ACBB -1, R0, CLRIT
                        MOVD BIN_VAL, DEC_VAL
                        MOVQD 0, CHRCOUNT
                        CMPB HEX, BASE
                        BNE  D_WRI:W
                        ADDR NUMCH, R3
                        MOVB 8,R0
                        MOVQB TRUE,LEAD_0  
                        CMPQB FALSE,LEADZERO
                        BEQ H_WRILOOP:B
                        MOVQB FALSE,LEAD_0  

        H_WRILOOP:      ROTD 4,DEC_VAL
                        MOVB DEC_VAL,R1
                        ANDB H'F,R1
                        CMPQB 0,R1
                        BNE H_OUTIT:B
                        CMPQB TRUE,LEAD_0  
                        BEQ H_SKIPI:B
        H_OUTIT:        MOVB H'30,R2
                        CMPB R1,H'A
                        BLT H_NUMCHR:B
                        MOVB H'37,R2
        H_NUMCHR:       ADDB R1,R2
                        MOVB R2,0(R3)
                        ADDQD 1,R3                      
                        ADDQD 1, CHRCOUNT
                        MOVQB FALSE,LEAD_0  
        H_SKIPI:        CMPQB 1,R0
                        BNE H_NO:B
                        CMPQB TRUE,LEAD_0   
                        BNE H_NO:B
                        MOVB '0',0(R3)
                        ADDQD 1,R3                      
                        ADDQD 1, CHRCOUNT
        H_NO:           ACBB -1,R0,H_WRILOOP
                        BR  EX_N_T_:W

;-----------------DEC WRITE
        D_WRI:          MOVQB FALSE,NEGIT
                        MOVD DEC_VAL, R7
                        CMPD R7,0
                        BGE POS:B
                        NEGD R7,R7
                        MOVQB TRUE,NEGIT
        POS:            MOVZBD 78,R0
                        MOVB '0',NUMCH[R0:B]
                        CMPQD 0,R7
                        BNE ILOOP:B
                        ADDQD -1,R0
                        ADDQD 1, CHRCOUNT
                        BR FIN:B

        ILOOP:          CMPQD 0,R7
                        BEQ FIN:B
                        MOVD R7,R6
                        REMD 10,R6
                        ABSD R6,R6
                        ADDB H'30,R6
                        MOVB R6,NUMCH[R0:B]
                        ADDQD 1, CHRCOUNT
                        QUOD 10,R7
                        ADDQD -1,R0
                        BR ILOOP

        FIN:            CMPQB TRUE,NEGIT
                        BNE NON:B
                        MOVB '-',NUMCH[R0:B]
                        ADDQD 1, CHRCOUNT
                        ADDQD -1,R0

        NON:            ADDQD 1,R0

     PACKLEFT:          ADDR NUMCH[R0:B], R1
                        MOVZBD  CHRCOUNT, R0
                        ADDR NUMCH, R2
                        MOVSB
        EX_N_T_:
                        .ENDPROC
 



                .endseg


INIT__:                 .PROC
                        .VAR
                        .BEGIN
                        .ENDPROC

;OPEN__:                .PROC
;       FID:            .BLKD  
;                       .BLKD  
;                       .BLKW
;                       .BLKW
;                       .BLKW
;       FNADDR:         .BLKD  
;                       .VAR
;                       .BEGIN
;                       .ENDPROC

; end of autil.32k
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; start of edit.32k

EDIT:           .PROC
        EVECIN: .BLKD   ;START OF INPUT LINE
        EVECEN: .BLKD   ;FOR INSERT AND REPLACE FUNCTIONS
        COM_N:  .BLKW
                .RETURNS
        R_VIN:  .BLKD           ;EVECIN START OF RETURN MESSAGE
        R_VEN:  .BLKD           ;EVECEN END OF RETURN MESSAGE
                .VAR[R0,R1,R2,R3,R4,R5,R6,R7]
                .BEGIN
                BR      STARTE:W
        E_MES:  .BYTE   'ERR_ED#',CR
        E_MES2: .BYTE   'BAD_TXT',CR

CHR_CNT:
        MOVD    L_ADDR, R0
        MOVD    R0, R2
        MOVQB   0, SAFETY       ;SANITY CONTROL
NXCHR0: ADDQD   1, R0
        ADDQB   1, SAFETY       ;INCREMENT SAFETY COUNT
        CMPB    100, SAFETY     ;IF NO CR AFTER 100 THEN BAD
        BGT     SANE0:B
        MOVQD   TEXT_BAD, ERROR ;SET BAD TEXT ERROR FLAG AND
        BR      CHREX:B
SANE0:  CMPB    0(R0), CR
        BNE     NXCHR0
        ADDQD   1, R0
        SUBD    R0, R2
        ABSD    R2, R2
CHREX:  RET     0


LINE_ADDR:
        MOVQB   0, SAFETY       ;SANITY CONTROL
        CMPQD   0, R1           ;R0 := ADDR(LINE R1)
        BEQ     FRST:W
        CMPQD   -1, LAST_AD     ;CHECK FOR VALID LAST
        BGE     NXCHR:B
        CMPD    R1, LAST_L      ;IF CURRENT LINE #
        BNE     NOTSAM:B
        MOVD    LAST_AD, R0
        BR      FRST:W
NOTSAM: BLT     NXCHR:B         ;>= LAST LINE # THEN DO
        MOVD    LAST_AD, R0     ;DO OPTIMIZED SEARCH
        SUBD    LAST_L, R1
NXCHR:  ADDQD   1, R0
        ADDQB   1, SAFETY       ;INCREMENT SAFETY COUNT
        CMPB    100, SAFETY     ;IF NO CR AFTER 100 THEN BAD
        BGT     SANE:B
        MOVQD   TEXT_BAD, ERROR ;SET BAD TEXT ERROR FLAG AND
        BR      FRST:B          ;TERMINATE LOOKUP LOOP
SANE:   CMPB    0(R0), CR
        BNE     NXCHR
        MOVQB   0, SAFETY       ;RESET SAFETY FOR NEXT LINE
        ACBD    -1, R1, NXCHR:W
        ADDQD   1, R0
FRST:                          
        RET     0

MOVSB_B:
        MOVB    0(R1), 0(R2)
        ADDQD   -1, R1
        ADDQD   -1, R2
        ACBD    -1, R0, MOVSB_B
        RET     0

EXPAND:
        MOVD    TXTEND, R0
        MOVD    L_ADDR, R1
        SUBD    R1, R0          ;CHR CNT
        MOVD    TXTEND, R1      ;SOURCE
        ADDD    LGTH, TXTEND  
        MOVD    TXTEND,R2       ;DESTINATION
        CMPQD   0, R0
        BGE     NOEXP:B
        ADDQD   -1, R1
        ADDQD   -1, R2
        BSR     MOVSB_B         ;REV E BUG
NOEXP:  RET      0

ADDLIN:
        MOVD    LGTH, R0
        MOVD    EVECIN, R1       ;SOURCE
        MOVD    L_ADDR, R2      ;DESTINATION
        MOVSB
        RET     0

SQUEEZ:
        BSR     CHR_CNT
        MOVD    R0, R1          ;SOURCE
        MOVD    TXTEND, R0
        SUBD    R1, R0          ;GETCHR CNT
        CMPQD   0, R0
        BGE     NO_SQE:B
        SUBD    R2, TXTEND      ;UPDATE TXTEND
        MOVD    L_ADDR, R2
        MOVSB
NO_SQE: RET     0

STARTE:                    
        MOVQD   FALSE, ERROR
        CMPQW   0, COM_N
        BEQ     RESETE:B  
        CMPQD   0, LINNUM
        BGT     ER:W
        CMPD    LINNUM, LINES
        BGT     ER:W
        ADDR    TEXT, R0
        MOVD    LINNUM, R1
        BSR     LINE_ADDR
        MOVD    R0, L_ADDR
RESETE: MOVZWD  COM_N, R7
CMD_VE:  CASEW   CMD_VECE:B[R7:W]
CMD_VECE:       .WORD   INITE - CMD_VE      ; "RS"
                .WORD   INSERT - CMD_VE     ; "IN"
                .WORD   DISPLY - CMD_VE     ; "TP"
                .WORD   DELETEE - CMD_VE    ; "KI"
                .WORD   REPLAC - CMD_VE     ; "RP"
INVALE:
        MOVQD   0, LINNUM
        MOVQD   0, LINES
        MOVQD   0, NEXT_LN
        MOVQD   0, LAST_L
        ADDR    TEXT, TXTEND
        MOVQD   -1, LAST_AD
        RET     0

INITE:   BSR     INVALE                          
        BR      EDIT_EX:W

INS_LINE:
        BSR     EXPAND
        BSR     ADDLIN
        BSR     CHR_CNT
        ADDQD   1, LINES
        RET     0

INSERT: 
        MOVD    EVECEN, LGTH
        SUBD    EVECIN, LGTH
        ADDQD   1, LGTH
        CMPQD   1, LGTH                 ;        CMPQD   2, LGTH   
        BGE     ER:W   
        CMPD    LGTH, LINE_LGTH         ;CHECK FOR MAX LENGTH
        BGT     ER:W    
        BSR     INS_LINE
        BR      EX:W

DISPLY:  
        CMPQD   0, LINES
        BGE     ER:W
        CMPD    LINNUM ,LINES
        BGE     ER:W
        MOVD    L_ADDR, R_VIN
        BSR     CHR_CNT
        ADDQD   -1, R0
        MOVD    R0, R_VEN
        BR      LEAVE:W

DEL_LINE:
        BSR     SQUEEZ
        ADDQD   -1, LINES
        RET     0

DELETEE: 
        CMPD    LINNUM, LINES
        BGE     ER:W
        CMPQD   1, LINES
        BLT     DO_DEL:B
        BSR     INVALE
        BR      EX:W
DO_DEL: BSR     DEL_LINE
        BR      EX:W

REPLAC: 
        CMPD    LINNUM, LINES
        BGE     ER:B
        MOVD    EVECEN, LGTH
        SUBD    EVECIN, LGTH
        ADDQD   1, LGTH
        CMPQD   1, LGTH   
        BGE     ER:B   
        CMPQD   1, LINES
        BLT     A_DEL:B
        BSR     INVALE
        BR      INSE:B
A_DEL:  BSR     DEL_LINE
INSE:    
        BSR     INS_LINE
        BR      EX:w

ER2:    ADDR    E_MES2, R0
        BR      SET:B
ER:     ADDR    E_MES, R0
SET:    MOVD    R0, R_VIN
        ADDQD   EMES_L, R0
        MOVD    R0, R_VEN
        MOVQD   -1, LAST_AD
        MOVD    LAST_L, LINNUM          ;RESTORE A GOOD LINE NUMBER
        ADDQD   -1, LINNUM
        CMPQD   -1, LINNUM
        BLT     OK_N:B
        MOVQD   0, LINNUM
OK_N:   MOVQD   TRUE, ERROR
        BR      EDIT_EX:B                       ;LEAVE
EX:     MOVQD   0, R_VIN
        MOVQD   0, R_VEN
LEAVE:  MOVD    LINNUM, LAST_L
        CMPQD   TEXT_BAD, ERROR         ;CHECK FOR BAD TEXT ERROR
        BEQ     ER2                        
        MOVD    L_ADDR, LAST_AD
EDIT_EX:
        .ENDPROC

; end of edit.32k
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; start of float.32k


P1_DIGIT:       .PROC
        .BLKB   4
        .RETURNS
        .BLKB   4
        .VAR    [R7,R6]
        .BLKB   4
        .BEGIN

                                ; line 153
                                ; line 154
        MOVXBD  88(FLOATS),R7
        MOVXBD  47(FLOATS)[R7:B],R6
        SUBD    48,R6
        MOVD    R6,(-4)(FP)
                                ; line 155
        CMPQD   0,(-4)(FP)
        BLE     L1:W
                                ; line 155
        MOVQD   1,124(FLOATS)
L1:
                                ; line 156
        CMPD    9,(-4)(FP)
        BGE     L2:W
                                ; line 156
        MOVQD   1,124(FLOATS)
L2:
                                ; line 157
        MOVD    (-4)(FP),8(FP)
                                ; line 158
        .ENDPROC

P2_MOVE_PNT:    .PROC
        .BLKB   0
        .VAR    [R7]
        .BEGIN

                                ; line 161
                                ; line 162
        MOVXBD  88(FLOATS),R7
        ADDQD   1,R7
        MOVB    R7,88(FLOATS)
                                ; line 163
        MOVXBD  88(FLOATS),R7
        CMPB    13,47(FLOATS)[R7:B]

        BNE     L3:W
                                ; line 163
        MOVQB   0,90(FLOATS)
L3:
                                ; line 164
        MOVXBD  88(FLOATS),R7
        CMPB    32,47(FLOATS)[R7:B]
        BNE     L4:W
                                ; line 164
        MOVQB   0,90(FLOATS)
L4:
                                ; line 165
        MOVXBD  88(FLOATS),R7
        CMPD    R7,44(FLOATS)
        BLE     L5:W
                                ; line 165
        MOVQB   0,90(FLOATS)
L5:
                                ; line 166
        MOVXBD  88(FLOATS),R7
        CMPD    40,R7
        BGE     L6:W
                                ; line 166
        MOVQB   0,90(FLOATS)
L6:
                                ; line 167
        .ENDPROC

P3_Q_SHF:       .PROC
        .BLKB   6
        .VAR    [R7]
        .BEGIN

                                ; line 172
                                ; line 173
        MOVXBD  8(FP),R7
        CMPQD   0,R7
        BNE     L7:W
                                ; line 173
        BR      L8:W
L7:
                                ; line 174
        MOVD    0(10(FP)),32(FLOATS)
                                ; line 175
        MOVD    4(10(FP)),36(FLOATS)
                                ; line 176
        ADDR    0(10(FP)),TOS
        MOVXBW  8(FP),TOS
        BSR     D_SHF   
                                ; line 177
        ADDR    4(10(FP)),TOS

        MOVXBW  8(FP),TOS
        BSR     D_SHF   
                                ; line 178
        MOVXBD  8(FP),R7
        CMPQD   0,R7
        BLE     L9:W
                                ; line 180
        MOVXBD  8(FP),R7
        ADDD    32,R7
        MOVB    R7,8(FP)
                                ; line 181
        ADDR    36(FLOATS),TOS
        MOVXBW  8(FP),TOS
        BSR     D_SHF   
                                ; line 182
        ADDR    0(10(FP)),TOS
        MOVD    36(FLOATS),TOS
        BSR     D_OR    
        BR      L10:W
L9:
                                ; line 185
        MOVXBD  8(FP),R7
        SUBD    32,R7
        MOVB    R7,8(FP)
                                ; line 186
        ADDR    32(FLOATS),TOS
        MOVXBW  8(FP),TOS
        BSR     D_SHF   
                                ; line 187
        ADDR    4(10(FP)),TOS
        MOVD    32(FLOATS),TOS
        BSR     D_OR    
L10:
L8:
                                ; line 190
        .ENDPROC

P4_Q_MUL_10:    .PROC
        .BLKB   0
        .VAR    
        .BEGIN

                                ; line 193
                                ; line 194
        MOVD    0(FLOATS),16(FLOATS)
                                ; line 195
        MOVD    4(FLOATS),20(FLOATS)
                                ; line 196
        ADDR    0(FLOATS),TOS
        MOVQW   3,TOS
        BSR     P3_Q_SHF   
                                ; line 197

        ADDR    16(FLOATS),TOS
        MOVQW   1,TOS
        BSR     P3_Q_SHF   
                                ; line 198
        ADDR    0(FLOATS),TOS
        ADDR    16(FLOATS),TOS
        BSR     Q_ADD   
                                ; line 199
        .ENDPROC

P5_Q_MOD_10:    .PROC
        .BLKB   0
        .VAR    
        .BEGIN

                                ; line 203
                                ; line 204
        MOVD    0(FLOATS),8(FLOATS)
                                ; line 205
        MOVD    4(FLOATS),12(FLOATS)
                                ; line 206
        ADDR    0(FLOATS),TOS
        BSR     Q_DIV_10
                                ; line 207
        BSR     P4_Q_MUL_10
                                ; line 208
        ADDR    8(FLOATS),TOS
        ADDR    0(FLOATS),TOS
        BSR     Q_SUB   
                                ; line 209
        MOVD    8(FLOATS),100(FLOATS)
                                ; line 210
        .ENDPROC

P6_REAL_CON:    .PROC
        .BLKB   0
        .VAR    [R7]
        .BLKB   2
        .BEGIN

                                ; line 216
                                ; line 217
        MOVQB   1,(-2)(FP)
                                ; line 218
        MOVQD   0,104(FLOATS)
                                ; line 219
        MOVQD   0,28(FLOATS)
                                ; line 220
        MOVQB   0,(-1)(FP)

L11:
                                ; line 223
        MOVXBD  88(FLOATS),R7
        CMPB    46,47(FLOATS)[R7:B]
        BEQ     L12:W
                                ; line 226
        BSR     P4_Q_MUL_10
                                ; line 227
        MOVQD   0,TOS
        BSR     P1_DIGIT   
        MOVD    TOS,24(FLOATS)
                                ; line 228
        CMPQD   0,24(FLOATS)
        BEQ     L13:W
                                ; line 228
        MOVQB   0,(-2)(FP)
L13:
                                ; line 229
        ADDR    0(FLOATS),TOS
        ADDR    24(FLOATS),TOS
        BSR     Q_ADD   
                                ; line 230
        CMPQB   1,(-1)(FP)
        BNE     L14:W
                                ; line 230
        ADDQD   1,96(FLOATS)
L14:
                                ; line 231
        CMPQB   0,(-2)(FP)
        BNE     L15:W
                                ; line 231
        ADDQD   1,104(FLOATS)
L15:
                                ; line 232
        BSR     P2_MOVE_PNT
        BR      L16:W
L12:
                                ; line 236
        MOVQB   1,(-1)(FP)
                                ; line 237
        BSR     P2_MOVE_PNT
L16:
                                ; line 240
        MOVXBD  88(FLOATS),R7
        CMPB    69,47(FLOATS)[R7:B]
        BEQ     L17:W
        CMPQB   0,90(FLOATS)
        BNE     L11
L17:
                                ; line 241
        CMPQD   0,120(FLOATS)
        BNE     L18:W
                                ; line 243
        CMPD    9,104(FLOATS)
        BGE     L19:W

                                ; line 243
        MOVQD   1,124(FLOATS)
L19:
        BR      L20:W
L18:
                                ; line 246
        CMPD    17,104(FLOATS)
        BGE     L21:W
                                ; line 246
        MOVQD   1,124(FLOATS)
L21:
L20:
                                ; line 248
        .ENDPROC

P7_DEC_CONV:    .PROC
        .BLKB   0
        .VAR    [R7,R6]
        .BEGIN

                                ; line 252
                                ; line 253
        MOVXBD  20,96(FLOATS)
                                ; line 254
        MOVD    96(FLOATS),R7
        MOVB    48,47(FLOATS)[R7:B]
                                ; line 255
        BR      L23:W
L22:
                                ; line 257
        BSR     P5_Q_MOD_10
                                ; line 258
        ADDR    0(FLOATS),TOS
        BSR     Q_DIV_10
                                ; line 259
        MOVD    48,R7
        ADDD    100(FLOATS),R7
        MOVD    96(FLOATS),R6
        MOVB    R7,47(FLOATS)[R6:B]
                                ; line 260
        ADDQD   -1,96(FLOATS)
L23:
                                ; line 261
        MOVD    0(FLOATS),R7
        ORD     4(FLOATS),R7
        CMPQD   0,R7
        BNE     L22
                                ; line 262
        CMPQB   1,128(FLOATS)
        BNE     L24:W
                                ; line 262
        MOVD    96(FLOATS),R7
        MOVB    45,47(FLOATS)[R7:B]

L24:
                                ; line 264
        MOVXWD  130(FLOATS),R7
        CMPQD   0,R7
        BLE     L25:W
                                ; line 266
        NEGW    130(FLOATS),130(FLOATS)
                                ; line 267
        MOVQB   1,129(FLOATS)
        BR      L26:W
L25:
                                ; line 269
        MOVQB   0,129(FLOATS)
L26:
                                ; line 271
        MOVXBD  27,96(FLOATS)
                                ; line 272
        MOVD    96(FLOATS),R7
        MOVB    48,47(FLOATS)[R7:B]
                                ; line 273
        MOVD    96(FLOATS),R7
        ADDQD   -5,R7
        MOVB    69,47(FLOATS)[R7:B]
                                ; line 275
        BR      L28:W
L27:
                                ; line 277
        MOVXWD  130(FLOATS),R7
        MODD    10,R7
        MOVD    R7,100(FLOATS)
                                ; line 278
        MOVXWD  130(FLOATS),R7
        QUOD    10,R7
        MOVW    R7,130(FLOATS)
                                ; line 279
        MOVD    48,R7
        ADDD    100(FLOATS),R7
        MOVD    96(FLOATS),R6
        MOVB    R7,47(FLOATS)[R6:B]
                                ; line 280
        ADDQD   -1,96(FLOATS)
L28:
                                ; line 281
        MOVXWD  130(FLOATS),R7
        CMPQD   0,R7
        BNE     L27
                                ; line 282
        CMPQB   1,129(FLOATS)
        BNE     L29:W
                                ; line 282
        MOVD    96(FLOATS),R7
        MOVB    45,47(FLOATS)[R7:B]
L29:
                                ; line 283
        .ENDPROC

P8_ROUND:       .PROC
        .BLKB   0
        .VAR    [R7]
        .BLKB   8
        .BEGIN

                                ; line 287
                                ; line 288
        MOVQD   1,108(FLOATS)
                                ; line 289
        CMPQD   0,120(FLOATS)
        BNE     L30:W
                                ; line 289
        MOVXBD  10,108(FLOATS)
L30:
                                ; line 290
        MOVD    108(FLOATS),(-8)(FP)
        CMPQD   1,(-8)(FP)
        BGT     L31:W
        MOVQD   1,(-4)(FP)
        BR      L33:W
L32:
        ADDQD   1,(-4)(FP)
L33:
                                ; line 292
        ADDR    0(FLOATS),TOS
        BSR     Q_DIV_10
                                ; line 293
        MOVXWD  130(FLOATS),R7
        ADDQD   1,R7
        MOVW    R7,130(FLOATS)
                                ; line 294
        CMPD    (-8)(FP),(-4)(FP)
        BNE     L32
L31:
                                ; line 295
        .ENDPROC

P9_EXP: .PROC
        .BLKB   0
        .VAR    [R7]
        .BEGIN

                                ; line 299
                                ; line 300
        BR      L35:W
L34:
                                ; line 302
        MOVQD   0,TOS
        BSR     P1_DIGIT   

        MOVXWD  130(FLOATS),R7
        MULD    10,R7
        ADDD    TOS,R7
        MOVW    R7,130(FLOATS)
                                ; line 303
        BSR     P2_MOVE_PNT
L35:
                                ; line 304
        CMPQB   1,90(FLOATS)
        BEQ     L34
                                ; line 305
        CMPQB   1,129(FLOATS)
        BNE     L36:W
                                ; line 305
        NEGW    130(FLOATS),130(FLOATS)
L36:
                                ; line 306
        CMPQD   0,120(FLOATS)
        BNE     L37:W
                                ; line 308
        MOVXWD  130(FLOATS),R7
        CMPD    37,R7
        BGE     L38:W
                                ; line 308
        MOVQD   1,124(FLOATS)
L38:
                                ; line 309
        MOVXWD  130(FLOATS),R7
        CMPD    -37,R7
        BLE     L39:W
                                ; line 309
        MOVQD   1,124(FLOATS)
L39:
        BR      L40:W
L37:
                                ; line 312
        MOVXWD  130(FLOATS),R7
        CMPD    307,R7
        BGE     L41:W
                                ; line 312
        MOVQD   1,124(FLOATS)
L41:
                                ; line 313
        MOVXWD  130(FLOATS),R7
        CMPD    -307,R7
        BLE     L42:W
                                ; line 313
        MOVQD   1,124(FLOATS)
L42:
L40:
                                ; line 315
        .ENDPROC

P10_SIGN_CHK:   .PROC
        .BLKB   4
        .VAR    [R7]
        .BEGIN

                                ; line 318
                                ; line 319
        MOVXBD  88(FLOATS),R7
        CMPB    45,47(FLOATS)[R7:B]
        BNE     L43:W
                                ; line 319
        MOVQB   1,0(8(FP))
                                ; line 319
        BSR     P2_MOVE_PNT
        BR      L44:W
L43:
                                ; line 320
        MOVXBD  88(FLOATS),R7
        CMPB    43,47(FLOATS)[R7:B]
        BNE     L45:W
                                ; line 320
        BSR     P2_MOVE_PNT
L45:
L44:
                                ; line 321
        .ENDPROC

P11_NORMALIZ:   .PROC
        .BLKB   0
        .VAR    [R7]
        .BEGIN

                                ; line 324
                                ; line 325
        MOVQD   0,92(FLOATS)
                                ; line 326
        BR      L47:W
L46:
                                ; line 328
        ADDR    0(FLOATS),TOS
        MOVQW   1,TOS
        BSR     P3_Q_SHF   
                                ; line 329
        ADDQD   1,92(FLOATS)
L47:
                                ; line 330
        MOVQW   0,TOS
        MOVD    4(FLOATS),TOS
        MOVXBW  31,TOS
        BSR     D_TBIT  
        CMPQB   1,TOS
        BNE     L46

                                ; line 331
        ADDR    0(FLOATS),TOS
        MOVQW   -4,TOS
        BSR     P3_Q_SHF   
                                ; line 332
        MOVQD   4,R7
        SUBD    92(FLOATS),R7
        MOVD    R7,96(FLOATS)
                                ; line 333
        .ENDPROC

ASC_2_RE:       .PROC
        .BLKB   20
        .VAR    [R7,R6]
        .BLKB   4
        .BEGIN

                                ; line 344
                                ; line 345
        MOVD    20(FP),44(FLOATS)
                                ; line 346
        MOVQD   1,(-4)(FP)
        BR      L50:W
L49:
        ADDQD   1,(-4)(FP)
L50:
                                ; line 346
        MOVD    (-4)(FP),R7
        MOVD    (-4)(FP),R6
        MOVB    -1(24(FP))[R7:B],47(FLOATS)[R6:B]
                                ; line 346
        CMPD    40,(-4)(FP)
        BNE     L49
L48:
                                ; line 347
        MOVD    0(16(FP)),120(FLOATS)
                                ; line 348
        MOVQW   0,130(FLOATS)
                                ; line 349
        MOVQD   0,132(FLOATS)
                                ; line 350
        MOVQB   0,128(FLOATS)
                                ; line 351
        MOVQB   0,129(FLOATS)
                                ; line 352
        MOVQD   0,124(FLOATS)
                                ; line 353
        MOVQD   0,96(FLOATS)
                                ; line 354
        MOVQD   0,0(FLOATS)
                                ; line 355
        MOVQD   0,4(FLOATS)

                                ; line 356
        MOVQD   0,0(28(FP))
                                ; line 357
        MOVQD   0,4(28(FP))
                                ; line 358
        MOVQD   0,40(FLOATS)
                                ; line 359
        MOVQB   1,88(FLOATS)
                                ; line 359
        MOVQB   1,90(FLOATS)
                                ; line 361
        ADDR    128(FLOATS),TOS
        BSR     P10_SIGN_CHK
                                ; line 362
        BSR     P6_REAL_CON
                                ; line 364
        CMPQB   0,90(FLOATS)
        BNE     L51:W
                                ; line 364
        BR      L52:W
L51:
                                ; line 365
        BSR     P2_MOVE_PNT
                                ; line 367
        ADDR    129(FLOATS),TOS
        BSR     P10_SIGN_CHK
                                ; line 368
        BSR     P9_EXP     
L52:
                                ; line 371
        MOVD    0(FLOATS),R7
        ORD     4(FLOATS),R7
        CMPQD   0,R7
        BNE     L53:W
                                ; line 371
        BR      L54:W
L53:
                                ; line 372
        CMPQD   0,124(FLOATS)
        BEQ     L55:W
                                ; line 372
        BR      L54:W
L55:
                                ; line 373
        MOVXWD  130(FLOATS),R7
        SUBD    96(FLOATS),R7
        MOVW    R7,130(FLOATS)
                                ; line 380
        MOVQD   0,92(FLOATS)
                                ; line 381
        BR      L57:W
L56:
                                ; line 383
        ADDR    0(FLOATS),TOS
        MOVQW   1,TOS

        BSR     P3_Q_SHF   
                                ; line 384
        ADDQD   1,92(FLOATS)
L57:
                                ; line 385
        MOVQW   0,TOS
        MOVD    4(FLOATS),TOS
        MOVXBW  27,TOS
        BSR     D_TBIT  
        CMPQB   0,TOS
        BEQ     L56
                                ; line 386
        MOVD    59,R7
        SUBD    92(FLOATS),R7
        MOVD    R7,96(FLOATS)
                                ; line 389
        ADDD    96(FLOATS),132(FLOATS)
                                ; line 396
        BR      L59:W
L58:
                                ; line 398
        MOVXWD  130(FLOATS),R7
        CMPQD   0,R7
        BGE     L60:W
                                ; line 399
        BSR     P4_Q_MUL_10
                                ; line 400
        MOVXWD  130(FLOATS),R7
        ADDQD   -1,R7
        MOVW    R7,130(FLOATS)
                                ; line 401
        BSR     P11_NORMALIZ
                                ; line 402
        ADDD    96(FLOATS),132(FLOATS)
        BR      L61:W
L60:
                                ; line 405
        ADDR    0(FLOATS),TOS
        BSR     Q_DIV_10
                                ; line 406
        MOVXWD  130(FLOATS),R7
        ADDQD   1,R7
        MOVW    R7,130(FLOATS)
                                ; line 407
        BSR     P11_NORMALIZ
                                ; line 408
        ADDD    96(FLOATS),132(FLOATS)
L61:
L59:
                                ; line 410
        MOVXWD  130(FLOATS),R7
        CMPQD   0,R7
        BNE     L58
                                ; line 412
        MOVD    132(FLOATS),96(FLOATS)

                                ; line 413
        ADDD    1023,132(FLOATS)
                                ; line 414
        MOVD    96(FLOATS),R7
        ADDD    127,R7
        MOVD    R7,136(FLOATS)
                                ; line 415
        MOVD    4(FLOATS),40(FLOATS)
                                ; line 416
        MOVD    0(FLOATS),16(FLOATS)
                                ; line 417
        MOVD    4(FLOATS),20(FLOATS)
                                ; line 418
        ADDR    16(FLOATS),TOS
        MOVXBD  127,TOS
        BSR     D_AND   
                                ; line 419
        ADDR    20(FLOATS),TOS
        MOVXBD  15,TOS
        BSR     D_AND   
                                ; line 421
        ADDR    132(FLOATS),TOS
        MOVXBW  20,TOS
        BSR     D_SHF   
                                ; line 422
        ADDR    0(FLOATS),TOS
        MOVQW   -7,TOS
        BSR     P3_Q_SHF   
                                ; line 423
        MOVQD   1,8(FLOATS)
                                ; line 424
        MOVQD   0,12(FLOATS)
                                ; line 425
        CMPD    2097151,4(FLOATS)
        BEQ     L62:W
        CMPQD   -1,0(FLOATS)
        BEQ     L62:W
                                ; line 426
        CMPQD   0,16(FLOATS)
        BEQ     L63:W
                                ; line 426
        ADDR    0(FLOATS),TOS
        ADDR    8(FLOATS),TOS
        BSR     Q_ADD   
L63:
L62:
                                ; line 428
        ADDR    4(FLOATS),TOS
        MOVD    1048575,TOS
        BSR     D_AND   
                                ; line 429
        ADDR    4(FLOATS),TOS
        MOVD    132(FLOATS),TOS
        BSR     D_OR    
                                ; line 430

        CMPQB   1,128(FLOATS)
        BNE     L64:W
                                ; line 431
        ADDR    4(FLOATS),TOS
        MOVD    -2147483647,R7
        ADDQD   -1,R7
        MOVD    R7,TOS
        BSR     D_OR    
L64:
                                ; line 433
        ADDR    136(FLOATS),TOS
        MOVXBW  23,TOS
        BSR     D_SHF   
                                ; line 434
        ADDR    40(FLOATS),TOS
        MOVQW   -4,TOS
        BSR     D_SHF   
                                ; line 435
        CMPD    16777215,40(FLOATS)
        BEQ     L65:W
                                ; line 436
        CMPQD   0,20(FLOATS)
        BEQ     L66:W
                                ; line 436
        ADDQD   1,40(FLOATS)
L66:
L65:
                                ; line 438
        ADDR    40(FLOATS),TOS
        MOVD    8388607,TOS
        BSR     D_AND   
                                ; line 439
        ADDR    40(FLOATS),TOS
        MOVD    136(FLOATS),TOS
        BSR     D_OR    
                                ; line 440
        CMPQB   1,128(FLOATS)
        BNE     L67:W
                                ; line 441
        ADDR    40(FLOATS),TOS
        MOVD    -2147483647,R7
        ADDQD   -1,R7
        MOVD    R7,TOS
        BSR     D_OR    
L67:
                                ; line 442
        CMPQD   1,120(FLOATS)
        BNE     L68:W
                                ; line 443
        MOVD    0(FLOATS),0(28(FP))
                                ; line 444
        MOVD    4(FLOATS),4(28(FP))
        BR      L69:W
L68:
                                ; line 447

        MOVD    40(FLOATS),0(28(FP))
                                ; line 448
        MOVQD   0,4(28(FP))
L69:
L54:
                                ; line 451
        MOVD    124(FLOATS),0(12(FP))
                                ; line 452
        .ENDPROC

REAL_2_A:       .PROC
        .BLKB   12
        .VAR    [R7,R6]
        .BLKB   4
        .BEGIN

                                ; line 460
                                ; line 461
        MOVD    0(16(FP)),120(FLOATS)
                                ; line 462
        CMPQD   0,120(FLOATS)
        BNE     L70:W
                                ; line 465
        MOVD    0(12(FP)),132(FLOATS)
                                ; line 466
        MOVQW   0,TOS
        MOVD    132(FLOATS),TOS
        MOVXBW  31,TOS
        BSR     D_TBIT  
        CMPQB   1,TOS
        BNE     L71:W
                                ; line 467
        MOVQB   1,128(FLOATS)
        BR      L72:W
L71:
                                ; line 468
        MOVQB   0,128(FLOATS)
L72:
                                ; line 469
        ADDR    132(FLOATS),TOS
        MOVD    2139095040,TOS
        BSR     D_AND   
                                ; line 470
        ADDR    132(FLOATS),TOS
        MOVXBW  -23,TOS
        BSR     D_SHF   
                                ; line 471
        MOVD    0(12(FP)),4(FLOATS)
                                ; line 472
        MOVQD   0,0(FLOATS)
                                ; line 473
        ADDR    4(FLOATS),TOS
        MOVD    8388607,TOS

        BSR     D_AND   
                                ; line 474
        MOVD    132(FLOATS),R7
        ORD     4(FLOATS),R7
        ORD     0(FLOATS),R7
        CMPQD   0,R7
        BNE     L73:W
                                ; line 474
        BR      L74:W
L73:
                                ; line 475
        SUBD    127,132(FLOATS)
                                ; line 476
        ADDD    1023,132(FLOATS)
                                ; line 477
        ADDR    132(FLOATS),TOS
        MOVXBW  20,TOS
        BSR     D_SHF   
                                ; line 478
        ADDR    0(FLOATS),TOS
        MOVQW   -3,TOS
        BSR     P3_Q_SHF   
                                ; line 479
        ADDR    4(FLOATS),TOS
        MOVD    132(FLOATS),TOS
        BSR     D_OR    
                                ; line 480
        CMPQB   1,128(FLOATS)
        BNE     L75:W
                                ; line 480
        ADDR    4(FLOATS),TOS
        MOVD    -2147483647,R7
        ADDQD   -1,R7
        MOVD    R7,TOS
        BSR     D_OR    
L75:
        BR      L76:W
L70:
                                ; line 484
        MOVD    0(12(FP)),0(FLOATS)
                                ; line 485
        MOVD    4(12(FP)),4(FLOATS)
L76:
                                ; line 487
        MOVD    4(FLOATS),132(FLOATS)
                                ; line 488
        MOVQW   0,TOS
        MOVD    4(FLOATS),TOS
        MOVXBW  31,TOS
        BSR     D_TBIT  
        CMPQB   1,TOS
        BNE     L77:W
                                ; line 489
        MOVQB   1,128(FLOATS)
        BR      L78:W

L77:
                                ; line 490
        MOVQB   0,128(FLOATS)
L78:
                                ; line 491
        ADDR    132(FLOATS),TOS
        MOVD    2146435072,TOS
        BSR     D_AND   
                                ; line 492
        ADDR    132(FLOATS),TOS
        MOVXBW  -20,TOS
        BSR     D_SHF   
                                ; line 493
        ADDR    4(FLOATS),TOS
        MOVD    1048575,TOS
        BSR     D_AND   
                                ; line 494
        MOVD    132(FLOATS),R7
        ORD     4(FLOATS),R7
        ORD     0(FLOATS),R7
        CMPQD   0,R7
        BNE     L79:W
                                ; line 494
        BR      L74:W
L79:
                                ; line 495
        SUBD    1023,132(FLOATS)
                                ; line 496
        ADDR    4(FLOATS),TOS
        MOVD    1048576,TOS
        BSR     D_OR    
                                ; line 497
        ADDR    0(FLOATS),TOS
        MOVQW   7,TOS
        BSR     P3_Q_SHF   
                                ; line 498
        SUBD    59,132(FLOATS)
                                ; line 499
        MOVQW   0,130(FLOATS)
                                ; line 501
        CMPQD   4,132(FLOATS)
        BGT     L80:W
                                ; line 503
        BR      L82:W
L81:
                                ; line 505
        ADDR    0(FLOATS),TOS
        BSR     Q_DIV_10
                                ; line 506
        MOVXWD  130(FLOATS),R7
        ADDQD   1,R7
        MOVW    R7,130(FLOATS)
                                ; line 507
        BSR     P11_NORMALIZ
                                ; line 508

        ADDD    96(FLOATS),132(FLOATS)
L82:
                                ; line 509
        CMPQD   4,132(FLOATS)
        BLE     L81
        BR      L83:W
L80:
                                ; line 511
        CMPQD   -4,132(FLOATS)
        BLT     L84:W
                                ; line 513
        BR      L86:W
L85:
                                ; line 515
        BSR     P4_Q_MUL_10
                                ; line 516
        MOVXWD  130(FLOATS),R7
        ADDQD   -1,R7
        MOVW    R7,130(FLOATS)
                                ; line 517
        BSR     P11_NORMALIZ
                                ; line 518
        ADDD    96(FLOATS),132(FLOATS)
L86:
                                ; line 519
        CMPQD   -4,132(FLOATS)
        BGE     L85
L84:
L83:
                                ; line 521
        ADDR    0(FLOATS),TOS
        MOVXBW  132(FLOATS),TOS
        BSR     P3_Q_SHF   
                                ; line 522
        BSR     P8_ROUND   
L74:
                                ; line 524
        MOVQD   1,(-4)(FP)
        BR      L89:W
L88:
        ADDQD   1,(-4)(FP)
L89:
                                ; line 524
        MOVD    (-4)(FP),R7
        MOVB    32,47(FLOATS)[R7:B]
                                ; line 524
        CMPD    40,(-4)(FP)
        BNE     L88
L87:
                                ; line 525
        BSR     P7_DEC_CONV
                                ; line 526
        MOVQD   1,(-4)(FP)
        BR      L92:W
L91:

        ADDQD   1,(-4)(FP)
L92:
                                ; line 526
        MOVD    (-4)(FP),R7
        MOVD    (-4)(FP),R6
        MOVB    47(FLOATS)[R7:B],-1(20(FP))[R6:B]
                                ; line 526
        CMPD    38,(-4)(FP)
        BNE     L91
L90:
                                ; line 527
        .ENDPROC

; end of float.32k
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; start of pasutil.32k

D_AND:          .proc
VECT_AND:       .blkd   ;  var ANUMBER :integer 
MASK_AND:       .blkd   ;  MASK :integer
                .var 
                .begin
                
                andd    MASK_AND, 0(VECT_AND)

                .endproc

;------------------------------------------------------------------------------

D_OR:           .proc
VECT_OR:        .blkd   ;  var ANUMBER :integer 
MASK_OR:        .blkd   ;  MASK :integer
                .var 
                .begin
                
                ord     MASK_OR, 0(VECT_OR)

                .endproc
;------------------------------------------------------------------------------


D_SHF:          .proc
VECT_SHF:       .blkd   ; var ABIT_FIELD : DOUB_WRD
                .blkb
CNT:            .blkb   ; SHF_VAL : BYTE
                .var [ r0 ]
                .begin

                movb    CNT, r0
                cmpb    r0, 0
                ble     SHFR:b
        SHF_1L: lshd    1, 0(VECT_SHF)
                acbb    -1, r0, SHF_1L
                br      EXX:b
        SHFR:
        SHF_1R: lshd    -1, 0(VECT_SHF)
                acbb    1, r0, SHF_1R
        EXX:
                .endproc

;--------------------------------------------------------------------------

D_TBIT:         .proc
                .blkw
T_BIT_FLD:      .blkd
                .blkb
OFFSET:         .blkb
                .returns
BIT_VAL:        .blkb
                .var
                .begin

                tbitb   OFFSET, T_BIT_FLD
                movqb   FALSE, BIT_VAL
                bfc     BIT_IS_0:b
                movqb   TRUE, BIT_VAL
BIT_IS_0:
                .endproc

;----------------------------------------------------------------------------

Q_ADD:          .proc
VECT_ADD:       .blkd
VECT_VAL:       .blkd
                .var 
                .begin
                
                addd    0(VECT_VAL), 0(VECT_ADD)        ;add low double wrd
                addcd   4(VECT_VAL), 4(VECT_ADD)        ; add high double wrd

                .endproc

;----------------------------------------------------------------------------

Q_SUB:          .proc
VECT_SUB:       .blkd
VECT_SVAL:      .blkd
                .var 
                .begin
                
                subd    0(VECT_SVAL), 0(VECT_SUB)       ;add low double wrd
                subcd   4(VECT_SVAL), 4(VECT_SUB)       ; add high double wrd

                .endproc

;---------------------------------------------------------------------------
;       R O U T I N E        Q U A D div 1 0
;        the general derivation of a split datum length divide by 10
; routine. (I.E. in this case 64bit / 10 in a basic 32 bit machine)
; Definition of terms:
;       N....................................a 64 bit number
;       Nh...........................the high doub word of N
;       Nl............................the low doub word of N
;       D..............the value of N, Nh, Nl after a div 10
;       Q...........................................is 2**32
;       CONST1......................................Q div 10
;       CONST2......................................Q mod 10
;
;       N = Nh*Q + Nl
;       N/10 = (Nh*Q)/10 + Nl/10
;       D = Dh + (Nh mod 10)Q/10 + Dl   by definiton of remainder
;       D = Dh + (Nh mod 10)(CONST1 + CONST2/10) + Dl + (Nl mod 10)/10
;       D =   Dh  
;           + (Nh mod 10)CONST1  
;           + ((Nh mod 10)CONST2)/10  
;           + (Nl mod 10)/10            
;           + Dl
;       D =   Dh 
;           + (Nh mod 10)CONST1
;           + [(Nh mod 10)CONST2 
;           + (Nl mod 10)]/10
;           + Dl                
;           

Q_DIV_10:       .proc
VECT_DIV:       .blkd
                .var [r0,r1,r2,r3,r6,r7]
                .begin

                movzbd  10, r7

                movqd   0, r1           ;DOUB_WRD hi := 0 
                movd    4(VECT_DIV), r0 ;DOUB_WRD lo := Nh
                deid    r7, r0          ;r0 := Nh mod 10
                                        ;r1 := Nh / 10

                movqd   0, r3           ;DOUB_WRD hi := 0
                movd    0(VECT_DIV), r2 ;DOUB_WRD lo := Nl
                deid    r7, r2          ;r2 := Nl mod 10
                                        ;r3 := Nl / 10

                movd    r0, r6

                muld    CONST2, r6      ;[ (Nh mod 10)*CONST2
                addd    r2, r6          ;+ (Nl mod 10)]
                divd    r7, r6          ; / 10
                addd    r3, r6          ;+ (Nl / 10)
        
                movd    r0, r2          ;r2 := (Nh mod 10) DOUB_WRD lo
                movqd   0, r3           ;r3 := 0 DOUB_WRD hi
                meid    CONST1, r2      ;r2 := (Nh mod 10)*CONST2
                addd    r6, r2          ; +  final summation

                movd    r2, 0(VECT_DIV) ; .DOUB_WRD_LO
                movd    r1, 4(VECT_DIV) ; .DOUB_WRD_HI

                .endproc

; end of pasutil.32k
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; start of tio.32k


;+++++++++++++
#ifdef DB16000
;+++++++++++++


;                       CASSETTE TAPE IO DESCRIPTION
;
;       This tape io driver is designed for the db16000.
;       Its implementation is made possible thru the parallel port.
;       Simple interface circuitry is required at the parallel port.
;
;       DB16000 Hardware implementation @ PPI_BASE
;
;       ---------------------------------    Special simple cassette interface 
;                      +5v------>       |       connected to J1
;       PPI_A(BASE)             < 4.7k  |
;                    8________  |       |
;    data bit in -----| 8303 |----------->------                   to recorder
;      (bit 0)        | U4   |     J1-47|    c \| 2N2222    1k  ||    aux out  
;                     /      /          /       |-----|---/\/\--||-------->
;                                       |    e V| b   <1k       ||.1uf   -- 
;                                       |      |      >                   |
;           DB16000                     |     ---    ---                 ---
;                                       |      - gnd  -                   - gnd
;                                       |
;      PPI_B(BASE)                      |     
;                     ________11        |      
;    data bit out-----| 7437 |----------->-- 
;      (bit 0)        | XU7  |     J1-15|  < 2.2k
;                     /      /          /  >
;                                          |---------->  to recorder input
;                                          <         --
;   note on db16000 J1 2-50                > 22*      |
;      are gnd                             |          | 
;                                         ---        ---
;                                          - gnd      -
;  * This value may be dependent on
;    the particular recorder used.
;
;


;       TIMING DATA:
;
;       The timings generated by the program produce a serial data flow rate
;       of approximately 330 baud. The effective recording frequency is approx
;       660 hz. The recorded pulses are not square waves for two reasons.
;       1. Recording a square pulse of greater than 1ms period is meaningless.
;       2. Therefore the input circuitry RC constant is set to approx 10k input
;       transition. Also the pulse lo time is good time for functions to be
;       executed by the processor.
;       The constant CYCLE is of key importance and must be adjusted to 
;       produce the specified timings in fig 3. 
;
;       OUTPUT PULSE TIMING:
;                                at UX7 pin 11 (J1-15)
;       
;       <------ CLOCK PERIOD ------><------ DATA  PERIOD ------>
;       ++++++++++                  ++++++++++                  ++++++//
;       +        +                  +        +                  +
;       +        +                  +  HI=1  +                  +  
;       +        +                  +  LO=0  +                  +
;       +        +                  +        +                  +
;    //++        ++++++++++++++++++++        ++++++++++++++++++++
;       <   Tw   >                  <   Tw   >                  |
;       <             Tp            >                           |
;       |                           <            Tp             >
;       <------------ 1 / (2 * Tp) = BAUD RATE ----------------->
;
;               Tw = .500 ms +/- 5%
;               Tp = 1.50 ms +/- 5%
;
;                       FIG. 3
;
; The above timings are satisfied by setting CYCLE to 100 for a 5 mhz CPU.
;
;


;
;       TAPE FORMAT:
;                              Start of recording
;    ------------------------------------------------------------------------>
;    |    start of tape       |      16000 master clock sync bits           
;    |                        |
;    |                        |
;    ------------------------------------------------------------------------>
;
;    Byte sync data   Recorded data
;    >--------//----------------------------------//-------------------------->
;    |  64 bytes of  | record start byte |                |            |next 
;    |  H'A5         | DATA = H'B7       | 128 data bytes | CRC byte   |record 
;    |               | EOD = H'FF        |                |            |or EOD
;    >--------//----------------------------------//-------------------------->
;
;       BYTE FORMAT:
;                        III = CLOCK HI , HHH = DATAHI, ______ = LO
;
;      | one clk |
;      v         bit 7               bit 6                bit 5  > to bit 0    
;      III_______HHH_______III_________________III________HHH_______III_______
;      ^ ^       ^ ^
;      | |       | D         The basic bit write is acomplished in the TPUT  
;      | |       C           routine where where the byte bits are sensed
;      | B                   and control whether a hi or lo is recorded. All 
;      A       FIG. 4        bits are preceded by a clock bit. The hi or lo 
;                            pulse time is generated by the PULSEhi/lo routines
;                            which access the parrallel port and loop CYCLE
;                            number of times to generate timings of figure 3.
;                            Readback starts in the master clock sync routine
;                            CSYNC. Here time period AC (fig. 4) is averaged
;                            over 10000 bits. Next the bit flow is synced to
;                            a byte by the BYTSYNC routine. Bytes are grabbed
;                            by the TGET routine which syncs to a clock pules
;                            by the CLKP routine. Upon exit from CLKP the TGET
;                            routine is at point B. It then samples for a hi
;                            from point B to D using the time base generated
;                            by CSYNC.



;------------------------------------------------------------------------
;                       T A P E    W R I T E  
;------------------------------------------------------------------------
;       TAPE IO ROUTINE REGISTER DUTY LIST
;       R0 = PPI_BASE,  R1 = DATA BYTE, R2 = BIT OFFSET FOR DATA BYTE
;       R3 = CHECKSUM,  R4 = LOOP CONTROL, R5 = TIMING CONTROL
;       R6 = MAX WAIT AND GP, R7 = GP
        
        TPUT:   ;BYTE WRITE ROUTINE

                        MOVQB   7, R2           ;START WITH BIT 7
                NEXBIT: BSR     PULSELO         ;CREATE A CLOCK PULSE
                        BSR     PULSEHI         ;INVERTED LOGIC BECAUSE
                        BSR     PULSEHI         ;INVERTING PORT
                        TBITB   R2, R1          ;OFFSET = R2, BASE = R1
                        BFS     AHI:B           ;WANT TO CRATE POSITIVE PULSE 
                        BSR     PULSEHI         ;IMAGE ON TAPE.
                        BR      ENDCYC:B        ;1/2 HI TO LO RATIO
                AHI:    BSR     PULSELO         ;IF BIT IS ZERO THEN PULSEHI
                ENDCYC: BSR     PULSEHI
                        BSR     PULSEHI
                        ADDQB   -1, R2          ;DO 8 BITS AND FINISH
                        CMPQB   0, R2
                        BLE     NEXBIT                          
                        RET     0


        THEAD:  ;ROUTINE TO PRODUCE TAPE HEADER
                
                        MOVD    LEADN * 2, R4   ;1000 X 2 X 8 = 16000 SYNC BITS
        CLCKIT:         MOVQB   -1, R1          ;MASTER SYNC BITS
                        MOVQB   7, R7
                        ACBB    -1, R7, $
                        BSR     TPUT
                        ACBD    -1, R4, CLCKIT
                        MOVD    RLEN / 2, R4    ;64 BYTE SYNC MARKS
        MARKIT:         MOVB    TMARK, R1
                        MOVQB   7, R7
                        ACBB    -1, R7, $
                        BSR     TPUT
                        ACBD    -1, R4, MARKIT
                        RET     0

;* * * * * * * * * * M A I N    R O U T I N E * * * * * * * * * * * * * * * 

        TWRITE:                 .PROC

                                ;EXPORTED TAPE WRITE ROUTINE
                STRTD:  .BLKD   ;START OF WRITE DATA -ADDR-
                ENDD:   .BLKD   ;ADDR OF LAST WRITE BYTE
                BAUD:   .BLKD
                        .VAR    [R0, R1, R2, R3, R4, R5, R6, R7]
                EOD:    .BLKB
                TCYCLE: .BLKD
                        .BEGIN
                        MOVD    BAUD,TCYCLE     ;SET BAUD SPEED
                        BSR     INI8255         ;INITIALIZE PARALLEL PORT
                        BSR     THEAD           ;WRITE OUT SYNC PULSES AND HEADER
                        MOVQB   FALSE, EOD      ;FLAG NOT END OF DATA
                NEXREC: CMPQB   TRUE, EOD       ;LOOP WRITING OUT RECORDS
                        BEQ     ENDMARK:W       ;OF RLEN UNTIL EOD FLAGGED
                        MOVB    RECMARK, R1     ;WRITE RECORD START
                        MOVQB   7, R7
                        ACBB    -1, R7, $
                        BSR     TPUT
                        MOVQD   0, R3           ;R3 = CHECKSUM REGISTER
                        MOVW    RLEN, R4        ;R4 RLOOP COUNTER
                RLOOP:  MOVQB   NUL, R1         ;IF EOD TRUE THEN WRITE NULL
                        CMPQB   TRUE, EOD       ;ELSE GET BYTE
                        BEQ     NULLS:B         ;CHECK FOR END
                        MOVB    0(STRTD), R1    ;IF AT LAST ADDR THEN SET EOD
                        CMPD    STRTD, ENDD     ;WRITE NULLS AFTER EOD TILL
                        BLT     NEXBYT:B        ;RECORD END
                        MOVQB   TRUE, EOD
                NEXBYT: ADDQD   1, STRTD        ;INDEX TO NEXT BYTE
                        ADDB    R1, R3          ;UPDATE CHECKSUM
                NULLS:  
                        BSR     TPUT            ;WRITE BYTE TO TAPE
                        ACBW    -1, R4, RLOOP   ;IF RECORD LOOP DONE
                        MOVB    R3, R1          ;THEN WRITE CHECKSUM BYTE
                        MOVQB   7, R7
                        ACBB    -1, R7, $
                        BSR     TPUT
                        BR      NEXREC
                ENDMARK:
                        MOVQB   -1, R1          ;WRITE EOD MARK
                        BSR     TPUT
                        .ENDPROC

;------------------------------------------------------------------------
;                       T A P E    R E A D
;------------------------------------------------------------------------

                CSYNC:  ;CLOCK SYNC ROUTINE     
                        MOVD    R2, R3          ;SAVE AVERAGE LOOP
                        MOVD    MAXWAIT, R6     ;ESTABLISH MAX WAIT TIME
                        MOVQD   0, R7
                LLOOP:  TBITB   0, PPI_A(R0)    ;LOOP FOR A PLUS TRANSITION
                        BFS     PEDGE:B         ;ONCE FOUND START COUNTER
                        ACBD    -1, R6, LLOOP
                        RET     0               ;WAITED TO LONG EXIT
                PEDGE:  MOVQD   0, R5           ;COUNTER IS R5, SET TO 0
                PLOOP1: TBITB   0, PPI_A(R0)    ;LOOP NOW WAITING FOR
                        BFC     PLOOP2:B        ;NEGATIVE TRANSITON
                        ADDQD   1, R5           ;COUNT PULSE WIDTH IN R5
                        ACBD    -1, R6, PLOOP1
                        RET     0
                PLOOP2: TBITB   0, PPI_A(R0)    ;LOOP NOW WAITING FOR
                        BFS     SUNK:B          ;NEGATIVE TRANSITON
                        ADDQD   1, R5           ;COUNT PULSE WIDTH IN R5
                        ACBD    -1, R6, PLOOP2
                        RET     0
                SUNK:   ADDD    R5, R7          ;MAKE AVERAGE
                FORLO:  TBITB   0, PPI_A(R0)
                        BFS     FORLO
                        ACBD    -1, R2, LLOOP
                        DIVD    R3, R7          ;CALCULATE AVERAGE
                        MOVD    R7, R5          ;AND STORE IN R5
                        RET     0

                CLKP:   ;EDGE SYNC ROUTINE      
                        MOVD    MAXCYCLE, R6    ;ESTABLISH MAX WAIT TIME
                ELOOP:  TBITB   0, PPI_A(R0)    ;LOOP FOR A PLUS TRANSITION
                        BFS     EDGE1:B         ;ONCE FOUND START COUNTER
                        ACBD    -1, R6, ELOOP
                        RET     0               ;WAITED TO LONG EXIT
                EDGE1:  TBITB   0, PPI_A(R0)
                        BFC     EDGE2:B
                        ACBD    -1, R6, EDGE1
                EDGE2:  RET     0
                
                        
                TGET:   ;TAPE GET BYTE ROUTINE
                        MOVQB   0, R1           ;DATA START
                        MOVB    8, R2           ;BIT COUNT
                GBIT:   BSR     CLKP            ;SYNC TO CLOCK
                        CMPQD   FALSE, R6       ;CHECK FOR TIME OUT
                        BEQ     GOUT:W          ;AND EXIT
                        MOVQB   0, R7
                        MOVD    R5, R6          ;SET DATA SAMPLE TIME
                        LSHB    1, R1
                SAMPLE: TBITB   0, PPI_A(R0)    ;SAMPLE DATA BIT
                        BFC     ZBIT:B          ;SET IF BIT IS 1
                        ADDQB   1, R7           ;ADD TO NOISE COUNT
                        SBITB   0, R1
                ZBIT:   ACBD    -1, R6, SAMPLE  ;WAIT FOR SAFE START OF NEXT
                        CMPB    FILTER, R7      ;CHECK FOR NOISE ACTIVATED
                        BLE     WAITLO:B
                        CBITB   0, R1           ;CHECK FOR NOISE PULSE
                WAITLO: TBITB   0, PPI_A(R0)
                        BFS     WAITLO
                        ACBB    -1, R2, GBIT    ;CLOCK PULSE
                GOUT:   RET     0               ;DO 8 BITS AND RETURN 

                BYTSYNC:;ALIGN CLOCK/DATA TO BYTE BOUNDRY
                        MOVW    RLEN, R4        ;DO FOR MAX OF RLEN
                BSINK:  CMPB    TMARK, R1       ;IF NOT SYNC CHAR
                        BEQ     BSUNK:B         ;THEN SKIP A CLOCK PULSE
                        BSR     CLKP                    
                        MOVD    R5, R6          ;CODE TO SKIP A CLOCK PULSE
                DLOOP:  TBITB   0, PPI_A(R0)
                        BFC     ZDUM:B
                        SBITB   0, R1
                ZDUM:   ACBD    -1, R6, DLOOP
                ALO:    TBITB   0, PPI_A(R0)
                        BFS     ALO
                        BSR     TGET
                        ACBW    -1, R4, BSINK   ;TRY AGAIN
                BSUNK:  RET     0       
        
                RHEAD:  ;READ TAPE HEADER
                        MOVD    LEADN * 5, R2   ;ROUGH SYNC -GET PASS SETTLING
                        BSR     CSYNC           ;AND START UP NOISE
                        CMPQD   0, R6           ;CHECK FOR TIME OUT
                        BNE     HLOOP1:B
                        RET     0
                HLOOP1: MOVD    LEADN * 10, R2  ;FINE SYNC
                        BSR     CSYNC
                        CMPQD   0, R6           ;CHECK FOR TIME OUT
                        BNE     HLOOP2:B
                        RET     0
                HLOOP2: BSR     TGET
                        CMPQB   -1, R1          ;FINISH OF SYNC BITS
                        BEQ     HLOOP2
                RECMRK: BSR     BYTSYNC         ;SYNC TO BYTE BOUNDRY
                        MOVQD   1, R6           ;FLAG NO TIME OUT
                        RET     0

; * * * * * * * * * * * * * M A I N    R O U T I N E * * * * * * * * * * *

        TREAD:          .PROC
                        ;EXPORTED TAPE READ ROUTINE
                STRTR:  .BLKD   ;STORE DATA STARTING HERE
                RERR:   .BLKD   ;ERROR CODE ADDR
                        .RETURNS
                LXADDR: .BLKD   ;LAST ADDRESS OF STORED DATA
                        .VAR    [R0, R1, R2, R3, R4, R5, R6, R7]
                        .BEGIN
                        MOVQD   FALSE, 0(RERR)
                        BSR     INI8255         ;INITIALIZE PARALLEL PORT
                        BSR     RHEAD
                        CMPQD   0, R6           ;CHECK FOR NO HEAD SYNC
                        BNE     MLOOP:B
                        MOVQD   ASYNC, 0(RERR)  ;SET NO HEAD ERROR
                        BR      TROUT:W
                MLOOP:  BSR     TGET            ;SKIP BYTE SYNC MARKS
                        CMPB    TMARK, R1
                        BEQ     MLOOP   
                GREC:   CMPQB   -1, R1          ;RECORD LOOP
                        BEQ     TROUT:B         ;IF LAST RECORD THEN DONE
                        CMPB    RECMARK, R1     ;ELSE IF RECORD MARK DO READ
                        BEQ     DOREC:B         ;ELSE
                        MOVQD   FREC, 0(RERR)   ;SET NO RECORD ERROR
                        BR      TROUT:B
                DOREC:  MOVQD   0, R3           ;INIT CHECKSUM TO 0
                        MOVW    RLEN, R4        ;BYTE COUNT
                RECLOOP:
                        BSR     TGET            ;GET A BYTE
                        MOVB    R1, 0(STRTR)    ;STOREIT
                        ADDQD   1, STRTR        ;NEXT STORE ADDR
                        ADDB    R1, R3          ;CALCULATE CHECKSUM
                        ACBW    -1, R4, RECLOOP ;GET NEXT BYTE
                        BSR     TGET            ;GET CHECKSUM
                        CMPB    R1, R3          ;CHECK IT
                        BNE     CRCER:B         ;SET ERROR IF BAD
                        BSR     TGET            ;GET RECORD MARK
                        BR      GREC
                CRCER:  MOVQD   RCRC, 0(RERR)
                        BSR     TGET            ;SET CRC ERROR
                        BR      GREC
                TROUT:  ADDQD   -1, STRTR       ;SET TRUE LAST ADDR
                        MOVD    STRTR, LXADDR   ;RETURN IT
                        .ENDPROC                        
#endif
;+++++++++++++

;@@@@@@@@@@@@@@
#ifdef THEFORCE
;@@@@@@@@@@@@@@
; use RAM as virtual tape drive
;       TAPE IO ROUTINE REGISTER DUTY LIST
;       R0 = PPI_BASE,  R1 = DATA BYTE, R2 = BIT OFFSET FOR DATA BYTE
;       R3 = CHECKSUM,  R4 = LOOP CONTROL, R5 = TIMING CONTROL
;       R6 = MAX WAIT AND GP, R7 = GP

        TPUT:
                        MOVB    R1,0(R5)   ; migry - save to virtual tape
                        ADDQD   1,R5
                        ADDQD   1,R2
                        RET     0

        ;;;MOVD    R0,TOS                  ;START OF TEXT DATA
        ;;;MOVD    TXTEND, TOS             ;END OF TEXT DATA
        ;;;MOVD    R7, TOS                 ;BAUD RATE

        TWRITE:                 .PROC

                STRTD:  .BLKD   ;ADDR OF START OF WRITE DATA 
                ENDD:   .BLKD   ;ADDR OF LAST WRITE BYTE
                BAUD:   .BLKD
                        .VAR    [R0, R1, R2, R3, R4, R5, R6, R7]
                EOD:    .BLKB
                        .BEGIN
                        ADDR    @TAPE_SAV,R5    ; R5 = address of virtual tape (first 2 bytes are length of saved data)
                        MOVD    ENDD,R3
                        SUBD    STRTD,R3
                        MOVW    R3,0(R5)        ; write length as a word at 0th location of virtual tape
                        ADDQD   2,R5
                        MOVD    STRTD,R2        ; R2 = pointer to start address of data
                        ;
                        MOVQD   0, R4           ; R4 = CHECKSUM REGISTER
                NEXBYT: MOVB    0(R2), R1       ; get data byte
                        ADDB    R1, R4          ; UPDATE CHECKSUM
                        BSR     TPUT            ; writes bytes and increments R2 and R5
                        NOP
                        NOP
                        ACBD    -1,R3,NEXBYT
                        NOP
                        NOP
                        ;;;MOVB    0(R2), R1       ; get final data byte
                        ;;;ADDB    R1, R4          ; UPDATE CHECKSUM
                        ;;;BSR     TPUT            ; writes final byte
                FINITO: 
                        MOVB    R4,R1           ;THEN WRITE CHECKSUM BYTE
                        BSR     TPUT
                        MOVB    0x55,R1         ;THEN WRITE MAGIC
                        BSR     TPUT
                        MOVB    0xaa,R1         ;THEN WRITE MAGIC
                        BSR     TPUT
                        NOP
                        NOP
                        .ENDPROC


        ;;;MOVD    PAR_VAL, TOS
        ;;;ADDR    ERROR, TOS              ;ERROR RETURN

        TREAD:          .PROC
                        ;EXPORTED TAPE READ ROUTINE
                STRTR:  .BLKD   ;STORE DATA STARTING HERE
                RERR:   .BLKD   ;ERROR CODE ADDR
                        .RETURNS
                LXADDR: .BLKD   ;LAST ADDRESS OF STORED DATA
                        .VAR    [R0, R1, R2, R3, R4, R5, R6, R7]
                        .BEGIN
                        ADDR    @TAPE_SAV,R5    ; migry - address of virtual tape data
                        MOVZWD  0(R5),R7        ; migry - length of tape (in bytes) 
                        ADDQD   2,R5
                        MOVQD   0, R4           ;R4 = CHECKSUM REGISTER
                        MOVD    STRTR,R6        ; migry - address of where to load tape
#ifdef DEBUGTHEFORCE
                        MOVD    R6,@DEBUGD
#endif
                        MOVQD   FALSE, 0(RERR)
                        ;
                RECLOOP:
                        MOVB    0(R5),R1
                        ADDQD   1,R5
                        MOVB    R1,0(R6)
                        ADDQD   1,R6
                        ADDB    R1, R4          ;UPDATE CHECKSUM
                        ACBD    -1,R7,RECLOOP
                        NOP
                        NOP
                        ;
                        MOVD    R6, LXADDR      ; return parameter, address of last byte loaded
                        MOVB    0(R5),R1        ; migry - read checksum byte
                        CMPB    R4,R1
                        ; TODO
                        .ENDPROC
#endif

; end of tio.32k
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; all hardware specific code has been moved here for easy modification...

;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

;+++++++++++++
#ifdef DB16000
;+++++++++++++

;============================================================================
IOBEG:   .EQU   H'C00000        ;  IO BEGIN ADDRESS
SWITCHP: .EQU   IOBEG+H'30      ; DIP SWICHES PORT ADDRESS
;============================================================================

;============================================================================
;;;;;;;;;;;;;;;;;;;;;;;;
; 8251 USART CONSTANTS ;
;;;;;;;;;;;;;;;;;;;;;;;;

; 0xc00000 to 0xc0000F          ; USART#1
; 0xc00040 to 0xc0004F          ; USART#1

USRTCS: .EQU    2               ; USRT CONTROL & STATUS PORT
USRTCS2: .EQU   USRTCS+H'40     ; USART # 2
DATAP:  .EQU    0               ; USRT DATA INPUT OUTPUT PORT
OUT_RDY: .EQU   0               ; TX-RDY BIT OF STATUS WORD
IN_RDY: .EQU    1               ; RX-RDY BIT OF STATUS

RUSRT:  .BYTE   0,0,0,H'40,H'4E,H'37    ; INIT USRT SEQUENCE

INITUART:
        MOVD    USRTCS+IOBEG,R1         ; {INIT USARTS}
        MOVQD   -6,R2                   ; FOR I=1,6 DO
UARTRST2:   
        MOVB    RUSRT+6:D[R2:B],0(R1)   ; migry add :D ;  USRT1_CONTROL:=RUSRT[I];
        MOVB    RUSRT+6:D[R2:B],(USRTCS2-USRTCS):W(R1) ; migry add :D ;
                                        ;  USRT2-CONTROL:=RUSRT[I];
        MOVW    1000,R3                 ; WAIT FOR USART TO SETTLE
        ACBW    -1,R3,$                 ;BEFORE NEXT COMMAND
        ACBB    1,R2,UARTRST2           ; END;
        RET     0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  R D C H R      ( DUMMY READ CHAR PROCEDURE )  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
RDCHR:  .PROC                   ; PROCEDURE RDCHR (WAIT,TRM)
RD_CHR: .BLKB   ;BYTE           ; PROCEDURE VALUE
RD_WAIT: .BLKB  ;BYTE           ; WAIT/NOWAIT FLAG
RD_TRM: .BLKB   ;BYTE           ; TERMINAL NUMBER
        .RETURNS
        .BLKW   ;WORD           ; RETURN CHR,CHR_RDY FLAG
        .VAR    [R1,R2]
        .BEGIN
        MOVD    USRTCS+IOBEG,R1 ; R1: ADDRESS OF TRMINAL A
        CMPQB   TRMA,RD_TRM     ; IF TRMINAL_NUM<> 0 THEN
        BEQ     RDCHRLP:B
        MOVD    USRTCS2+IOBEG,R1 ; R1: ADDRESS OF TRMINAL B
RDCHRLP:                        ; DO WHILE IN_RDY=0 AND RD_WAIT=TRUE
        TBITB   IN_RDY,0(R1)    ;   INPUT IN_RDY
        BFS     RDCHR3:B        
;       BR      RDCHR3:B        ; *** FOR DEBUG ONLY ***
        CMPQB   TRUE,RD_WAIT
        BEQ     RDCHRLP         ; END;
        BR      RDCHREX:B
RDCHR3: MOVB    (DATAP-USRTCS)(R1),RD_CHR ; RDCHR:=USART DATA
        MOVQB   TRUE,RD_WAIT    ; RD_WAIT:=TRUE
;
RDCHREX:
        .ENDPROC

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  P R C H R    ( PRINT CHARACTER )  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       FUNCTION - SEND ONE CHARACTER TO TERMINAL
;
;       CALLING SEQUENCE PRCHR(ENDF,WAIT,CHR,TRM)
;
;        ENDF/WAIT      
;               BOOLEANO  IN/OUT ON INPUT FLAGE WAIT TO END OF OPERATION
;                                OR REURN
;                                ON OUTPUT INDICATES END OF OPERATION
;        CHR  - CHARACTER INPUT  CHARACTER TO BE PRINTED
;        TRM  - INTEGER   INPUT  TERMINAL NUMBER
;
        .ALIGN 2
PRCHR:   .PROC
WAIT_PR: .BLKB  ;BYTE                   ; WAIT : BOOLEAN
CHR_PR:  .BLKB  ;BYTE                   ; ASCII CHR
TRM_CHR: .BLKB  ;BYTE                   ; TERMINAL NUMBER
DUMMY2:  .BLKB  ;BYTE for alignment
        .RETURNS
        .BLKB   ;BYTE                   ; OUTPUT WAIT WAIT:BOOLEAN
        .VAR    [R1,R2]
HOLD_:  .BLKB
A_WAIT: .BLKB
        .BEGIN
        MOVD    USRTCS+IOBEG,R1 ; R1: ADDRESS OF TRMINAL A
        CMPQB   TRMA,TRM_CHR    ; IF TRMINAL_NUM<> 0 THEN
        BEQ     PRCHRLP:B
        MOVD    USRTCS2+IOBEG,R1 ; R1: ADDRESS OF TRMINAL B
PRCHRLP: TBITB  OUT_RDY,0(R1)   ; IF TX-RDY = 0 
        BFS     PRCHR3:B        ; THEN
        CMPQB   FALSE,WAIT_PR   ;   IF WAIT THEN REPET
        BNE     PRCHRLP
        BR      PRCHREX:B               ;   ELSE WAIT:=FALSE
PRCHR3: MOVB    CHR_PR,(DATAP-USRTCS)(R1)
        MOVQB   TRUE,WAIT_PR    ; ELSE WRITE(DATA-PORT,CHR)
PRCHREX:
        CMPQB   TRMA,TRM_CHR
        BNE     P_OUT:W     
        ;++++++++++++++++
        MOVQW   FALSE, TOS      ;READ WITH NO WAIT
        MOVB    TRM_CHR, TOS    ;TERM A
        ;migry;SPRD    MOD, TOS
        BSR     RDCHR
        MOVB    TOS, A_WAIT     ;CLEAN STACK
        MOVB    TOS, HOLD_      ;
        ;----------------
        CMPQB   FALSE, A_WAIT   ;
        BEQ     P_OUT:W         ;IF NO INPUT THEN PRINT NEXT
        CMPB    XOFF, HOLD_     ;ELSE CHECK FOR XOFF SIGNAL
        BEQ     HOLD_LP:W       ;IF TRUE THEN GO INTO HOLD LOOP
        BR      P_OUT:W         ;ELSE BRANCH OUT AND PRINT NEXT
HOLD_LP:
        ;++++++++++++++++
        MOVQW   TRUE, TOS       ;READ WITH  WAIT
        MOVB    TRM_CHR, TOS    
        ;migry;SPRD    MOD, TOS
        BSR     RDCHR
        MOVB    TOS, A_WAIT     ;WAIT RETURN DOES NOT COUNT
        MOVB    TOS, HOLD_      ;GET CHAR
        ;----------------
        CMPB    HOLD_, XON      ;NO NOT PROCEED UNTIL XON
        BNE     HOLD_LP
P_OUT:
        .ENDPROC

;
;WILL READ DIP SWITCH AND PROGRAM USART FOR AUX PORT
;
INITAUXU:
        MOVD    R0,R1                   ;PARAM PASSED IN R0
        CMPQD   -1,R1
        BNE     SETP1:B
                                        ;    STARTING VALUE
        MOVZBD  @SWITCHP,R1             ; LOAD SWITCH FOR BAUD RATE
SETP1:
        ANDW    H'0F,R1
        movb    mo82531,@timcmo         ; set 8253 mode (square wave, select timer 1)
        movb    tb:w[r1:w],@timcd1      ; load lsb of count divisor
        movb    tb+1:w[r1:w],@timcd1    ; load msb of count divisor
        RET     0

;============================================================================
;;;;;;;;;;;;;;;;;;;;;;;;
; 8253 USART CONSTANTS ;
;;;;;;;;;;;;;;;;;;;;;;;;

; 0xc00050 to 0xc0005F          ; USART#1

; Programmable Interval Timer (8253)
;
pit_base:       .equ    io_base + x'050 ;Programmable interval timer
;
;               PIT register definitions
;
pit_c0:         .equ    0
pit_c1:         .equ    2
pit_c2:         .equ    4
pit_moff:       .equ    6
pit_mode:       .equ    pit_base + pit_moff
;
;               PIT mode register definitions
;
pit_bcd:        .equ    1
pit_binary:     .equ    0
pit_sc0:        .equ    0 << 6          ;select counter 0
pit_sc1:        .equ    1 << 6          ;select counter 1
pit_sc2:        .equ    2 << 6          ;select counter 2
pit_latch:      .equ    0 << 4          ;counter latching operation
pit_rllsb:      .equ    1 << 4          ;read / load lsbyte
pit_rlmsb:      .equ    2 << 4          ;read / load msbyte
pit_rlboth:     .equ    3 << 4          ;read / load lsbyte then msbyte
pit_rate_gen:   .equ    2 << 1          ;rate generator
pit_square:     .equ    3 << 1          ;square wave
;
;       Timer profile defintion (8253)

timcpo: .equ    h'c00050        ; port address for timer
timc_mo:.equ    6               ; offset for timer c mode 
timc_d1:.equ    2               ; offset to timer 1 data port
timc_d2:.equ    4               ; offset to timer 2 data port
timcmo: .equ    timcpo + timc_mo; port addr to timer mode
timcd1: .equ    timcpo + timc_d1; port addr for timer 1 data
timcd2: .equ    timcpo + timc_d2; port addr for timer 2 data
mo82531:.equ    h'76            ; required operation mode of 8253 timer 1
mo82532:.equ    h'b6            ; required operation mode of 8253 timer 2

; 8253 TIMER DIVISOR RATES FOR DB16A
;
tb:
TB:     .WORD   4,8,11,16               ; 19200,9600,7200,4800
        .WORD   21,32,38,43             ;  3600,2400,2000,1800
        .WORD   64,128,256,512          ;  1200,600,300,150
        .WORD   573,698,1024,1536       ;   134,110,75,50
;       Timer initialization sequence (after reset)

INITTIMER:
        MOVZBD  @SWITCHP,R1             ; LOAD SWITCH FOR BAUD RATE
        ANDW    H'0F,R1
        movb    mo82531,@timcmo         ; set 8253 mode (square wave, select timer 1)
        movb    tb:w[r1:w],@timcd1      ; load lsb of count divisor
        movb    tb+1:w[r1:w],@timcd1    ; load msb of count divisor
        movb    mo82532,@timcmo         ; set 8253 mode (square wave, select timer 2)
        movb    tb:w[r1:w],@timcd2      ; load lsb of count divisor
        movb    tb+1:w[r1:w],@timcd2    ; load msb of count divisor
        ret     0

;============================================================================
;
;  I C U   R E G.
;
ICUADR:  .EQU   H'FFFE00        ; ICU REGISTER  0 ADDRESS
ICU16:   .EQU   ICUADR+16*2     ; ICU REG 16
ICU22:   .EQU   ICUADR+22*2     ; ICU REG 22
ICU24:   .EQU   ICUADR+24*2     ; ICU REG 24
ICU28:   .EQU   ICUADR+28*2     ; ICU REG 28
icu_code:       .equ    x'b00
icu_min:        .equ     7373
icu_max:        .equ    65000

;
;
;  DIVIDE FACTOR FOR ICU COUNTER TO GENERATE USRT CLOCK
;   N := 1.84MHZ/(BAUD_RATE*16*2)
;          1.84 HZ IS CRYSTAL FREQUENCY (DIVIDE BY 12 TO GET 9600)
;          THE 16 FACTOR BEACUSE USRT DIVIDE BY 16
;          THE 2 FACTOR BEACUSE THE SQUARE WAVE CHANGES TWICE IN CYCLE
;     N-1 MUST BE WRITTEN TO ICU REG.
ICUTB:  .WORD   2,5,7,11                ; 19200,9600,7200,4800
        .WORD   15,23,28,31             ;  3600,2400,2000,1800
        .WORD   47,95,191,383           ;  1200,600,300,150
        .WORD   429,523,767,1151        ;   134,110,75,50

INITICU:
        MOVQB   0,@ICU16                ; 8 BITS MOD,COUT OUTPUT,SQUARE WAVE
        MOVQB   0,@ICU22                ; COUNTER HALT {ENABLE WRINIG OF 
                                        ;    STARTING VALUE
        MOVZBD  @SWITCHP,R1             ; LOAD SWITCH FOR BAUD RATE
        ANDB    H'0F,R1
        MOVB    ICUTB:W[R1:W],@ICU24    ; ICU24 := ICUTB[R1],ICU25 := 0; LOAD
        MOVB    ICUTB+1:W[R1:W],@ICU24+2;     COUNTING VALUE;
        MOVB    ICUTB:W[R1:W],@ICU28    ; ICU28 := ICUTB[R1],ICU29 := 0; INIT
        MOVB    ICUTB+1:W[R1:W],@ICU28+2;     COUNTING VALUE;
        MOVB    H'54,@ICU22             ; NOT PRESCALED,L COUNTER RUNNIG,
                                        ;  L COUNTER OUTPUT TO PIN COUT!
        RET     0

;============================================================================
;
;       PPI configuration       
;
;port A = INPUT(SELECT,BUSY)
;port B = OUTPUT(DATA STROBE)                           
;port C = OUTPUT(DATA)
;port A = bit 0 INPUT
;port B = bit 0 OUTPUT                          
PPI_CON:        .equ    h'90
PPI_BASE:       .equ    h'C00020        ;base 8255 PPI port address
PPI_A:          .equ    0               ;offset to port A
PPI_B:          .equ    2               ;offset to port B
PPI_C:          .equ    4               ;offset to port C
PPI_CNTL:       .equ    6               ;offset to control word


;               routine for print db16000 to centronics 307
;                       OR EQUIVALENT

;               H A R D W A R E     N O T E S
;         this is a low level I/O driver for running Centronics 307 or
; equivalent type strobed input line printers.
;       The program logic supports DB16000's with 8303 type transceivers
; on port A and 7437 type buffers on ports B and C. Stake pins 1-2 @W11
; must be straped together for proper operation.
;       The data strobe routine has been ISE tuned for maximum thruput
; and should not be changed.
;
PRINTC:         .proc
        VECP:   .blkd           ;vector to buffer
        PCNT:   .blkd           ;char count
                .var [r0,r1,r2,r3,r4,r5,r6,r7]  ;save r0=PPI_BASE, r7=counter, r1=vec base, r6=time out flag
                .begin
                    movqd   FALSE,r6                ;set time out flag to false
                    movd    PPI_BASE,r0     ;init addr mode for PPI I/O
                    movb    PPI_CON,PPI_CNTL(r0)    ;init 8255
                    movqb   pTRUE,PPI_B(r0)         ;init strobe to high
                    tbitb   PRI_SLCT,PPI_A(r0)      ;if selected then go on
                    bfc     PRLP:b                  ;else try to select
;               movb    com(DC1),PPI_C(r0)      ;output select control
                    movb    ~DC1, PPI_C(r0)
                    bsr     STROBIT:w               ;strobe it in
        PRLP:       MOVQB   TRUE, R4                ;DO LF WITH CR
                    TBITD   31, PCNT
                    BFC     PRILP:B
                    CBITD   31, PCNT
                    MOVQB   FALSE, R4
        PRILP:      ABSD    PCNT, PCNT
                    CMPQD   0, PCNT
                    BLT     PRILOOP:B
                    ADDQD   1, PCNT                 ;AVOID DUMMY MISTAKES
        PRILOOP:
                    bsr     BUSY                    ;wait till not busy
                    cmpqd   TRUE,r6                 ;if timed out 
                    beq     ABORT:b                 ;then abort printing
                    movb    0(VECP),r1              ;reverse logic drivers
                    comb    r1,r1                   ;must complement data
                    movb    r1,PPI_C(r0)            ;output a char  
                    bsr     STROBIT:w               ;strobe it in
                    CMPQB   FALSE, R4               ;CR CHRCK
                    BEQ     NOLF:B
;               CMPB    COM(CR), R1
                    cmpb    ~CR, R1
                    BNE     NOLF:B                  ;IF NOT CR THEN SKIP
                    bsr     BUSY                    ;wait till not busy
;               MOVB    COM(LF), PPI_C(r0)
                    MOVB    ~LF, PPI_C(r0)
                    bsr     STROBIT:w               ;strobe it in
        NOLF:       addqd   1,VECP                  ;vec to next char
                    acbd    -1,PCNT,PRILOOP         ;loop till PCNT=0
        ABORT:
                .endproc

STROBIT:        movzbd  STRB_TIME,r7    ;pulse active time init
                movqb   pTRUE,PPI_B(r0) ;pulse high
                acbb    -1,r7,$         ;wait high

                movzbd  STRB_TIME*2,r7
                movqb   pFALSE,PPI_B(r0)        ;pulse low
                acbb    -1,r7,$         ;wait low

                movzbd  STRB_TIME,r7
                movqb   pTRUE,PPI_B(r0) ;pulse high
                acbb    -1,r7,$

                ret 0

INI8255:
        movd    PPI_BASE,r0             ;init addr mode for PPI I/O
        movb    PPI_CON,PPI_CNTL(r0)    ;init 8255
        RET     0
                
PULSEHI:
        movd -5(fp),r5                  ; migry;movd    TCYCLE:B, r5             ;pulse active time init
        movqb   TRUE, PPI_B(r0)         ;pulse high
        acbd    -1, r5, $               ;wait high
        RET     0

PULSELO:
        movd -5(fp),r5                  ; migry;movd    TCYCLE:B, r5
        movqb   FALSE, PPI_B(r0)        ;pulse low
        acbd    -1, r5, $               ;wait low
        RET     0

BUSY:           br START1:w
        E_PRI:  .byte 'check lpt:',CR,LF
        M_NUM:  .equ ($ - E_PRI)

        START1:  movd    BUSY_WAIT,r7    ;initialize wait counter
                                        ;total wait ~ 20secs
        BLOOP:  tbitb   PRI_BUSY,PPI_A(r0)      
                bfs     CONTIN:b        ;if not busy then exit
                acbd    -1,r7,BLOOP     ;else loop 

                movqd   4,r0            ;set I/O parms -write ser port
                addr    E_PRI,r1        ; -address of error message
                movzbd  M_NUM,r2        ; - count char err
                movqd   0,r3            ;out to term 1
                movqd   TRUE, r6        ;timed out      
                svc                     ; pass to supervisor

        CONTIN: ret 0

#endif 
;+++++++++++++


;@@@@@@@@@@@@@@
#ifdef THEFORCE
;@@@@@@@@@@@@@@

diag_fail:     .equ    0xd00000
ds1:           .equ    0xd00036
ds2:           .equ    0xd00034
ds3:           .equ    0xd00032
PPI_A:         .equ    0           ;offset to port A

#ifdef THEFORCE_MK1
INTTAB: .EQU    H'6000     ; INTERRUPT TABLE ADDRESS FOR V1.03 ;updated by migry
TAPE_SAV: .EQU  H'7000
#endif
#ifdef THEFORCE_MK2
INTTAB: .EQU    H'07f00    ; INTERRUPT TABLE ADDRESS FOR THE FORCE MK2 (has 2Mb of RAM) ;updated by migry
TAPE_SAV: .EQU  H'50000
#endif

INITAUXU:
        RET     0
PULSELO:
        RET     0
PULSEHI:
        RET     0
INI8255:
        RET     0

                 
INITSTCK:      .equ 0xc000
;
; register offset from UART_base 
;
#ifdef THEFORCE_MK1
UART_BASE1:    .equ 0xc000
#endif
#ifdef THEFORCE_MK2
UART_BASE1:    .equ 0xc00000
#endif

UART_RBR:      .equ 0
UART_THR:      .equ 0
UART_IER:      .equ 2
UART_IIR:      .equ 4
UART_LCR:      .equ 6
UART_MCR:      .equ 8
UART_LSR:      .equ 10
UART_MSR:      .equ 12
UART_SCRATCH:  .equ 14
UART_DIV_LS:   .equ 0
UART_DIV_MS:   .equ 2
UART_LSR_DR:   .equ 0

;
;  I C U   R E G.
;
ICUBASE:  .EQU   H'FFFE00        ; ICU REGISTER  0 ADDRESS
ICU_SVCT: .EQU   ICUBASE+ 1*2    ; ICU REG  1 SVCT
ICU_ELTGL:.EQU   ICUBASE+ 2*2    ; ICU REG  2 ELTG lo
ICU_ELTGH:.EQU   ICUBASE+ 3*2    ; ICU REG  3 ELTG hi
ICU_TPLL: .EQU   ICUBASE+ 4*2    ; ICU REG  4 TRIGGERING POLARITY lo
ICU_TPLH: .EQU   ICUBASE+ 5*2    ; ICU REG  5 TRIGGERING POLARITY hi
ICU_MCTL: .EQU   ICUBASE+16*2    ; ICU REG 16 MODE CONTROL
ICU_PDAT: .EQU   ICUBASE+19*2    ; ICU REG 19 PORT DATA
ICU_IPS:  .EQU   ICUBASE+20*2    ; ICU REG 20
ICU_PDIR: .EQU   ICUBASE+21*2    ; ICU REG 21
ICU_CCTL: .EQU   ICUBASE+22*2    ; ICU REG 22
ICU_CIC:  .EQU   ICUBASE+23*2    ; ICU REG 23
ICU_LCSV: .EQU   ICUBASE+24*2    ; ICU REG 24
ICU_HCSV: .EQU   ICUBASE+26*2    ; ICU REG 26
ICU_LCCV: .EQU   ICUBASE+28*2    ; ICU REG 28
ICU_HCCV: .EQU   ICUBASE+30*2    ; ICU REG 30


MCTL_CFRZ:   .equ    1 << 7
MCTL_COUTD:  .equ    1 << 6
MCTL_CLKM:   .equ    1 << 4
MCTL_FRZ:    .equ    1 << 3
MCTL_NTAR:   .equ    1 << 1
MCTL_BUS8:   .equ    0

;--------------------------------------------------------------------
; RDCHR for the FORCE
;--------------------------------------------------------------------

        .ALIGN 2
RDCHR:   .PROC           ; PROCEDURE RDCHR (WAIT,TRM)
RD_CHR:  .BLKB   ;BYTE   ; PROCEDURE VALUE
RD_WAIT: .BLKB   ;BYTE   ; WAIT/NOWAIT FLAG
RD_TRM:  .BLKB   ;BYTE   ; TERMINAL NUMBER
         .RETURNS
         .BLKW   ;WORD   ; RETURN CHR,CHR_RDY FLAG
         .VAR    [R1]
         .BEGIN
           movd    UART_BASE1,r1   ; assume terminal #0
           CMPQB   TRMA,RD_TRM     ; IF TRMINAL_NUM<> 0 THEN
           BEQ     RDCHRF0:B
           movd    UART_BASE1,r1   ; no - terminal #1
RDCHRF0: 
           tbitb   UART_LSR_DR,UART_LSR(r1)
           bfs     RDCHRF1:b
           CMPQB   TRUE,RD_WAIT
           BEQ     RDCHRF0         ; END;
           BR      RDCHRFX:B
RDCHRF1: 
           movb    UART_RBR(r1),RD_CHR ; RDCHR:=USART DATA
           MOVQB   TRUE,RD_WAIT        ; RD_WAIT:=TRUE
RDCHRFX:
         .ENDPROC

;--------------------------------------------------------------------
; PRCHR for the FORCE
;--------------------------------------------------------------------

; does not implement the ctrl-S and ctrl-Q keys to stop and start scrolling

        .ALIGN 2
PRCHR:  .PROC
WAIT_PR: .BLKB  ;BYTE   ; WAIT : BOOLEAN
CHR_PR:  .BLKB  ;BYTE   ; ASCII CHR
TRM_CHR: .BLKB  ;BYTE   ; TERMINAL NUMBER
DUMMY2:  .BLKB  ;BYTE for alignment - migry
        .RETURNS
        .BLKB   ;BYTE   ; OUTPUT WAIT WAIT:BOOLEAN
        .VAR    [R1]
HOLD_:  .BLKB
A_WAIT: .BLKB
        .BEGIN
        NOP
#ifdef DEBUGTHEFORCE
        MOVW    0xfeed,@DEBUGD  ; migry - debug
#endif
        ;
        movd    UART_BASE1,r1   ; assume terminal #0
        CMPQB   TRMA,TRM_CHR    ; IF TRMINAL_NUM<> 0 THEN
        BEQ     PRCHRF0:B
        movd    UART_BASE1,r1   ; no - terminal #1
PRCHRF0: 
waittx:
        tbitb   #5,UART_LSR(r1)
        bfc     waittx
        movb    CHR_PR,UART_THR(r1)
        MOVQB   TRUE,WAIT_PR    ; return true/false?

        .ENDPROC

;--------------------------------------------------------------------
; PRINTC for the FORCE
;--------------------------------------------------------------------

        .ALIGN 2
PRINTC: .proc
VECP:   .blkd           ;vector to buffer
PCNT:   .blkd           ;char count
        .var [r0,r1,r2,r3,r4,r5,r6,r7]  ;save r0=PPI_BASE, r7=counter , r1=vec base, r6=time out flag 
        .begin
        NOP             ; no printer port so nothing to do
#ifdef DEBUGTHEFORCE
        movd    VECP,@DEBUGD
        movd    PCNT,@DEBUGD
#endif
        .endproc

;;;;;;;;;;;
; NS32202 ;
;;;;;;;;;;;
        .ALIGN 2
INITICU:
        MOVB    0x10,@ICU_SVCT              ; IRQ vector 0x10 to 0x20 (first 16 are reserved for traps)
        MOVB    0x00,@ICU_IPS               ; ports are I/O
        MOVB    0x00,@ICU_PDIR              ; ports are all output
        MOVB    ~0x55,@ICU_PDAT             ; initial pattern
        MOVB    0x02,@ICU_MCTL              ; 8 BITS INTERFACE,COUT OUTPUT,SQUARE WAVE,COUNTER OUTPUT TO PIN COUT
        MOVB    0xB0,@ICU_CCTL              ; COUNTER HALT
        ; load 32 bit counter starting value
        MOVB    0xff,@ICU_LCSV              ; 
        MOVB    0xff,@ICU_LCSV+2            ; 
        MOVB    0x3f,@ICU_HCSV              ; 
        MOVB    0x00,@ICU_HCSV+2            ; 
        ; load initial 32 bit current counter value
        MOVB    0x01,@ICU_LCCV              ; 
        MOVB    0x00,@ICU_LCCV+2            ; 
        MOVB    0x00,@ICU_HCCV              ; 
        MOVB    0x00,@ICU_HCCV+2            ; 
        ;
        MOVB    0xB8,@ICU_CCTL              ; 32 BIT COUNTER, CLK PRESCALED, COUNTER RUNNING, 
        ;
        MOVB    0x00,@ICU_IPS               ; ports are I/O
        MOVB    0x00,@ICU_PDIR              ; ports are all output
        MOVB    ~0xaa,@ICU_PDAT             ; initial pattern
        RET     0

;;;;;;;;;;;;;
;  IN16450  ; 
;;;;;;;;;;;;;
        .ALIGN 2
INITUART:
        movd    UART_BASE1,r0
        movb    0x87,UART_LCR(r0)      ;DLAB(bit 7)=1 to select the Divisor latch registers
        movb    6,UART_DIV_LS(r0)      ; 19200 Baud with 1.8432MHz XTAL
        movb    0,UART_DIV_MS(r0)
        movb    0x07,UART_LCR(r0)      ;DLAB(bit 7)=0 to deselect the Divisor latch registers
        movb    0x0c,UART_SCRATCH(r0)  ; holds LED state (start both off)
        movb    0x0c,UART_MCR(r0)      ; copy to LEDs (OUT1 & OUT2)
        movb    0x01,UART_IER(r0)      ; interrupt (sets LED) on character recevied
        movb    UART_RBR(r0),r1
        movb    UART_IIR(r0),r1
        movb    UART_LSR(r0),r1
        movb    UART_MSR(r0),r1
        RET     0

; GREEN LED = INTRPT (pin 30)
; RED   LED = OUT2   (pin 31)
; BLUE  LED = OUT1   (pin 34)

        .ALIGN 2
LED1OFF:                              ; OUT2
        save    [r1,r0]
        movd    UART_BASE1,r0
        movb    UART_SCRATCH(r0),r1
        orb     0x08,r1
        movb    r1,UART_SCRATCH(r0)
        movb    r1,UART_MCR(r0)
        restore [r1,r0]
        RET     0
        .ALIGN 2
LED1ON:                               ; OUT2
        save    [r1,r0]
        movd    UART_BASE1,r0
        movb    UART_SCRATCH(r0),r1
        andb    ~0x08,r1
        movb    r1,UART_SCRATCH(r0)
        movb    r1,UART_MCR(r0)
        restore [r1,r0]
        RET     0

        .ALIGN 2
LED2OFF:                              ; OUT1
        save    [r1,r0]
        movd    UART_BASE1,r0
        movb    UART_SCRATCH(r0),r1
        orb     0x04,r1
        movb    r1,UART_SCRATCH(r0)
        movb    r1,UART_MCR(r0)
        restore [r1,r0]
        RET     0
        .ALIGN 2
LED2ON:                               ; OUT1
        save    [r1,r0]
        movd    UART_BASE1,r0
        movb    UART_SCRATCH(r0),r1
        andb    ~0x04,r1
        movb    r1,UART_SCRATCH(r0)
        movb    r1,UART_MCR(r0)
        restore [r1,r0]
        RET     0

LED3ON:
        RET     0
LED3OFF:
        RET     0


ICU0RT:
        MOVB    ~0xe0,@ICU_PDAT 
        RETI
ICU1RT:
        MOVB    ~0xe1,@ICU_PDAT 
        RETI
ICU2RT:
        MOVB    ~0xe2,@ICU_PDAT 
        RETI
ICU3RT:
        MOVB    ~0xe3,@ICU_PDAT 
        RETI
ICU4RT:
        MOVB    ~0xe4,@ICU_PDAT 
        RETI
ICU5RT:
        MOVB    ~0xe5,@ICU_PDAT 
        RETI
ICU6RT:
        MOVB    ~0xe6,@ICU_PDAT 
        RETI
ICU7RT:
        MOVB    ~0xe7,@ICU_PDAT 
        RETI
ICU8RT:
        MOVB    ~0xe8,@ICU_PDAT 
        RETI
ICU9RT:
        MOVB    ~0xe9,@ICU_PDAT 
        RETI
ICU10RT:
        MOVB    ~0xea,@ICU_PDAT 
        RETI
ICU11RT:
        MOVB    ~0xeb,@ICU_PDAT 
        RETI
ICU12RT:
        MOVB    ~0xec,@ICU_PDAT 
        RETI
ICU13RT:
        MOVB    ~0xed,@ICU_PDAT 
        RETI
ICU14RT:
        MOVB    ~0xee,@ICU_PDAT 
        RETI
ICU15RT:
        MOVB    ~0xef,@ICU_PDAT 
        RETI

#endif
;@@@@@@@@@@@@@@

;+++++++++++++
#ifdef DB16000
;+++++++++++++
        .org     MODTB
MD_MAIN:
        ; standard MODULE TABLE ENTRY, composed of...
        .double SB_MAIN    ; Static Base Pointer
        .double 0          ; Link Base Pointer
        .double RESET      ; Program Base Pointer
        .double 0          ; reserved
; module descriptors normally done by the linker
MD_NVIRT:
        .double SB_NVIRT
        .double 0
        .double NVIRT
        .double 0
MD_NMIRT:
        .double SB_NMIRT
        .double 0
        .double NMIRT
        .double 0
MD_ABTRT:
        .double SB_ABTRT
        .double 0
        .double ABTRT
        .double 0
MD_FPURT:
        .double SB_FPURT
        .double 0
        .double FPURT
        .double 0
MD_ILLRT:
        .double SB_ILLRT
        .double 0
        .double ILLRT
        .double 0
MD_SVCRT:
        .double SB_SVCRT
        .double 0
        .double SVCRT
        .double 0
MD_DVZRT:
        .double SB_DVZRT
        .double 0
        .double DVZRT
        .double 0
MD_FLGRT:
        .double SB_FLGRT
        .double 0
        .double FLGRT
        .double 0
MD_BPTRT:
        .double SB_BPTRT
        .double 0
        .double BPTRT
        .double 0
MD_TRCRT:
        .double SB_TRCRT
        .double 0
        .double TRCRT
        .double 0
MD_UNINS:
        .double SB_UNINS
        .double 0
        .double INSRT
        .double 0
#endif
;+++++++++++++


        .org     INTTAB
        ; Interrupt/Trap Dispatch Table
        .word  MD_NVIRT    ; Maskable interrupt (label must exist in first 64k of address range)
        .word  0           ; OFFSET always zero (added to program base pointer)
        .word  MD_NMIRT    ; NON Maskable interrupt
        .word  0           ; OFFSET always zero
        .word  MD_ABTRT    ; Abort
        .word  0           ; OFFSET always zero
        .word  MD_FPURT    ; FPU (or other slave) trap
        .word  0           ; OFFSET always zero
        .word  MD_ILLRT    ; Illegal operation
        .word  0           ; OFFSET always zero
        .word  MD_SVCRT    ; Supervisor Call trap
        .word  0           ; OFFSET always zero
        .word  MD_DVZRT    ; Divide by Zero trap
        .word  0           ; OFFSET always zero
        .word  MD_FLGRT    ; Flag trap
        .word  0           ; OFFSET always zero
        .word  MD_BPTRT    ; BPT instruction was executed
        .word  0           ; OFFSET always zero
        .word  MD_TRCRT    ; Trace trap
        .word  0           ; OFFSET always zero
        .word  MD_UNINS    ; Undefined instruction trap
        .word  0           ; OFFSET always zero
        .word  0x11
        .word  0x0
        .word  0x12
        .word  0x0
        .word  0x13
        .word  0x0
        .word  0x14
        .word  0x0
        .word  0x15
        .word  0x0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
